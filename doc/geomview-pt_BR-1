This is ../../doc/geomview-pt_BR, produced by makeinfo version 4.13
from ../../doc/geomview-pt_BR.texi.

INFO-DIR-SECTION Graphics Applications
START-INFO-DIR-ENTRY
* Geomview: (geomview-pt_BR).         Programa interativo de visualizac,a~o tridimensional.
END-INFO-DIR-ENTRY




File: geomview-pt_BR,  Node: Top,  Next: Intro,  Prev: (dir),  Up: (dir)

   Programa interativo de visualizac,a~o tridimensional.

* Menu:

* Intro::                         Introduc,a~o ao Geomview.
* Distrib::                       Como acessar a versa~o mais recente do Geomview.
* Copiando::                      A Licenc,a Pu'blica Geral Menor do GNU.
* Historia::                      Histo'ria do Desenvolvimento do Geomview.
* Plantaformas::                  Plantaformas Suportadas.
* Pronuncia::                     Como Pronunciar ``Geomview''.
* Visao Geral::                   Visa~o Geral do Geomview.
* Tutorial::                      Tutorial Introduto'rio.
* Interacao::                     Interagindo com Geomview.
* Formatos dos Arquivos da OOGL:: Formatos para Inserc,a~o de Dados Geome'tricos.
* Customizacao::                  Modificando o comportamento do Geomview.
* Modulos::                       Programas que usam Geomview para exibic,a~o de
                                  imagens.
* GCL::                           GCL: a Linguagem de Comandos do Geomview.
* Geometrias Nao-Euclidianas::    Geometrias Na~o Euclideanas.
* Mathematica::                   Gra'ficos do Mathematica no Geomview ou no RenderMan.
* Instalacao::                    Instalando o Geomview no seu computador.
* Suporte::                       Acessando o Suporte Te'cnico para o Geomview.
* Contribuindo::                  Como contribuir com o Geomview.
* Indice de Funcoes::             Acesso ra'pido a cada func,a~o da GCL.
* Lista de Figuras::              Lista de Figuras.


File: geomview-pt_BR,  Node: Intro,  Next: Distrib,  Prev: Top,  Up: Top

Introduc,a~o ao Geomview
************************

Geomview e' um programa interativo para visualizar e controlar objetos
geome'tricos, originalmente escrito pelos membros do estado maior do
Geometry Center na Universidade de Minesota (EUA), comec,ando em 1991.
O Geomview pode ser usado como um visualizador independente para
objetos esta'ticos ou como um mecanismo de visualizac,a~o para outros
programas que produzem dinamicamente mudanc,as geome'tricas.  Geomview
roda sobre muitos tipos de computadores Unix, incluindo Linux, SGI,
Sun, e HP. Geomview tambe'm executa com Cygwin. Esse manual descreve
Geomview em sua versa~o 1.9.

   Geomview e' um "software" livre, disponi'vel sob os termos da
Licenc,a Pu'blica Geral Menor do GNU ; veja *note Copiando:: para
detalhes.

   Geomview e esse manual podem ser encontrados em
`http://www.geomview.org'.

   E' permitido fazer co'pias desse manual.

   Se voce^ tiver du'vidas ou comenta'rios sobre o Geomview ou esse
manual, considere inscrever-se na lista de correio eletro^nico
`geomview-users', que e' um fo'rum no qual usua'rios do Geomview
comunicam-se para responder outras questo~es e para compartilhar
noti'cias sobre o que eles esta~o fazendo com o Geomview.  Os autores
do Geomview participam dessa lista e algumas vezes enviam respostas a
questionamentos existentes.  Para assinar a lista, visite a pa'gina da
lista no si'tio
`http://lists.sourceforge.net/mailman/listinfo/geomview-users'.


File: geomview-pt_BR,  Node: Distrib,  Next: Copiando,  Prev: Intro,  Up: Top

Distribuic,a~o
**************

Geomview e' um "software" livre; isso significa que qualquer um e'
livre para usa'-lo e livre para redistribui'-lo sob certas condic,o~es.
Geomview na~o e' de domi'nio pu'blico; e' protegido por direitos
autorais e existem restric,o~es sobre sua distribuic,a~o, mas essas
restric,o~es sa~o montadas de forma a permitir qualquer coisa que um
bom cidada~o colaborador possa querer fazer.  O que na~o e' permitido
e' para tentar previnir outros de compartilhamento adicional de
qualquer versa~o do Geomview que eles possam pegar de voce^.  As
condic,o~es precisas podem ser encontradas na Licenc,a Geral Menor do
GNU que acompanha o Geomview e tambe'm aparece acompanhando essa
sec,a~o.

   Uma forma de acessar uma co'pia do Geomview e' a partir de algue'm
que ja' possua o Geomview.  Voce^ na~o precisa perguntar por nossa
permissa~o para fazer isso, ou informar qualquer coisa; apenas fac,a a
co'pia.  Se voce^ tiver acesso a` internet, voce^ pode pegar a mais
recente versa~o do Geomview em `http://www.geomview.org'.

   Voce^ tambe'm pode receber Geomview quando voce^ compra um
computador.  Fabricantes de computadores esta~o livres para distribuir
co'pias sob os mesmos termos que sa~o aplicados a qualquer pessoa.
Esses termos requerem que os fabricantes fornec,am a voce^ o co'digo
completo, incluindo qualquer mudanc,as que eles tenham feito, e
permitam a voce^ que redistribua o Geomview recebido deles nos termos
usuais da Licenc,a Pu'blica Geral Menor do GNU.  Em outras palavras, o
programa deve ser livre para voce^ quando voce^ o receber, na~o apenas
livre para o fabricante.


File: geomview-pt_BR,  Node: Copiando,  Next: Historia,  Prev: Distrib,  Up: Top

Copiando
********

     NOTA: Geomview e' distribui'do sob a LICENC,A PU'BLICA GERAL
     MENOR.  Para os propo'sitos dessa licenc,a  no's pensamos em Geomview como se ele
     fosse uma "biblioteca", e dos mo'dulos externos do Geomview como "programas que
     se comunicam com a biblioteca".  Fazemos isso porque queremos especificamente
     permitir que programas proprieta'rios e mo'dulos usem o Geomview.

LICENC,A PU'BLICA GERAL DO GNU
******************************

                      Version 2.1, February 1999

     Licenc,a Pu'blica Geral Menor do GNU

     This is an unofficial translation of the GNU Lesser General Public
     License into Portuguese. It was not published by the Free Software Foundation,
     and does not legally state the distribution terms for software that uses the
     GNU LGPL-only the original English text of the GNU LGPL does that. However,
     we hope that this translation will help Portuguese speakers understand the
     GNU LGPL better.

     Esta e' uma traduc,a~o na~o-oficial da GNU Lesser General Public
     License para o Portugue^s. Ela na~o e' publicada pela Free Software Foundation
     e na~o traz os termos de distribuic,a~o legal do software que usa a GNU LGPL - estes termos esta~o contidos apenas no texto da GNU LGPL original em ingle^s.
     No entanto, esperamos que esta traduc,a~o ajudara' no
     melhor entendimento da GNU LGPL em Portugue^s.

     Versa~o 2.1, Fevereiro de 1999

     Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA [Estados Unidos da Ame'rica]

     E' permitido a qualquer pessoa copiar e distribuir co'pias
     sem alterac,o~es deste documento de licenc,a, sendo vedada, entretanto, sua modificac,a~o.

     [Esta e' a primeira versa~o da GPL Menor a ser lanc,ada. Ela tambe'm constitui
     a sucessora da Licenc,a Pu'blica de Biblioteca do GNU, dai' o nu'mero 2.1. da versa~o].

     [This is the first released version of the Lesser GPL.  It also counts
      as the successor of the GNU Library Public License, version 2, hence
      the version number 2.1.]

Introduc,a~o
============

As licenc,as da maioria dos softwares sa~o elaboradas para suprimir sua
liberdade de compartilha'-los e modifica'-los. As Licenc,as Pu'blicas
do GNU, ao contra'rio, te^m o objetivo de assegurar sua liberdade para
compartilhar e modificar softwares livres para garantir que o software
seja livre para todos os seus usua'rios.

   A presente Licenc,a Pu'blica Geral Menor se aplica a alguns pacotes
de software especialmente designados - normalmente bibliotecas - da
Free Software Foundation e de outros autores que decidam utiliza'-la.
Voce^ pode utiliza'-la tambe'm, mas recomendamos que antes, voce^
analise cuidadosamente se esta licenc,a, ou a Licenc,a Pu'blica Geral
comum, e' a melhor estrate'gia a ser adotada em cada caso especi'fico,
tendo como base as explicac,o~es abaixo.

   Quando falamos de software livre, estamos nos referindo a liberdade
de uso e na~o de gratuidade de prec,o. Nossas Licenc,as Pu'blicas
Gerais sa~o elaboradas para garantir que voce^ tenha liberdade para
distribuir co'pias de software livre (cobrando por esse servic,o se
voce^ assim o desejar); que voce^ receba co'digo-fonte ou o obtenha, se
quiser; que voce^ modifique o software e utilize partes dele em novos
programas livres; e que voce^ tenha cie^ncia de que pode praticar estes
atos.

   A fim de proteger seus direitos, e' necessa'rio que fac,amos
restric,o~es que proi'bam distribui'dores de negar estes direitos a
voce^ ou de pedir que voce^ que renuncie a eles. Essas restric,o~es se
traduzem em determinadas responsabilidades que voce^ devera' assumir,
se vier a distribuir co'pias da biblioteca ou modifica'-la.

   Por exemplo, se voce^ distribuir co'pias da biblioteca, seja
gratuitamente ou mediante um valor, tera' de conceder a seus receptores
todos os direitos que estamos concedendo a voce^. Voce^ tera' de
garantir que eles, tambe'm, recebam ou possam obter o co'digo fonte. Se
voce^ ligar outro co'digo com a biblioteca, voce^ deve fornecer os
arquivos-objeto completos para os receptores, de modo que eles possam
liga'-los novamente com a biblioteca apo's terem feito mudanc,as na
biblioteca e recompilado a mesma. E voce^ tera' de exibir a eles esses
termos, para que eles conhec,am seus direitos.

   Protegemos seus direitos atrave's de um me'todo que envolve dois
passos: (1) estabelecemos direitos autorais sobre a biblioteca e (2)
oferecemos a voce^ esta licenc,a, que da' a voce^ permissa~o para
copiar, distribuir e/ou modificar a biblioteca.

   Para proteger cada distribuidor, queremos deixar bem claro que na~o
ha' nenhuma garantia para a biblioteca livre. Ale'm disso, se a
biblioteca for modificada por algue'm e passada adiante, os receptores
devem saber que o que eles te^m na~o e' a versa~o original, de modo que
a reputac,a~o do autor original na~o sera' afetada por problemas que
possam ser introduzidos por outros.

   Por fim, as patentes de software representam uma ameac,a constante
para a existe^ncia de qualquer programa livre. Queremos assegurar que
uma empresa na~o possa efetivamente restringir os usua'rios de um
programa livre por ter obtido uma licenc,a restritiva de um titular de
direitos de patente. Por isso, insistimos que qualquer licenc,a de
patente obtida para alguma versa~o da biblioteca seja consistente com a
plena liberdade de uso, especificada nesta licenc,a.

   A maior parte dos softwares do GNU, incluindo algumas bibliotecas,
esta' coberta pela Licenc,a Pu'blica Geral comum do GNU. A presente
Licenc,a Pu'blica Geral Menor do GNU se aplica a determinadas
bibliotecas designadas, sendo bastante diferente da Licenc,a Pu'blica
Geral comum. Usamos esta licenc,a para determinadas bibliotecas, a fim
de permitir a ligac,a~o dessas bibliotecas a programas na~o-livres.

   Quando um programa e' ligado a uma biblioteca, seja estaticamente ou
usando uma biblioteca compartilhada, essa combinac,a~o das duas e' em
termos legais uma obra combinada, uma derivac,a~o da biblioteca
original. Por essa raza~o, a Licenc,a Pu'blica Geral comum somente
permite essa ligac,a~o se a combinac,a~o como um todo atender a seus
crite'rios de liberdade. A Licenc,a Pu'blica Geral Menor permite
crite'rios mais flexi'veis para a ligac,a~o de outros co'digos a`
biblioteca.

   Chamamos esta licenc,a de Licenc,a Pu'blica Geral "Menor" porque ela
faz Menos para proteger a liberdade do usua'rio do que a Licenc,a
Pu'blica Geral comum. Ela tambe'm oferece a outros desenvolvedores de
software livre uma Menor vantagem na competic,a~o com com programas
na~o livres. Essas desvantagens sa~o o motivo pelo qual usamos a
Licenc,a Pu'blica Geral comum para muitas bibliotecas. Por outro lado,
em determinadas circunsta^ncias especiais, a licenc,a Menor oferece
vantagens.

   Por exemplo, em raras ocasio~es, pode existir uma necessidade
especial de se incentivar a mais ampla utilizac,a~o possi'vel de uma
determinada biblioteca, para que ela se torne um padra~o de fato. Para
conseguir isso, deve-se permitir que programas na~o-livres utilizem a
biblioteca. Um caso mais frequ"ente ocorre quando uma biblioteca livre
desempenha a mesma func,a~o de bibliotecas na~o-livres amplamente
usadas. Nesse caso, existem poucas vantagens em restringir a biblioteca
livre somente para software livre, enta~o utilizamos a Licenc,a
Pu'blica Geral Menor.

   Em outros casos, a permissa~o para usar uma determinada biblioteca
em programas na~o-livres possibilita que um maior nu'mero de pessoas
use um amplo leque de softwares livres. Por exemplo, a permissa~o para
usar a Biblioteca C do GNU permite que muito mais pessoas usem todo o
sistema operacional do GNU, bem como sua variante, o sistema
operacional do GNU/Linux.

   Mesmo protegendo a liberdade dos usua'rios em menor grau, a Licenc,a
Pu'blica Geral Menor garante ao usua'rio de um programa que esteja
ligado a` Biblioteca a liberdade e os meios para executar o programa,
usando uma versa~o modificada da Biblioteca.

   Seguem abaixo os termos e condic,o~es exatos para a co'pia,
distribuic,a~o e modificac,a~o. Preste muita atenc,a~o a` diferenc,a
entre uma "obra baseada na biblioteca" e uma "obra que usa a
biblioteca". O primeiro conte'm co'digo que e' derivado da biblioteca,
enquanto o segundo tem de ser combinado a` biblioteca para que possa
ser executado.

TERMOS E CONDIC,O~ES PARA CO'PIA, DISTRIBUIC,A~O E MODIFICAC,A~O
================================================================

  0. O presente Contrato de Licenc,a se aplica a qualquer biblioteca de
     software ou a outro programa que contenha um aviso colocado pelo
     titular dos direitos autorais ou outra parte autorizada,
     informando que ela pode ser distribui'da nos termos desta Licenc,a
     Pu'blica Geral Menor (tambe'm denominada "esta Licenc,a").  Cada
     licenciado doravante sera' denominado "voce^".

     Uma "biblioteca" significa uma colec,a~o de func,o~es de software
     e/ou dados preparados, de forma a serem convenientemente ligados
     com programas de aplicac,a~o (que usam algumas dessas func,o~es e
     dados) para formar executa'veis.

     O termo "Biblioteca", abaixo, refere-se a qualquer biblioteca de
     software ou obra que tenha sido distribui'da de acordo com esses
     termos. Uma "obra baseada na Biblioteca" significa tanto a
     Biblioteca como qualquer obra derivada, nos termos da legislac,a~o
     autoral: isto e', uma obra contendo a Biblioteca ou parte dela,
     seja sem alterac,o~es ou com modificac,o~es e/ou traduzida
     diretamente para outra linguagem. (Doravante, o termo
     "modificac,a~o" inclui, sem reservas, o termo "traduc,a~o").

     O "co'digo-fonte" de uma obra significa o formato preferencial da
     obra para que sejam feitas modificac,o~es na mesma. Para uma
     biblioteca, o co'digo-fonte completo significa todo o co'digo
     fonte para todos os mo'dulos contidos na mesma, ale'm de quaisquer
     arquivos de definic,a~o de interface associados, ale'm dos scripts
     utilizados para controlar a compilac,a~o e a instalac,a~o da
     biblioteca.

     Outras atividades que na~o a co'pia, distribuic,a~o e
     modificac,a~o na~o sa~o cobertas por esta Licenc,a; elas esta~o
     fora de seu escopo. O ato de executar um programa usando a
     Biblioteca na~o tem restric,o~es, e o resultado gerado a partir
     desse programa encontra-se coberto somente se seu conteu'do
     constituir uma obra baseada na Biblioteca (independente do uso da
     Biblioteca em uma ferramenta para escreve^-lo). Na verdade, isto
     dependera' daquilo que a Biblioteca faz e o que o programa que usa
     a biblioteca faz.

  1. Voce^ pode copiar e distribuir co'pias sem alterac,o~es do
     co'digo-fonte completo da Biblioteca ao recebe^-lo, em qualquer
     meio ou mi'dia, desde que publique, ostensiva e adequadamente, um
     aviso de direitos autorais (ou copyright) apropriado e uma
     notificac,a~o sobre a exonerac,a~o de garantias; mantenha intactas
     as informac,o~es, avisos ou notificac,o~es referentes a esta
     Licenc,a e a` ause^ncia de qualquer garantia; e distribua uma
     co'pia desta Licenc,a junto com a Biblioteca.

     Voce^ podera' cobrar um valor pelo ato fi'sico de transferir uma
     co'pia, e voce^ pode oferecer, se quiser, a protec,a~o de uma
     garantia em troca de um valor.

  2. Voce^ pode modificar sua co'pia ou co'pias da Biblioteca ou
     qualquer parte dela, formando, assim, uma obra baseada na
     Biblioteca, bem como copiar e distribuir essas modificac,o~es ou
     obra, em conformidade com a Cla'usula 1 acima, desde que atenda,
     ainda, a todas as seguintes condic,o~es:

       a. A obra modificada tem de ser, por si so', uma biblioteca de
          software.

       b. Voce^ tem de fazer com que os arquivos modificados contenham
          avisos, em destaque, de que voce^ modificou os arquivos e a
          data de qualquer modificac,a~o.

       c. Voce^ tem de fazer com que a obra como um todo seja
          licenciada, sem nenhum custo, a todos os terceiros, de acordo
          com esta Licenc,a.

       d. Se um dispositivo, na Biblioteca modificada, se referir a uma
          func,a~o ou a uma tabela de dados a ser fornecida por um
          programa de aplicac,a~o que usa esse dispositivo, outro que
          na~o um argumento transmitido quando o dispositivo e'
          invocado, nesse caso, voce^ tera' de fazer um esforc,o de
          boa-fe' para assegurar que, no caso de uma aplicac,a~o que
          na~o fornec,a essa func,a~o ou tabela, o dispositivo ainda
          assim opere, e ira' realizar qualquer parte de sua finalidade
          que permanecer significativa.

          (Por exemplo, uma func,a~o de uma biblioteca para computar
          rai'zes quadradas tem uma finalidade que e' completamente bem
          definida independentemente da aplicac,a~o. Por essa raza~o, a
          letra d, da Cla'usula 2, exige que qualquer func,a~o ou
          tabela fornecida pela aplicac,a~o, usada por essa func,a~o,
          tem de ser opcional: se a aplicac,a~o na~o fornece^-la, a
          func,a~o de rai'zes quadradas devera' ainda assim computar
          rai'zes quadradas).

     Essas exige^ncias se aplicam a` obra modificada como um todo. Se
     partes identifica'veis dessa obra na~o forem derivadas da
     Biblioteca e puderem ser consideradas razoavelmente, em si, como
     obras independentes e separadas, nesse caso, esta Licenc,a e seus
     termos na~o se aplicara~o a essas partes quando voce^
     distribui-las como obras separadas. Todavia, quando voce^
     distribuir essas mesmas partes como partes de um todo, que por si
     seja uma obra baseada na Biblioteca, a distribuic,a~o desse todo
     devera' ser realizada de acordo com esta Licenc,a, cujas
     respectivas permisso~es para outros licenciados extendem-se a`
     integralidade deste todo, dessa forma, a toda e qualquer parte,
     independentemente de quem a escreveu.

     Assim, esta cla'usula na~o tem a intenc,a~o de afirmar direitos ou
     contestar os seus direitos sobre uma obra escrita inteiramente por
     voce^; a intenc,a~o e', antes, de exercer o direito de controlar a
     distribuic,a~o de obras derivadas ou obras coletivas baseadas na
     Biblioteca.

     Ale'm disto, a simples agregac,a~o de outra obra, que na~o seja
     baseada na Biblioteca, a` Biblioteca (ou a uma obra baseada na
     Biblioteca) em um volume de meio ou mi'dia de armazenamento ou
     distribuic,a~o, na~o inclui esta outra obra no a^mbito desta
     Licenc,a.

  3. Voce^ podera' optar por aplicar os termos da Licenc,a Pu'blica
     Geral do GNU ao inve's desta Licenc,a, para uma determinada co'pia
     da Biblioteca. Para tanto, voce^ devera' alterar todos os avisos
     ou notificac,o~es que se refiram a esta Licenc,a, para que eles se
     refiram a` Licenc,a Pu'blica Geral comum do GNU, versa~o 2, ao
     inve's desta Licenc,a. (Se uma versa~o mais nova do que a versa~o
     2 da Licenc,a Pu'blica Geral comum do GNU tiver sido gerada,
     enta~o voce^ podera' especificar essa versa~o, se preferir). Na~o
     fac,a nenhuma outra alterac,a~o nesses avisos ou notificac,o~es.

     Uma vez que essa alterac,a~o tenha sido feita em uma determinada
     co'pia, ela e' irreversi'vel para esta co'pia, passando a Licenc,a
     Pu'blica Geral comum do GNU a ser aplicada para todas as co'pias e
     obras derivadas subsequ"entes, feitas a partir dessa co'pia.

     Essa opc,a~o e' u'til quando voce^ desejar copiar parte do co'digo
     da Biblioteca em um programa que na~o seja uma biblioteca.

  4. Voce^ podera' copiar e distribuir a Biblioteca (ou uma parte ou
     obra derivada dela, de acordo com a Cla'usula 2) em co'digo-objeto
     ou formato executa'vel, sob as Cla'usulas 1 e 2 acima, desde que
     inclua todo o co'digo-fonte correspondente, passi'vel de leitura
     pela ma'quina, que deve ser distribui'do sob os termos das
     Cla'usulas 1 e 2 acima, em um meio ou mi'dia costumeiramente
     utilizado para o interca^mbio de software.

     Se a distribuic,a~o do co'digo-objeto for feita pela oferta de
     acesso para co'pia a partir de um local designado, enta~o a
     permissa~o de acesso equivalente para copiar o co'digo-fonte a
     partir do mesmo local atende a exige^ncia de distribuic,a~o do
     co'digo-fonte, mesmo que terceiros na~o sejam levados a copiar a
     fonte junto com o co'digo-objeto.

  5. Um programa que na~o contenha nenhum derivativo de qualquer parte
     da Biblioteca, mas que seja desenhado para operar com a Biblioteca
     ao ser compilado ou ligado a ela, e' chamado de uma "obra que usa
     a Biblioteca". Essa obra, isoladamente, na~o e' uma obra derivada
     da Biblioteca e, portanto, fica de fora do a^mbito desta Licenc,a.

     Entretanto, a ligac,a~o de uma "obra que usa a Biblioteca" com a
     Biblioteca constitui um executa'vel que e' um derivado da
     Biblioteca (pois conte'm partes da Biblioteca), e na~o uma "obra
     que usa a Biblioteca". O executa'vel e', assim, coberto por esta
     Licenc,a.  A Cla'usula 6 estabelece os termos para a
     distribuic,a~o desses executa'veis.

     Quando uma "obra que usa a Biblioteca" usar material de um arquivo
     de cabec,alho que e' parte da Biblioteca, o co'digo-objeto para a
     obra podera' ser uma obra derivada da Biblioteca, mesmo que o
     co'digo-fonte na~o o seja.  Para que isto seja verdade, e'
     especialmente importante se a obra pode ser ligada sem a
     Biblioteca, ou se a obra e', em si mesma, uma biblioteca. O limiar
     para que isto seja verdade na~o e' definido com precisa~o pela lei.

     Se um arquivo-objeto usar somente para^metros nume'ricos, layouts
     e accessors da estrutura de dados, bem como pequenas macros e
     pequenas func,o~es inline (dez linhas ou menos de extensa~o),
     enta~o o uso do arquivo-objeto na~o e' restrito, independente de
     ser ele legalmente uma obra derivada. (Executa'veis contendo este
     co'digo-objeto mais partes da Biblioteca continuam submetidos aos
     termos da Cla'usula 6).

     Do contra'rio, se a obra for um derivado da Biblioteca, voce^
     podera' distribuir o co'digo objeto da obra sob os termos da
     Cla'usula 6.  Quaisquer executa'veis contendo esta obra tambe'm se
     submetmem a` Cla'usula 6, estejam ou na~o diretamente ligados a`
     Biblioteca em si.

  6. Como excec,a~o a` Cla'usula acima, voce^ tambe'm pode combinar ou
     ligar uma "obra que usa a Biblioteca" a` Biblioteca para produzir
     uma obra contendo partes da Biblioteca e distribui'-la de acordo
     com os termos de sua escolha, desde que estes termos permitam
     modificac,o~es na obra para uso pro'prio por parte do cliente e
     engenharia reversa para depurac,a~o dessas modificac,o~es.

     Em cada co'pia da obra, voce^ tera' de colocar um aviso, em
     destaque, de que a Biblioteca foi usada e que ela e seu uso esta~o
     cobertos por esta Licenc,a. Voce^ devera' fornecer uma co'pia
     desta Licenc,a. Se, durante a execuc,a~o, a obra exibir avisos ou
     notificac,o~es de direitos autorais (ou copyright), voce^ tera' de
     incluir, entre eles, o aviso de direitos autorais (ou copyright)
     referente a` Biblioteca, bem como uma refere^ncia direcionando o
     usua'rio para a co'pia desta Licenc,a. Ale'm disso, voce^ dever
     tomar ao menos uma das seguintes provide^ncias:

       a. Incluir na obra todo o co'digo-fonte da Biblioteca, passi'vel
          de leitura pela ma'quina, incluindo quaisquer modificac,o~es
          que foram usadas na obra (as quais devem ser distribui'das
          conforme as Cla'usulas 1 e 2 acima); e, se a obra for um
          executa'vel ligado a` Biblioteca, com toda a "obra que usa a
          Bilblioteca" passi'vel de leitura pela ma'quina, como
          co'digo-objeto e/ou co'digo-fonte, de modo que o usua'rio
          possa modificar a biblioteca e, depois, religar para produzir
          um executa'vel modificado contendo a Biblioteca modificada.
          (Fica entendido que o usua'rio que modificar o conteu'do dos
          arquivos de definic,o~es da Biblioteca na~o necessariamente
          sera' capaz de recompilar a aplicac,a~o para usar as
          definic,o~es modificadas).

       b. Usar um mecanismo adequado de biblioteca compartilhada para
          ligar com a Biblioteca. Um mecanismo adequado e' aquele que
          (a) usa, ao tempo da execuc,a~o, uma co'pia da biblioteca ja'
          presente no sistema do computador do usua'rio, e (2) ira'
          operar adequadamente com uma versa~o modificada da
          biblioteca, se o usua'rio instalar uma, desde que a versa~o
          modificada seja compati'vel com a interface da versa~o com a
          qual a obra foi feita.

       c. Incluir na obra uma oferta por escrito, va'lida por pelo
          menos 3 anos, oferencendo ao mesmo usua'rio os materiais
          especificados na letra "a" da Cla'usula 6 acima, por um custo
          na~o superior ao custo de fazer esta distribuic,a~o.

       d. Se a distribuic,a~o da obra for feita com a permissa~o de
          acesso para copiar, a partir de um local designado, oferecer
          acesso equivalente para copiar os materiais acima
          especificados, a partir do mesmo local.

       e. Certificar-se se o usua'rio ja' recebeu uma co'pia desses
          materiais ou de que voce^ ja' enviou uma co'pia a esse
          usua'rio.

     Para um executa'vel, o formato exigido da "obra que usa a
     Biblioteca" deve incluir quaisquer dados e programas utilita'rios
     necessa'rios para reproduc,a~o do executa'vel a partir dele.
     Todavia, como uma excec,a~o especial, os materiais a serem
     distribui'dos na~o necessitam incluir algo que seja normalmente
     distribui'do (tanto no formato fonte quanto bina'rio) com os
     componentes mais importantes (compilador, kernel, e assim por
     diante) do sistema operacional no qual executa'vel e' executado, a
     menos que esse componente, em si, acompanhe o executa'vel.

     Pode ocorrer que essa exige^ncia contradiga as restric,o~es da
     licenc,a de outras bibliotecas proprieta'rias que normalmente na~o
     acompanham o sistema operacional. Essa contradic,a~o significa que
     voce^ na~o pode utilizar ambas e a Biblioteca juntas em um
     executa'vel distribui'do por voce^.

  7. Voce^ pode colocar dispositivos da biblioteca que sejam uma obra
     baseada na Biblioteca lado-a-lado em uma u'nica biblioteca junto
     com outros dispositivos de bibliotecas, desde que uma
     distribuic,a~o separada da obra baseada na Biblioteca e dos outros
     dispositivos de bibliotecas seja, de outro modo, permitida e desde
     que voce^ tome uma das seguintes provide^ncias:

       a. Incluir na biblioteca combinada uma co'pia dessa obra baseada
          na Biblioteca sem a combinac,a~o com quaisquer outros
          dispositivos de biblioteca. Essa co'pia tem de ser
          distribui'da de acordo com as condic,o~es das cla'usulas
          acima.

       b. Junto com a biblioteca combinada, fornecer um aviso, em
          destaque, sobre o fato de que parte dela e' uma obra baseada
          na Biblioteca, e explicando onde encontrar o formato na~o
          combinado incluso dessa mesma obra.

  8. Voce^ na~o podera' copiar, modificar, sublicenciar, ligar, ou
     distribuir a Biblioteca, exceto conforme expressamente disposto
     nesta Licenc,a. Qualquer tentativa de, de outro modo, copiar,
     modificar, sublicenciar, ligar ou distribuir a Biblioteca e'
     inva'lida, e automaticamente terminara' seus direitos sob esta
     Licenc,a. Todavia, terceiros que tiverem recebido co'pias ou
     direitos de voce^, de acordo com esta Licenc,a, na~o tera~o seus
     direitos rescindidos, enquanto estes terceiros mantiverem o seu
     pleno cumprimento.

  9. Voce^ na~o e' obrigado a aceitar esta Licenc,a, uma vez que voce^
     na~o a assinou. Entretanto, nada mais concede a voce^ permissa~o
     para modificar ou distribuir a Biblioteca ou suas obras derivadas.
     Esses atos sa~o proibidos por lei se voce^ na~o aceitar esta
     Licenc,a. Portanto, ao modificar ou distribuir a Biblioteca (ou
     qualquer obra baseada na Biblioteca), voce^ manifesta sua
     aceitac,a~o desta Licenc,a para faze^-lo, bem como de todos os
     seus termos e condic,o~es para co'pia, distribuic,a~o ou
     modificac,a~o da Biblioteca ou obras nela baseadas.

 10. A cada vez que voce^ redistribuir a Biblioteca (ou qualquer obra
     nela baseada), o receptor automaticamente recebe uma licenc,a do
     licenciante original para copiar, distribuir, ligar ou modificar a
     Biblioteca, sujeito a estes respectivos termos e condic,o~es.
     Voce^ na~o podera' impor quaisquer restric,o~es adicionais ao
     exerci'cio, pelos receptores, dos direitos concedidos por este
     instrumento.  Voce^ na~o tem responsabilidade de promover o
     cumprimento desta licenc,a por parte de terceiros.

 11. Se, como resultado de uma sentenc,a judicial ou alegac,a~o de
     violac,a~o de patente, ou por qualquer outro motivo (na~o restrito
     a`s questo~es de patentes), forem impostas a voce^ condic,o~es
     (tanto atrave's de mandado judicial, contrato ou qualquer outra
     forma) que contradigam as condic,o~es desta Licenc,a, voce^ na~o
     estara' desobrigado quanto a`s condic,o~es desta Licenc,a. Se
     voce^ na~o puder atuar como distribuidor de modo a satisfazer
     simultaneamente suas obrigac,o~es sob esta Licenc,a e quaisquer
     outras obrigac,o~es pertinentes, enta~o, como consequ"e^ncia, voce^
     na~o podera' distribuir a Biblioteca de nenhuma forma. Por
     exemplo, se uma licenc,a sob uma patente na~o permite a
     redistribuic,a~o por parte de todos aqueles que tiverem recebido
     co'pias, direta ou indiretamente de voce^, sem o pagamento de
     royalties, enta~o, a u'nica forma de cumprir tanto com esta
     exige^ncia quanto com esta licenc,a sera' deixar de distribuir,
     por completo, a Biblioteca.

     Se qualquer parte desta Cla'usula for considerada inva'lida ou
     na~o executa'vel, sob qualquer circunsta^ncia especi'fica, o
     restante da cla'usula devera' continuar a ser aplicado e a
     cla'usula, como um todo, devera' ser aplicada em outras
     circunsta^ncias.

     Esta cla'usula na~o tem a finalidade de induzir voce^ a infringir
     quaisquer patentes ou direitos de propriedade, nem de contestar a
     validade de quaisquer reivindicac,o~es deste tipo; a u'nica
     finalidade desta cla'usula e' proteger a integridade do sistema de
     distribuic,a~o do software livre, o qual e' implementado mediante
     pra'ticas de licenc,as pu'blicas. Muitas pessoas te^m feito
     generosas contribuic,o~es a` ampla gama de software distribui'do
     atrave's desse sistema, confiando na aplicac,a~o consistente deste
     sistema; cabe ao autor/doador decidir se deseja distribuir software
     atrave's de qualquer outro sistema e um licenciado na~o pode impor
     esta escolha.

     Esta cla'usula visa deixar absolutamente claro o que se acredita
     ser uma consequ"e^ncia do restante desta Licenc,a.

 12. Se a distribuic,a~o e/ou uso da Biblioteca for restrito em
     determinados pai'ses, tanto por patentes ou por interfaces
     protegidas por direito autoral, o titular original dos direitos
     autorais que colocar a Biblioteca sob esta Licenc,a podera'
     acrescentar uma limitac,a~o geogra'fica de distribuic,a~o
     expli'cita excluindo esses pai'ses, de modo que a distribuic,a~o
     seja permitida somente nos pai'ses ou entre os pai'ses que na~o
     foram exclui'dos dessa forma. Nesse caso, esta Licenc,a passa a
     incorporar a limitac,a~o como se esta tivesse sido escrita no
     corpo desta Licenc,a

 13. A Free Software Foundation [Fundac,a~o Software Livre] podera' de
     tempos em tempos publicar verso~es revisadas e/ou novasda Licenc,a
     Pu'blica Geral Menor.  Essas novas verso~es sera~o semelhantes em
     espi'rito a` presente versa~o, podendo, pore'm, ter diferenc,as
     nos detalhes, para tratar de novos problemas ou preocupac,o~es.

     Cada versa~o recebe um nu'mero distinto de versa~o. Se a Biblioteca
     especificar um nu'mero de versa~o desta Licenc,a, aplica'vel a`
     Biblioteca ou a "qualquer versa~o posterior", voce^ tera' a
     opc,a~o de seguir os termos e condic,o~es tanto daquela versa~o
     como de qualquer versa~o posterior publicada pela Free Software
     Foundation. Se a Biblioteca na~o especificar um nu'mero de
     licenc,a da versa~o, voce^ podera' escolher qualquer versa~o ja'
     publicada pela Free Software Foundation.

 14. Se voce^ desejar incorporar partes da Biblioteca em outros
     programas livres cujas condic,o~es de distribuic,a~o sejam
     incompati'veis com estas, escreva ao autor para solicitar
     permissa~o. Para software cujos direitos autorais pertencerem a`
     Free Software Foundation, escreva a` Fundac,a~o; algumas vezes,
     fazemos excec,o~es nesse sentido. Nossa decisa~o sera' guiada
     pelos dois objetivos de preservar a condic,a~o livre de todos os
     derivados de nosso software livre e de promover o compartilhamento
     e reutilizac,a~o de softwares, de modo geral.

     _      EXCLUSA~O DE GARANTIA_

 15. COMO A BIBLIOTECA E' LICENCIADA SEM CUSTO, NA~O HA' NENHUMA
     GARANTIA PARA A BIBLIOTECA, NO LIMITE PERMITIDO PELA LEI
     APLICA'VEL.  EXCETO QUANDO DE OUTRA FORMA ESTABELECIDO POR
     ESCRITO, OS TITULARES DOS DIREITOS AUTORAIS E/OU OUTRAS PARTES
     FORNECEM A BIBLIOTECA "NO ESTADO EM QUE SE ENCONTRA", SEM NENHUMA
     GARANTIA DE QUALQUER TIPO, TANTO EXPRESSA COMO IMPLI'CITA,
     INCLUINDO, DENTRE OUTRAS, AS GARANTIAS IMPLI'CITAS DE
     COMERCIABILIDADE E ADEQUAC,A~O PARA UMA FINALIDADE ESPECI'FICA. O
     RISCO INTEGRAL QUANTO A` QUALIDADE E DESEMPENHO DA BIBLIOTECA E'
     ASSUMIDO POR VOCE^. CASO A BIBLIOTECA CONTENHA DEFEITOS, VOCE^
     ARCARA' COM OS CUSTOS DE TODOS OS SERVIC,OS, REPAROS OU
     CORREC,O~ES NECESSA'RIAS.

 16. EM NENHUMA CIRCUNSTA^NCIA, A MENOS QUE EXIGIDO PELA LEI APLICA'VEL
     OU ACORDADO POR ESCRITO, QUALQUER TITULAR DE DIREITOS AUTORAIS OU
     QUALQUER OUTRA PARTE QUE POSSA MODIFICAR E/OU REDISTRIBUIR A
     BIBLIOTECA, CONFORME PERMITIDO ACIMA, SERA' RESPONSA'VEL PARA COM
     VOCE^ POR DANOS, INCLUINDO ENTRE OUTROS QUAISQUER DANOS GERAIS,
     ESPECIAIS, FORTUITOS OU EMERGENTES, ADVINDOS DO USO OU
     IMPOSSIBILIDADE DE USO DA BIBLIOTECA (INCLUINDO, ENTRE OUTROS,
     PERDA DE DADOS, DADOS SENDO GERADOS DE FORMA IMPRECISA, PERDAS
     SOFRIDAS POR VOCE^ OU TERCEIROS OU A IMPOSSIBILIDADE DA BIBLIOTECA
     DE OPERAR COM QUALQUER OUTRO SOFTWARE), MESMO QUE ESSE TITULAR, OU
     OUTRA PARTE, TENHA SIDO AVISADO SOBRE A POSSIBILIDADE DESSES DANOS.


FINAL DOS TERMOS E CONDIC,O~ES
==============================

Como Aplicar Estes Termos para Suas Novas Bibliotecas
=====================================================

Se voce^ desenvolver uma nova biblioteca e quiser que ela seja da maior
utilidade possi'vel para o pu'blico, no's recomendamos fazer dela um
software livre que todos possam redistribuir e modificar. Voce^ pode
fazer isto permitindo a redistribuic,a~o sob estes termos (ou,
alternativamente, sob os termos da Licenc,a Pu'blica Geral comum)

   Para fazer isto, anexe as notificac,o~es seguintes a` biblioteca.
E' mais seguro anexa'-las ao comec,o de cada arquivo-fonte, de modo a
transmitir do modo mais eficiente a exclusa~o de garantia; e cada
arquivo deve ter ao menos a linha de "direitos autorais reservados" e
uma indicac,a~o de onde a notificac,a~o completa se encontra.

     UMA LINHA PARA INFORMAR O NOME DA BIBLIOTECA E UMA BREVE IDE'IA DO QUE ELA FAZ.
     Direitos Autorais Reservados (C) <ano>  NOME DO AUTOR

     Esta biblioteca e' software livre; voce^ pode redistribui'-la e/ou
     modifica'-la sob os termos da Licenc,a Pu'blica Geral
     Menor do GNU conforme publicada pela Free Software Foundation; tanto a
     versa~o 2.1 da Licenc,a, ou (a seu crite'rio) qualquer versa~o posterior.

     Esta biblioteca e' distribui'do na expectativa de que seja u'til,
     pore'm, SEM NENHUMA GARANTIA; nem mesmo a garantia impli'cita de
     COMERCIABILIDADE OU ADEQUAC,A~O A UMA FINALIDADE ESPECI'FICA. Consulte a Licenc,a Pu'blica
     Geral Menor do GNU para mais detalhes.

     Voce^ deve ter recebido uma co'pia da Licenc,a Pu'blica Geral Menor
     do GNU junto com esta biblioteca; se na~o, escreva para a Free Software
     Foundation, Inc., no enderec,o 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.

   Inclua tambe'm informac,o~es sobre como contatar voce^ por correio
eletro^nico e por meio postal.  Voce^ tambe'm pode solicitar a seu
empregador (se voce^ for um programador) ou a sua instituic,a~o
acade^mica, se for o caso, para assinar uma "renu'ncia de direitos
autorais" sobre a biblioteca, se necessa'rio. Segue um exemplo; altere
os nomes:

     A Yoyodyne Ltda., neste ato, renuncia a todos eventuais direitos autorais sobre a
     biblioteca 'Frob' (uma biblioteca para ajustar fechaduras), escrita por James
     Random Hacker.

     <Assinatura de Ty Coon>, 1 de abril de 1990
     Ty Coon, Presidente

   Isso e' tudo!


File: geomview-pt_BR,  Node: Historia,  Next: Plantaformas,  Prev: Copiando,  Up: Top

Histo'ria do Desenvolvimento do Geomview
****************************************

Geomview foi originalmente escrito no Geometry Center da the University
of Minnesota in Minneapolis.  O Geometry Center era um centro de
pesquisa e educac,a~o fundado pela National Science Foundation, com a
missa~o de promover pesquisa e comunicac,a~o de assuntos relacionados
a` matema'tica.  A maioria do trabalho era direcionado ao uso de
computadores para ajudar a visualizac,a~o de conceitos matema'ticos.

   O projeto que eventualmente levou ao Geomview comec,ou no vera~o de
1988 com o trabalho de Pat Hanrahan sobre um programa de visualizac,a~o
chamado MinneView.  Pouco tempo depois Charlie Gunn comec,ou o
desenvolvimento da OOGL (Object Oriented Graphics Language) juntamente
com o MinneView.  Muitas pessoas comtribuiram para a OOGL e o MinneView,
incluindo Stuart Levy, Mark Meuer, Tamara Munzner, Steve Anderson,
Mario Lopez, Todd Kaplan.

   Em 1991 o staff do Geometry Center comec,ou o trabalho sobre uma
nova e melhorada versa~o da OOGL, e um novo e melhorado programa de
visualizac,a~o, o qual eles chamaram Geomview.  Naquele tempo
essencialmente o u'nico jogo no comercio para gra'ficos interativos em
tre^s dimenso~es era Silicon Graphics (SGI), de forma que Geomview foi
desenvolvido inicialmente em estac,o~es de trabalho SGI, usando a IRIS
GL.  A primeira versa~o foi finalizada em Janeiro de 1992.  Essa
primeira versa~o tornou-se muito popular entre visitantes do Geometry
Center, e atrave's do ftp do Centro (isso ocorreu antes do advento da
web) pessoas em outras instituic,o~es comec,aram a usar essa primeira
versa~o tambe'm.

   Adicionalmente a estac,o~es de trabalho SGI o Geometry Center tinha
algumas poucas estac,o~es NeXT completas, de forma que apo's Geomview
estar sendo executado em ma'quinas SGIs a equipe desenvolveu uma
versa~o para NeXTStep tambe'm.  Nessa e'poca ouveram muitos milhares de
pessoas usando Geomview ao redor do mundo.

   Alguns anos depois a equipe portou Geomview para o X windows e a
OpenGL, e eventualmente, com o desaparecimento da NeXT, a versa~o para
NeXT seguiu o mesmo caminho.

   Nessa missa~o de incentivar a comunicac,a~o entre pesquisadores e
educadores, o Geometry Center desenvolveu um web site,
www.geom.umn.edu, mais tarde em 1993.  Esse foi um dos primeiros 300
si'tios na web que existiram no mundo.  Uma parte desse si'tio web era
certamente devotado ao Geomview, e ajudou a propagar o trabalho durante
sua existe^ncia.

   O Geometry Center fechou suas instalac,o~es de "tijolos e cimento"
em Agosto de 1998 (NSF cortou suas verbas), mas o si'tio web continuou
a existir, e o Geomview continuou a ser popular ao redor do mundo.  Em
Dezembro de 1999 algum membro da equipe original do Geometry Center
configurou `http://www.geomview.org' como casa permanente na web para o
Geomview.

   Os autores originais do Geomview, bem como va'rios outros voluna'rios
ao redor do mundo, esta~o ainda ativamente envolvidos na utilizac,a~o e
no desenvolvimento do Geomview.

* Menu:

* Autores::                     Autores.


File: geomview-pt_BR,  Node: Autores,  Prev: Historia,  Up: Historia

Autores
=======

Tamara Munzner, Stuart Levy, e Mark Phillips sa~o os autores originais
do Geomview. Celeste Fowler, Charlie Gunn, e Nathaniel Thurston tambe'm
fazem contribuic,o~es sgnificativas.  Daniel Krech e Scott Wisdom
fizeram o NeXTStep e a adaptac,a~o do RenderMan, e Daeron Meyer e Tim
Rowley fizeram a adaptac,a~o para o X windows.  Muitos outros membros
do estado maior do Geometry Center, bem como muitas pessoas em muitos
lugares, tambe'm contribui'ram.

   Mark Phillips escreveu esse manual, com ajuda substancial de Stuart
Levy e Tamara Munzner.  Inconta'veis usua'rios do Geomview tambe'm
foram de grande ajuda por meio da leitura do manual e indicando nossos
enganos.


File: geomview-pt_BR,  Node: Plantaformas,  Next: Pronuncia,  Prev: Historia,  Up: Top

Plantaformas Suportadas
***********************

Geomview 1.9 pode - em princi'pio - compilar e executar sobre quaisquer
claramente recentes sistemas operacionais semelhantes ao Unix.
Especificamente, Geomview executa sobre Linux e sobre Cygwin (Cygwin
emula um ambiente semelhante ao SystemV Unix environment sob o Microsoft
Windows). Desafortunadamente Geomview compila com MacOS X (Darwin), mas
aparentemente comunicac,o~es com Geomview por meio de pipes e sockets
causam falha de segmentaca~o. Sinta-se livre para consertar essa falha!
Veja *note Contribuindo::, para detalhes.


File: geomview-pt_BR,  Node: Pronuncia,  Next: Visao Geral,  Prev: Plantaformas,  Up: Top

Como Pronunciar "Geomview"
**************************

A palavra 'Geomview' e' uma combinac,a~o da primeira si'laba da palavra
'geometry', e da palavra 'view'. Os autores pronunciam Geomview como
uma palavra oxi'tona, isto e', tonicidade na primeira si'laba.

       GE-om-view

   Algumas pessoas colocam a tonicidade na segunda si'laba, onde
Geomview cai na palavra 'geometry', mas os autores originais, que
criaram o nome, preferem a pronu'ncia com tonicidade na primeira
si'laba.


File: geomview-pt_BR,  Node: Visao Geral,  Next: Tutorial,  Prev: Pronuncia,  Up: Top

1 Visa~o Geral
**************

O principal objetivo do Geomview e' mostrar objetos cuja geometria e'
fornecida, permitindo controle interativo sobre detalhes tais como
ponto de visa~o, velocidade de movimento, apare^ncia de superfi'cies e
linhas, e assim por diante.  Geomview pode manusear qualquer nu'mero de
objetos e permite controle coletivo ou separado sobre eles.

   A maneira mais simples de usar Geomview e' como um visualizador
independente para ver e controlar objetos.  Geomview pode mostrar
objetos descritos em uma variedade de formatos de arquivo.  Geomview e'
acompanhado com uma larga variedade de objetos como exemplo, e voce^
pode criar seus pro'prios objetos.

   Voce^ pode tambe'm usar Geomview para manusear os dados a serem
mostrados provenientes de outro programa que esta' sendo executado
simulta^neamente.  Como o outro programa modifica os dados, a imagem no
Geomview reflete as modificac,o~es.  Programas que geram objetos e
utilizam o Geomview para mostra'-los sa~o chamados _mo'dulos externos_.
Mo'dulos externos podem controlar quase todos os aspectos do Geomview.
A ide'ia aqui e' que muitos aspectos de visualizac,a~o e partes da
interac,a~o de programas geome'tricos sa~o independentes do conteu'do
geome'trico e podem ser coletados conjuntamente em uma pec,a simples de
programa que pode ser usada em uma larga variedade de situac,o~es.  O
autor de um mo'dulo externo pode concentrar-se sobre a implementac,a~o
dos algori'tmos desejados e deixar os aspectos de visualizac,a~o ao
Geomview.  Geomview e' acompanhado por uma colec,a~o de mo'dulos
externos a ti'tulo de exemplo, e esse manual descreve como escrever seu
pro'prio _mo'dulo externo_.

   Geomview e' o produto de um esforc,o no "Geometry Center" para
disponibilizar um "software" de geometria interativa que e'
particularmente apropriado para pesquisa matema'tica e educac,a~o.  Em
particular, Geomview pode mostrar coisas no espac,o hiperbo'lico e no
espac,o esfe'rico bem como no espac,o Euclidiano.

   Geomview permite mu'ltiplos objetos e ca^meras que sa~o controlados
independentemente.  As ca^meras fornecem controle interativo para
movimento, apare^ncias (incluindo iluminac,a~o, sombreamento, e
materiais), selecionando um objeto, aresta ou ni'vel de ve'rtice,
instanta^neos em um arquivo de imagem SGI ou no formato Renderman RIB,
a adic,a~o ou apagamento de objetos e' possi'vel atrave's do controle
direto do mouse, paine'is de controle, e teclas de atalho via teclado.

   Geomview suporta os seguintes tipos de dados simples: poliedros com
ve'rtices compartilhados (.off), quadrila'teros, malhas retangulares,
vetores, e ajustes em superfi'cies de Bezier de grau arbitra'rio
incluindo ajustes racionais. Hierarqui'as de objetos podem ser
construi'das com listas de objetos e insta^ncias de objeto(s)
transformado(s) por uma ou mais matrizes 4x4.  Porc,o~es arbitra'rias
de modificac,o~es de hierarqui'as podem ser transmitidas por meio da
criac,a~o de refere^ncias nomeadas.

   Geomview pode mostrar sai'das gra'ficas tridimensionais provenientes
do Mathematica e do Maple.


File: geomview-pt_BR,  Node: Tutorial,  Next: Interacao,  Prev: Visao Geral,  Up: Top

2 Tutorial
**********

Esse capi'tulo conduzira' voce^ atrave's de alguns usos elementares do
Geomview.  Traba-lhando do comec,o ao fim desse capi'tulo de frente a
um computador onde voce^ pode tentar acompanhar os exemplos fornecidos
aqui voce^ recebera' um pouco do que pode ser feito com Geomview.

   Para iniciar o Geomview, coloque seu usua'rio e sua senha no
computador e abra uma janela de shell.  Uma janela de shell e' uma
janela na qual voce^ pode digitar comandos Unix; o prompt na janela
usualmente termina com um '%'.  Na janela de shell (o cursor do mouse
deve estar posicionado sobre a janela) digite o seguinte (`<Enter>' aqui
significa pressione a tecla "Enter"):

     geomview tetra dodec <Enter>

   Esse comando inicia o Geomview e chama dois objetos exemplo, um
tetraedro e um dodecaedro.  Apo's poucos segundos tre^s janelas ira~o
aparecer; *note Figure: figinitial.

 Figura 2.1: Tela Inicial do Geomview.

   O painel a` esquerda e' o painel de controle principal do Geomview;
Esse painel e' chamado de painel _Main_ (principal).  O painel menor ao
centro e' o painel _Tools_ (de ferramentas) e serve para selecionar
diferentes tipos de movimentos.  A janela do lado direito e' a janela
de ca^mera e nessa janela voce^ ve^ um tetraedro grande e um dodecaedro
que esta' parcialmente obscurecido pelo tetraedro.

   Geomview tem alguns paine'is mas por padra~o ele mostra somente
esses tre^s.  iremos descrever alguns aspectos desses tre^s e alguns
dos outros nesse tutorial.  Voce^ pode ler mais sobre esses e outros
paine'is nos capi'tulos adiante neste manual.

   Coloque o cursor do mouse na janela de ca^mera e pressione e
mantenha pressionado o bota~o esquerdo do mouse.  Agora, enquanto
mante'm pressionado o bota~o, lentamente mova o mouse com movimentos
pequenos.  Voce^ vera' a figura rotacionar na direc,a~o na qual voce^
mover o mouse.    Se voce^ liberar o bota~o do mouse enquanto move o
mesmo, a figura continua girando.  Para parar o movimento de rotac,a~o,
mantenha o mouse sobre a figura e pressione rapidamente o bota~o
esquerdo do mesmo.

   Geomview utiliza o modelo da _esfera de vidro_ para os movimentos
iniciados atrave's do mouse.  Isso significa que voce^ esta' supondo o
objeto como estando dentro de uma esfera invisi'vel e o cursor do mouse
como sendo uma alc,a fora da esfera provida de uma ventosa.  Quando
voce^ mante'm pressionado o bota~o esquerdo do mouse, a ventosa da
alc,a gruda na esfera; quando voce^ libera o bota~o do mouse, a ventosa
da alc,a libera a esfera.  Movendo o mouse enquanto mante'm pressionado
o bota~o faz com que a esfera (e concequ"e^ntemente o objeto) mova-se
na mesma direc,a~o que o mouse.

   Adicionalmente para os dois so'lidos que esta~o atualmente na tela
voce^ pode tambe'm ver duas molduras de fios em forma de caixa na
janela de ca^mera.  Essas sa~o as "caixas associadas" dos dois objetos.
Por padra~o Geomview coloca uma caixa associada em torno de cada objeto
que e' mostrada de forma que voce^ tenha uma ide'ia de o quanto grande
o objeto e'.

   Note que quando voce^ move o mouse em torno do tetraedro e do
dodecaedro eles se movem como se fossem uma u'nica figura.  Isso ocorre
porque por padra~o o que voce^ esta' movendo atualmente e' o "World"
(objeto mundo).  Para mover um dos objetos individualmente em lugar de
o objeto mundo como um todo, mova o cursor do mouse para o navegador de
alvos (_Targets_) no painel principal (_Main_).  Clique (qualquer
bota~o) sobre a palavra _tetra_.  Isso faz com que o tetraedro seja o
"objeto alvo".  Agora mova o cursor de volta a` janela de ca^mera e
voce^ podera' rotacionar apenas o tetraedro.

   O movimento que voce^ aplicou ate' agora foi a rotac,a~o, porque
esse e' o modo de modo de movimento selecionado no painel de ferramentas
(_Tools_).  Para efetuar o movimento de translac,a~o em lugar do
movimento de rotac,a~o, clique sobre o bota~o translac,a~o
(_Translate_).  Agora quando voce^ mover o mouse na janela de ca^mera
enquanto mante'm pressionado o bota~o esquerdo, o tetraedro (que deve
ser ainda o objeto alvo de antes) ira' ser transladado na direc,a~o que
voce^ move o mouse.  Note que voce^ pode transladar o tetraedro na
direc,a~o da borda da janela enquanto voce^ mante'm pressionado o
bota~o esquerdo do mouse.  Se voce^ liberar o bota~o do mouse enquanto
move o mesmo, o tetraedro ira' continuar o movimento sozinho.  O
tetraedro mover-se-a' ao contra'rio do que ocorria antes muito
rapidamente de forma que e' muito fa'cil perder o rastro de onde ele se
encontra.

   Se voce^ acidentalmente perder o tetraedro atrave's de translac,a~o
para muito longe da janela de visa~o, voce^ pode pega'-lo de volta
atrave's de um clique sobre o bota~o Centro (_Center_) no painel de
ferramentas (_Tools_).  Isso fara' com que o tetraedro retorne para a
sua posic,a~o inicial.

   Clique sobre o bota~o Centro (_Center_) para trazer o tetraedro ao
centro da janela de ca^mera, e enta~o coloque-o em uma posic,a~o de
forma que voce^ possa ver completamente o dodecaedro.

   Seu objeto mundo agora tem dois objetos que esta~o um ao lado do
outro.  Voce^ pode ver o dodecaedro no meio da janela de ca^mera e pode
ver parte do tetraedro parcialmente fora da janela de ca^mera.  Volte
para o navegador de alvos (_Targets_) no painel principal (_Main_) e
clique sobre o "World" para selecionar o referido objeto mundo
novamente.  Agora clique sobre o bota~o "Olhar Para" (_Look At_) no
painel de ferramentas (_Tools_). Voce^ pode ver o dodecaedro e o
tetraedro ajustando-se ao meio da janela (figura *note
figlookatworld::).  O bota~o "Olhar Para" (_Look At_) posiciona a
ca^mera em uma posic,a~o tal que o objeto alvo fique centrado na janela.
 Figura 2.2: Olhando para o Objeto Mundo.

   Agora coloque o cursor sobre o meio do dodecaedro e de^ sobre ele um
duplo clique com o bota~o direito do mouse.  Isso significa clicar no
mouse para baixo e para cima duas vezes em uma ra'pida sucessa~o.  Note
que o dodecaedro torna-se o objeto alvo; voce^ pode ver isso no
navegador de alvos (_Targets_) do painel principal (_Main_).  Um duplo
clique no bota~o direito do mouse sobre um objeto e' outra forma de
fazer esse objeto tornar-se o objeto alvo.

 [image src="figs/ap.png" ]

Figura 2.3: A Painel Apare^ncia.

   Va' para o menu _Inspect_ no topo do painel principal (_Main_) e
selecione Apare^ncia (_Appearance_).  Isso faz aparecer o painel
"Apare^ncia" (_Appearance_).  Quando ele aparece, se estiver
parcialmente obscurecido por outra janela do Geomview voce^ pode
move^-lo para um lado arrastando sua moldura com o bota~o do meio do
mouse pressionado.

   O painel Apare^ncia (_Appearance_) permite a voce^ controlar va'rias
coisas sobre a maneira como o Geomview desenha objetos.  Note os
boto~es rotulados com _[af] Faces_ e _[ae] Edges_ (arestas).  Clique
sobre o _[ae] Edges_ uma vez, e note que Geomview agora
ressalta/destaca as arestas do dodecaedro.  Clique sobre o _[ae] Edges_
novamente e as arestas desaparecem.  Clique muitas vezes e assista as
arestas indo e voltando.  Quando voce^ tiver feito isso o suficiente,
deixe as arestas habilitadas e clique sobre o bota~o _[af] Faces_.
Essa ac,a~o alterna entre exibir ou na~o as faces.  Clique sobre o
bota~o novamente para de forma que a exibic,a~o das face fique
habilitada.

   Agora clique sobre o bota~o _[Cf] Faces_ sob a palavra _COLOR_. Um
painel de escolha de cores aparecera' (*note Figure: figcolorchooser.).
 Figura 2.4: Painel de Escolha de Cores.

   Note os tre^s boto~es deslizantes, _H_, _S_, e _V_, controlando a
matiz (_hue_), saturac,a~o, e valor (iluminac,a~o).  Clicando sobre o
bota~o _HSV_ fornece um diferente conjunto de boto~es deslizantes, um
para vermelho (_red_), outro para verde (_green_), e outro para azul (_
blue_).  Valores nume'ricos para ambos os sistemas de cores RGB e HSV
podem ser vistos ou editados na parte inferior do painel.  A cor
inicial do dodecaedro foi especificada no arquivo `dodec' que voce^
chamou quando iniciamos o Geomview.  A cor que voce^ especificou com o
painel de cores sobrescreveu as cores antigas.  Voce^ pode ajustar a
intensidade da cor com o bota~o deslizante _Intensity_.  Quando voce^
encontrar uma cor que voce^ gosta, clique sobre o bota~o _Done_.

   Agora coloque o cursor do mouse em algum lugar sobre sobre o fundo
cinza da janela de ca^mera e duplo-clique no bota~o direito; isso
seleciona "World" como objeto alvo.  Clique no bota~o _Look At_ para
para olhar para o objeto mundo novamente.

   Note que no painel de Apare^ncia (_Appearance_) as escolhas dos
boto~es se modificavam a` medida que o lado esquerdo tambe'm mudava com
o dodecaedro.  Isso ocorre porque o painel _Appearance_ sempre mostra
as escolhas para o objeto alvo, que agora e' o objeto mundo, o qual
ainda tem suas escolhas padra~o.

   Clique sobre o bota~o _[ab] BBox_ sob a palavra _Draw_.  A caixa
associada desaparece.  agora ponha o cursor de volta na janela de
ca^mera.  No teclado, digite as teclas `a 'b.  Note que a caixa
associada aparece novamente.  `a 'b e' o atalho de teclado para o
bota~o que alterna entre a exibic,a~o ou na~o da caixa associada; a
seque^ncia de caracteres "[ab]" aparece sobre o bota~o para indicar
isso.  A maioria dos boto~es do Geomview possuem atalhos de teclado que
voce^ pode usar se preferir.  Isso sera' u'ltil quando voce^ estiver
familiarizado com o Geomview e na~o quiser ter de se mover entre uma
montanha de paine'is.

   Agora selecione o tetraedro, use qualquer das duas formas:
duplo-clicando o bota~o direito do mouse sobre o tetraedro, ou
selecionando "tetra" no navegador de alvos (_Targets_).  Enta~o clique
sobre o bota~o _Delete_ do menu _Edit_ no painel principal (_Main_).  O
tetraedro deve desaparecer.  Essa e' a forma de voce^ se livrar de um
objeto.

   Voce^ pode tambe'm chamar objetos de dentro do Geomview.  Clique
sobre o menu _File_ no painel principal (_Main_) e escolha abrir
(_Open_).  O painel de arquivos (_Files_) ira' aparecer.  Abaixo do
meio desse painel, onde se le^ _Path List_, temos um navegador com
tre^s linhas dentro dele; a segunda linha e' um direto'rio com
montanhas de exemplos do Geomview.  Clique sobre aquela segunda linha;
*note Figure: figfilespanel. Role para baixo na lista de arquivos ate'
voce^ ver `tref.off'.  Clique sobre aquela linha, e enta~o clique sobre
o bota~o _OK_.  Um grande tubo em forma de trevo ira' aparecer em sua
janela.  Clique sobre o bota~o _Hide_ no painel _Files_ para dispensar
o painel.

 Figura 2.5: O Painel de Arquivos.

   Agora clique sobre o bota~o _Reset_ no painel de ferramentas
(_Tools_).  Isso fara' com que todas as figuras retornem ao centro da
janela de ca^mera.  Voce^ pode ver um dodecaedro e uma protubera^ncia
do trevo (*note Figure: figtrefdodec.).

   Brinque com a protubera^ncia do trevo e o dodecaedro.  Fac,a
experie^ncias com alguns outros boto~es no painel de ferramentas
(_Tools_).  Tente colorir o trevo com o painel de apare^ncia
(_Appearance_).

   Para um tutorial sobre criar seus pro'prios objetos para chama'-los
dentro do Geomview, veja `doc/oogltour' distribuido com Geomview.  As
coisas naquele arquivo ira~o ser incorporadas em futuras verso~es desse
manual.

 Figura 2.6: Trevo e Dodecaedro.


File: geomview-pt_BR,  Node: Interacao,  Next: Formatos dos Arquivos da OOGL,  Prev: Tutorial,  Up: Top

3 Interac,a~o
*************

Esse capi'tulo descreve como voce^ interage com Geomview atrave's do
mouse e do teclado.

* Menu:

* Iniciando o Geomview::        Iniciando o Geomview.
* Opcoes de Linha de Comando::  Opc,o~es de Linha de Comando.
* Interacao Basica::            Interac,o~es Ba'sicas: O Painel Principal.
* Chamando::                    Chamando Objetos Dentro do Geomview.
* Movimentos do Mouse::         Usando o Mouse para Controlar Objetos.
* Aparencia::                   Modificando a Forma de Ver as Coisas.
* Cameras::                     Ca^meras.
* Gravando::                    Gravando seu Trabalho.
* Comandos::                    O Painel de Comandos.
* Atalhos de Teclado::          Atalhos de Teclado.


File: geomview-pt_BR,  Node: Iniciando o Geomview,  Next: Opcoes de Linha de Comando,  Prev: Interacao,  Up: Interacao

3.1 Iniciando o Geomview
========================

A forma usual para iniciar o Geomview e' digitar `geomview <Enter>' em
uma janela de shell (<Enter> significa pressionar a tecla "Enter").
Esse procedimento carrega o Geomview na memo'ria do computador em uns
poucos segundos; uma ou mais janelas ira~o aparecer e voce^ pode
comec,ar a interagir com o Geomview imediatamente.

   E' tambe'm possi'vel especificar ac,o~es para o Geomview executar no
momento de iniciar fornecendo argumentos na linha de comando do shell.
Veja *note Opcoes de Linha de Comando::.


File: geomview-pt_BR,  Node: Opcoes de Linha de Comando,  Next: Interacao Basica,  Prev: Iniciando o Geomview,  Up: Interacao

3.2 Opc,o~es de Linha de Comando
================================

Aqui esta~o as opc,o~es de linha de comando que o Geomview permite:

`-b R G b'
     Escolhe a cor de fundo da janela de ca^mera para valores
     fornecidos de R G b.

`-c ARQUIVO'
     Interpreta os comandos GCL em ARQUIVO, que pode ser o si'mbolo
     especial `-' para a entrada padra~o.  Para uma descric,a~o de GCL,
     veja *note GCL::.

`-c COMANDO'
     Comandos podem tambe'm serem fornecidos literalmente, como em
          -c "(ui-panel main off)"
     Uma vez que COMANDO inclui pare^ntesis, que possuem significado
     especial para o shell, COMANDO deve receber apo'strofo.  Multiplas
     opc,o~es -C sa~o permitidas.

`-wins N'
     Faz com que Geomview mostre inicialmente N janelas de ca^mera.

`-wpos LARGURA,ALTURA[@XMIN,YMIN]'
     Especifica a localizac,a~o inicial e o tamanho da primeira janela
     de ca^mera.  Os valores para LARGURA, ALTURA, XMIN, e YMIN esta~o
     em coordenadas de tela (pixel).

`-M[cg][ps[un|in|in6]] PIPENOME|TCPPORT'
     A opc,a~o `-M' aceita modificadores: um sufixo `g' espera dados
     geome'tricos (o padra~o), enquanto um sufixo `c' espera comandos
     GCL. Um `p' implica que a conecc,a~o pode usar um pipe nomeado (o
     padra~o para tudo exceto para "NeXT"), enquanto `s' implica no uso
     de um "UNIX-domain socket" (o padra~o em "NeXT"). Uma vez que na
     versa~o 1.9 do Geomview "Internet domain sockets" sa~o tambe'm
     suportados; use `sin' para fazer o Geomview escutar uma porta IPv4
     fornecida por TCPPORT, ou use `sin6' para fazer Geomview escute
     uma porta IPv6 (tambe'm como especificado em TCPPORT). `sun' e' um
     sino^nimo para `s', i.e. use o "Unix domain socket" com o nome
     PIPENOME. Se PIPENOME inicia com uma barra ('/'), enta~o esse nome
     e' assumido ser um caminho absoluto, de outra forma o pipe nomeado
     ou socket e' criado sob o direto'rio `${TMPDIR}/geomview/'.

     Escutando fluxo de comando em portas TCP pode ser um risco de
     seguranc,a, como Geomview por si mesmo na~o toma nenhum tipo de
     precauc,a~o de seguranc,a, Geomview simplesmente executa todos os
     comandos alimentados a ele atrave's do socket de rede. Isso
     tambe'm implica entrada e sai'da para unidades de armazenamento
     locais devem ser permitidas remotamente.

     Exemplos:
    `-M NOME_DE_OBJETO'
          Mostra (possivelmente mudando dinamicamente) geometria
          enviada de programas `geomstuff' ou `togeomview'.  Essa
          opc,a~o "-M" escuta o pipe nomeado
          `/tmp/geomview/nome_de_objeto'; voce^ pode conseguir o mesmo
          efeito com os comandos de shell abaixo:
               mkdir /tmp/geomview
               mknod /tmp/geomview/nome_de_objeto p
          (assumindo que o direto'rio e o pipe nomeado na~o existam
          atualmente), enta~o executando o comando GCL:
               (geometry nome_de_objeto  <
               /tmp/geomview/nome_de_objeto)
          (veja *note `(geometry ...)': geometry.)

    `-Mc PIPENOME'
          Como `-M' acima, mas espera comandos GCL, em lugar de dados
          geome'tricos OOGL, na conecc,a~o.

    `-Mcs nome'
          Le^ comandos a partir do "UNIX-domain socket" nomeado.
          `/tmp/geomview/nome'

    `-Mcsin 40000'
          Le^ comandos a partir da porta IPv4 `40000'. Geomview por si
          mesmo na~o toma qualquer precauc,a~o de seguranc,a, de forma
          que "-Mcsin 40000" pode ser um risco de seguranc,a.

`-noopengl'
     Desabilita o uso de OpenGL para (possivelmente) conversa~o
     acelerada de hardware, mesmo que o bina'rio do Geomview tenha
     suporte a OpenGL compilado internamente. "-noopengl" tambe'm
     desabilita o suporte a transpare^ncia e texturas na janelas de
     ca^mera. Instanta^neos "RenderMan" ainda tera~o a transpare^ncia
     correta e suporte a alguma textura limitada.

`-nopanels'
     Inicia sem mostrar nenhum painel, somente a janelas gra'ficas.
     Paine'is podem ser invocados mais tarde da forma usual com as
     teclas de atalho `Px' ou com comando `ui-panel'. Veja *note
     `(ui-panel ...)': ui-panel.

`-noinit'
     Na~o le^ nenhum arquivo de inicializac,a~o. Por padra~o, Geomview
     le^ o arquivo `.geomview' do sistema, seguido daqueles em
     `${HOME}/.geomview' e em `./.geomview'.

`-e MODULO'
     Inicial um mo'dulo externo; MODULO e' o nome associado ao mo'dulo
     chamado, aparecendo no painel principal no navegador de
     "Applications", como definido pelo comando `emodule-define'. Veja
     *note `(emodule-define ...)': emodule-define.

`-start MODULE ARGS ...'
     Como -e mas permite a voce^ enviar argumentos para o mo'dulo
     externo.  "-" sinaliza o fim da lista de argumentos; o "-" pode
     ser omitido se for o u'ltimo argumento na linha de comando do
     Geomview.

`-run COAMANDO-SHELL ARGS ...'
     Como "-start" mas toma o caminho de arquivos do executa'vel do
     mo'dulo externo em lugar do nome do mo'dulo.  Os caminhos de
     arquivo de todos os direto'rios de mo'dulos conhecidos sa~o
     anexados ao final do caminho de busca do UNIX quando for invocado
     o COMANDO-SHELL.



File: geomview-pt_BR,  Node: Interacao Basica,  Next: Chamando,  Prev: Opcoes de Linha de Comando,  Up: Interacao

3.3 Interacao Basica: O Painel Principal
========================================

Normalmente quando voce^ invoca Geomview, tre^s janelas aparecem: O
painel principal (_Main_), o painel de ferramentas (_Tools_), e uma
janela de ca^mera.  Geomview tem muitas outras janelas mas muitas
coisas podem ser realizadas com essas tre^s de forma que por padra~o as
outras na~o aparecem.  Essa sec,a~o do manual introduz alguns conceitos
ba'sicos que sa~o usados nas sec,o~es restantes do manual e descreve o
painel principal (_Main_).
 Figura 3.1: O Painel Principal

   Geomview pode mostrar um nu'mero arbitra'rio de objetos
simultaneamente.  O navegador _Targets_ no painel principal (_Main_)
mostra uma lista de todos os objetos dos quais Geomview atualmente
abertos.  Esse navegador tem uma linha para cada objeto que voce^ tiver
chamado, adicionalmente algumas linhas para outros objetos.  Um desses
outros objetos e' chamado `World' e corresponde a todos os objetos
atualmente chamados, tratados como se eles fossem um objeto.  A maioria
das operac,o~es que voce^ pode fazer sobre um objeto, tais como aplicar
um movimento ou mudar uma cor, pode tambe'm ser feita para o objeto
"World".

   O navegador de alvos (_Targets_) tambe'm possui uma entrada para
cada ca^mera.  Por padra~o existe somente uma ca^mera; e' possi'vel
adicionar mais delas atrave's da entrada _New Camera_ do painel
principal (_Main_) via menu _File_.  Geomview trata ca^meras na maioria
das vezes como trata objetos geome'tricos.  Por exemplo, voce^ pode
mover ca^meras pelas pro-ximidades e adiciona'-las e apaga'-las como
objetos geome'tricos.  Ca^meras na~o sa~o mostradas na tela como um
objeto que voce^ ve^.  Cada ca^mera tem uma janela de ca^mera separada
que mostra a visa~o como vista atrave's da lente daquela ca^mera.  (E'
possi'vel para cada ca^mera mostrar uma representac,a~o geome'trica de
outras ca^meras.  Veja *note Cameras::.)

   Devido ao fato de Geomview tratar ca^meras e objetos geome'tricos
muito similarmente, o termo "objeto" nessa documentac,a~o e' usado para
referir-se a qualquer dos dois indistintamente.  Quando precisamos
distinguir entre os dois tipos de objetos, usamos o termo ""geom"" para
denotar um objeto geome'trico e a palavra "ca^mera" para denotar uma
ca^mera.

   O objeto que esta' selecionado (luminosidade alta) no navegador
"_Targets_" e' chamado objeto alvo.  Esse e' o objeto que recebe
quaisquer ac,o~es que voce^ faz com o mouse ou com o teclado.  Voce^
pode mudar o objeto alvo selecionando uma linha diferente no navegador
de alvos (_Targets_).  Outro caminho de modificar o objeto alvo e'
colocar o cursor do mouse diretamente sobre um geom na janela de ca^mera
e rapidamente dar um duplo clique no bota~o direito do mouse.  Esse
processo e' chamado "selecionar"; o objeto selecionado torna-se o novo
alvo.

   Objetos do Geomview sa~o todos conhecidos por dois nomes, ambos dos
quais sa~o mostrados no navegador de alvos (_Targets_).  O primeiro
nome la' fornecido, que aparece entre colche^tes ([ ]), e' um nome
curto atribuido pelo Geomview quando voce^ chama o objeto.  Esse nome
consiste da letra `g' para geometria e da letra `c' para ca^meras,
seguindo por um nu'mero.  O segundo nome e' maior e mais descritivo;
por padra~o esse e' o nome do arquivo do qual o objeto foi chamado.  Os
dois nomes sa~o equivalentes no que diz respeito ao Geomview; em
qualquer ponto onde voce^ precisar especificar um nome voce^ pode
fornecer qualquer dos dois.

   Para controlar um objeto, garanta que aquele objeto que voce^ quer
mover seja o objeto alvo, e coloque o cursor do mouse em uma janela de
ca^mera.  Movimentos sa~o aplicados pressionando ou o bota~o esquerdo
ou o bota~o do meio do mouse e movendo o mouse.  Existem muitos modos
de movimento diferentes, cada modo de movimento aplicando um diferente
tipo de movimento.  O navegador de modos de movimento (_MOTION MODE_)
no painel principal indica o modo de movimento atual.  O padra~o e' a
rotac,a~o ("Rotate").  Voce^ pode mudar o modo corrente de movimento
selecionando um novo modo de movimento no navegador de modos de
movimento (_MOTION MODE_), ou usando o painel de ferramentas (_Tools_).
Para maiores informac,o~es sobre modos de movimento, veja *note
Movimentos do Mouse::.

   O navegador de mo'dulos (_Modules_) lista mo'dulos externos do
Geomview.  Um mo'dulo externo e' um programa separado que interage com
Geomview para extender suas funciona-lidades.  Para informac,o~es sobre
mo'dulos externos, veja *note Modulos::.

   A barra de menu no topo do painel principal oferece menus para
operac,o~es comuns.

   Para criar novas janelas, chame novos objetos, grave os objetos ou
outras informac,o~es, ou saia do Geomview, veja o menu _File_.

   Para copiar ou apagar objetos, veja o menu _Edit_.

   Voce^ pode chamar qualquer painel a partir do menu _Inspect_.

   O menu _Space_ permite a voce^ escolher se Geomview trabalha no modo
Euclidiano, Hiperbolico ou Esfe'rico.  O modo Euclideano e' usado por
padra~o.  Para detalhes sobre a utilizac,a~o do modo espac,o
_Hyperbolic_ e do modo _Spherical_, veja *note Geometrias
Nao-Euclidianas::.

   A maioria das ac,o~es que voce^ pode fazer atrave's dos paine'is do
Geomview possuem equivalentes atalhos de teclado de forma que voce^
pode fazer a mesma ac,a~o atave's de digitac,a~o de uma seque^ncia de
teclas no teclado.  Isso e' u'til para usua'rios avanc,ados que esta~o
familiarizados com as capacidades do Geomview e querem trabalhar
rapidamente sem ter montanhas de paine'is amontoando-se na tela.
Atalhos de teclado sa~o usualmente indicados ente colche^tes ([ ])
pro'ximo ao item correspondente em um painel.  Por exemplo, o atalho de
teclado para o modo _Rotate_ e' 'r'; isso e' indicado par "[r]" que
aparece antes da palavra "Rotate" no navegador _MOTION MODE_.  Para
usar esse atalaho de teclado, apenas pressione a tecla `r' enquanto o
cursor do mouse estiver em qualquer janela  do Geomview.  Na~o e'
necessa'rio pressionar a tecla `<Enter>' posteriormente.

   Alguns atalhos de teclado consistem em mais de uma tecla.  Nesses
caso apenas digite as teclas uma apo's a outra, sem pressionar `<Enter>'
posteriormente ou entre as teclas pressionadas.  Atalhos de teclado
sa~o sensi'veis a` caixa alta/baixa.

   Muitas teclas de atalho podem ser precedidas de um para^metro
nume'rico.  Por exemplo, digitando `ae' muda o estado do desenho de
arestas, enquanto `1ae' sempre habilita o desenho de arestas.

   O campo _keyboard_ no canto superior esquerdo do painel principal
(_Main_), imediatamente acima da palavra "Targets", ecoa o estado atual
das teclas de atalho.

   Para uma lista de todas as teclas de atalho, pressione a telca _`?'_.


File: geomview-pt_BR,  Node: Chamando,  Next: Movimentos do Mouse,  Prev: Interacao Basica,  Up: Interacao

3.4 Disponibilizando Objetos dentro do Geomview
===============================================

Existem muitos caminhos para chamar um objeto dentro do Geomview.

No painel de arquivos (_Files_)
     Se voce^ clicar no bota~o _Load_ no painel principal do Geomview
     (_Main_), o painel de arquivos (_Files_) ira' aparecer.

      Figura 3.2: O Painel de Arquivos.

        Esse painel permite que voce^ selecione um arquivo a partir de
     uma variedade de direto'rios.  O topo do painel e' um navegador de
     arquivos padra~o do Motif.  Abaixo deste esta' uma lista de
     direto'rios no caminho de busca padra~o do Geomview; clique sobre
     um desses para navegar entre os arquivos naquele direto'rio.

        Para selecionar um arquivo, duplo-clique sobre o seu nome no
     navegador no canto superior direito, ou clique sobre o seu nome e
     pressione a tecla <Enter>, ou ainda digite o nome do arquivo
     dentro da caixa de texto na parte inferior do navegador e
     pressione a tecla <Enter>.

        Se o arquivo selecionado contiver dados geome'tricos OOGL, esse
     arquivo ira' ser adicionado ao navegador de alvos (_Targets_) do
     Geomview.  Se esse arquivo contiver comandos GCL em lugar de
     conter dados geome'tricos OOGL, o arquivo sera' interpretado. Veja
     *note GCL::.

        Quando o apinel de arquivos (_Files_) aparecer pela primeira
     vez, o direto'rio selecionado no navegador de direto'rios e' o
     direto'rio atual -- que corresponde ao direto'rio a partir do qual
     voce^ chamou o Geomview.  O navegador de arquivos mostra _todos_
     os arquivos nesse direto'rio, incluindo os que na~o sa~o arquivos
     do Geomview.  Se voce^ tentar chamar um arquivo que na~o contenha
     um objeto OOGL e tambe'm na~o contenha comandos do Geomview, o
     Geomview ira' mostrar uma mensagem de erro.

        O navegador de direto'rios tambe'm lista um segundo e um
     terceiro direto'rios adicionalmente ale'm do direto'rio atual.  O
     segundo, que termina em `data/geom', e' o direto'rio de exemplos
     de dados do Geomview.  Esse direto'rio conte'm uma grande
     variedade de amostras de objetos.  Esse direto'rio tambe'm conte'm
     muitos subdireto'rios.  Em particular, os subdireto'rios
     `hyperbolic' e o subdireto'rio `spherical' possuem amostras de
     objetos hiperbo'licos e esfe'ricos, respectivamente.  Entradas no
     navegador de direto'rios sa~o vistas apenas como entradas de
     arquivos; para visualizar um subdireto'rio, clique sobre o nome do
     referido direto'rio.

        O terceiro direto'rio mostrado no navegador de direto'rio, que
     termina em `geom', conte'm muitos subdireto'rios com outros
     arquivos do Geomview dentro deles.  Esses arquivos sa~o usados
     menos freque^ntemente que os outros no direto'rio `data/geom'.

        Voce^ pode mudar a lista de direto'rios mostrada no navegador
     de direto'rios do painel de arquivos (_Files_) usando o comando
     `set-load-path'; Veja *note `(set-load-path ...)': set-load-path.

  A tecla de atalho `<':
        Se voce^ digitar `<' em qualquer janela do Geomview, o painel
     _Load_ ira' aparecer.  Esse painel e' uma pequena versa~o do
     painel de arquivos (_Files_); o painel _Load_ conte'm um campo de
     texto no qual voce^ o nome de um arquivo a ser chamado (ou um
     comando GCL entre pare^ntesis).  Apo's digitar o nome do arquivo a
     ser chamado, aperte a tecla `<Enter>'; Geomview ira' chamar o
     arquivo como se voce^ o tivesse chamado com o bota~o _Add_ no
     painel de arquivos (_Files_).  Se, apo's fazer surgir o pequeno
     painel _Load_ com `<', voce^ decidir que quer usar o grande painel
     de arquivos (_Files_) apo's tudo, pressione o bota~o _File
     Browser_.
      Figura 3.3: O Painel de Chamar Arquivos.

  Comandos para chamar objetos geome'tricos:
        Os comandos GCL `load', `geometry', `new-geometry', e `read'
     permitem a voce^ chamar um objeto dentro do Geomview; veja *note
     GCL::. Veja *note `(load ...)': load. Veja *note `(new-geometry
     ...)': new-geometry. Veja *note `(read ...)': read.



File: geomview-pt_BR,  Node: Movimentos do Mouse,  Next: Aparencia,  Prev: Chamando,  Up: Interacao

3.5 Usando o Mouse para Controlar Objetos
=========================================

Geomview permite a voce^ controlar objetos com o mouse.  Existem seis
diferentes modos de movimento do mouse: rotac,a~o (_Rotate_),
translac,a~o (_Translate_), vo^o da ca^mera (_Cam Fly_), zoom da
ca^mera (_Cam Zoom_), homotetia de um objeto geome'trico (_Geom
Scale_), e o'rbita de ca^mera (_Cam Orbit_).  O painel de ferramentas
tem um bota~o para cada um desses modos; para trocar os modos, clique
sobre o bota~o correspondente.  voce^ pode tambe'm selecionar um novo
modo atrave's do navegador de modos de movimento (_Motion Mode_) no
painel principal (_Main_).

   Essa sec,a~o descreve a interac,a~o ba'sica com o mouse.  Para
detalhes, veja *note Comandos::.

 Figura 3.4: O Painel de Ferramentas.

   Cada um dos modos de movimento usa um paradigma comum para como o
movimento e' aplicado.  Em particular, cada modo de movimento depende
do objeto alvo (_target_) atual e do atual objeto do centro (_center_).
O objeto alvo atual e o atual objeto do centro sa~o explicados nos
para'grafos seguintes.

   O objeto alvo atual e' mostrado no campo _Target_ no painel de
ferramentas (_Tools_).  Isso e' o mesmo que o objeto selecionado no
navegador de alvos (_Targets_) no painel principal (_Main_), e voce^
pode mudar o alvo ou selecionando um novo objeto no navegador, digitando
uma nova entrada no campo, ou selecionando um objeto na janela de
ca^mera duplo-clicando no bota~o direito do mouse com o cursor sobre o
objeto.

   O atual objeto do centro e' mostrado no campo _Center_ no painel de
ferramentas(_Tools_).  Seu valor padra~o e' a palavra especial "target",
que significa que o objeto do centro e' o objeto que estiver designado
como objeto alvo.  Voce^ pode mudar o objeto atual do centro para
qualquer objeto digitando seu nome no campo _Center_.  A ori'gem do
objeto do centro e' mantida fixa no modo rotac,a~o _Rotate_ e no modo
_Orbit_.  Normalmente o objeto do centro e' um dos objetos geome'tricos
(geoms) existentes listados no navegador de alvos (_Targets_), o centro
atual das rotac,o~es e' a ori'gem daquele sistema de coordenadas
daquele objeto.  E' possi'vel, todavia, selecionar um ponto arbitra'rio
de interesse sobre um objeto como o centro. Para detalhes, veja *note
Ponto de Interesse::.

   Isso tambe'm e' possi'vel mudando o bota~o _BBox Center_ para
escolher o centro de movimento como sendo o centro do objeto atual da
caixa associada. Uma vez modificado o centro da caixa geome'trica ativa
associada ira' tornar-se o centro do movimento, se voce^ selecionar
outro objeto, enta~o o centro do movimento ira' tornar-se o centro da
caixa associada a` aquele objeto. Nenhuma modificac,a~o ocorrera'
quando uma ca^mera ou o objeto mundo (_World_) for selecionado; voce^
tem que digitar a palavra `target' no campo _Center_ para retornar ao
valor padra~o.

   Voce^ aplica um movimento de mouse pressionando ou o bota~o esquerdo
ou o bota~o do meio do mouse com o cursor em uma janela de ca^mera e
movendo o mouse.  A maioria dos modos de movimento possui ine'rcia
(_inertia_), que significa que se voce^ soltar o bota~o enquanto move o
mouse, o movimento ira' continuar.  Para imaginar a ine'rcia pode ser
u'til imaginar o cursor do mouse como sendo uma alc,a; quando voce^
pressiona um bota~o do mouse para baixo, o mouse agarra firmemente no
objeto alvo e voce^ pode mover esse objeto.  Quando voce^ libera o
bota~o do mouse, a alc,a libera o objeto.  Liberando o bota~o do mouse
enquanto move o mesmo funciona como abandonar o objeto -- o objeto
continua movendo-se independentemente do mouse.  Ine'rcia pode ser
desligada; veja o menu de movimento (_Motion_) no painel principal
(_Main_), descrito abaixo.

   Geralmente, o bota~o esquerdo do mouse controla movimento no plano
da tela, enquanto o bota~o me'dio do mouse controla movimento ao longo
ou em torno da direc,a~o de avanc,o.

   Pressionando o tecla "shift" enquanto arrasta com o bota~o esquerdo
ou me'dio do mouse na maioria dos modos de movimento fornece movimentos
de baixa velocidade , u'til para ajustes finos.

   Voce^ pode selecionar qualquer ponto sobre um objeto (na~o apenas
sua ori'gem) como centro do movimento pressionando a tecla "shift"
enquanto clica no bota~o direito do mouse; isso escolhe o ponto de
interesse.

_Rotate_
     No modo rotac,a~o (_Rotate_), pressione o bota~o esquerdo do mouse
     para rotacionar o objeto alvo en torno do objeto do centro.  A
     rotac,a~o ocorre na direc,a~o que voce^ move o mouse.
     Especificamente, o eixo de rotac,a~o passa atrave's da ori'gem do
     objeto do centro, e' paralelo ao plano de visa~o da ca^mera, e e'
     perpendicular a` direc,a~o do movimento do mouse.  Quando o centro
     for o alvo ("target"), isso significa que o objeto alvo rotaciona
     em torno de sua pro'pria ori'gem.

     O bota~ do meio do mouse no modo de movimento tipo rotac,a~o
     (_Rotate_) rotaciona o objeto alvo em torno de um eixo
     perpendicular ao plano de visa~o.

_Translate_
     No modo translac,a~o (_Translate_), mantenha pressionado o bota~o
     esquerdo do mouse para transladar o objeto alvo na direc,a~o do
     movimento do mouse.  O bota~o do meio do mouse translada o alvo ao
     longo de um eixo perpendicular ao plano de visualizac,a~o.

     No espac,o Euclideano, o objeto do centro e' essencialmente
     irrelevante para translac,o~es.  Nos espac,os hiperbo'licos e
     esfe'ricos, onde translac,o~es possuem um u'nico eixo, esse eixo
     e' escolhido para ir atrave's da ori'gem do objeto do centro.

_Cam Fly_
     O Vo^o de Ca^mera (_Cam Fly_) e' um simulador de vo^o muito
     simples que permite a voce^ voar em torno da cena.  _Cam Fly_
     trabalha atrave's do movimento da ca^mera.  Movimente o mouse
     enquanto mante'm pressionado o bota~o esquerdo do mouse para
     posicionar a ca^mera em uma direc,a~o diferente.  Para mover
     adiante ou para tra's, mantenha pressionado o bota~ do meio e mova
     o mouse verticalmente.  Os dois movimentos aqui descritos possuem
     ine'rcia; tipicamente o caminho mais fa'cil para voar em torno de
     uma cena e' fornecer a ca^mera um passo adiante pressionando o
     bota~ do meio enquanto move-se o mouse para cima, e enta~o usar o
     bota~o esquerdo para pilotar.

     _Cam Fly_ afeta a janela de ca^mera onde o mouse esta'
     correntemente posicionado; _Cam Fly_ ignora o objeto alvo e o
     objeto do centro.

_Cam Orbit_
     O modo o'rbita de Ca^mera (_Cam Orbit_) permite a voce^ rotacionar
     a ca^mera atual em torno do centro atual. O bota~o esquerdo do
     mouse faz essa rotac,a~o.  O bota~o do do meio do mouse no modo
     _Cam Orbit_ atua da mesma forma que no modo _Cam Fly_: O bota~o do
     do meio do mouse move a ca^mera para adiante e para tra's.

     Em geral _Cam Orbit_ na~o move o objeto alvo, embora se a ca^mera
     atual for selecionada como o alvo e o centro for tambe'm o alvo,
     _Cam Orbit_ ira' apenas pivotar aquela ca^mera sobre si' mesma
     como no modo _Cam Fly_.

_Cam Zoom_
     O modo Zoom de Ca^mera (_Cam Zoom_) permite a voce^ modificar o
     campo atual de visa~o com o mouse; mantenha pressionado o bota~o
     esquerdo do mouse e mova o mouse para modificar o campo de visa~o.
     O valor nume'rico do campo de visa~o e' mostrado no campo _FOV_
     (field of view) no painel de ca^mera (_Camera_).

_Geom Scale_
     O modo _Geom Scale_ permite a voce^ ampliar ou diminuir um objeto
     geome'trico (geom).  _Geom Scale_ atua sobre o objeto alvo se
     aquele objeto for um geom.  Se o alvo for uma ca^mera, _Geom
     Scale_ atual sobre o geom que foi o objeto alvo mais recentemente.
     Movendo o mouse enquanto mantem-se pressionado o bota~o esquerdo
     do mouse homotetiza-se o objeto ou ampliando ou reduzindo o mesmo,
     dependendo da direc,a~o do movimento do mouse.  o centro da
     transformac,a~o homote'tica aplicada e' o objeto do centro.

     Homotetia possui significado somente no espac,o Euclideano;
     tentativas do palicar homotetia sa~o ignoradas em outros espac,os.

     O modo _Geom Scale_ na~o possui ine'rcia.


   Os boto~es _Stop_, _Look At_, _Center_, e _Reset_ no painel de
ferramentas (_Tools_) executam ac,o~es relacionadas a movimentos mas
na~o modificam o modo atual de movimento (nota do tradutor: de
rotac,a~o para translac,a~o por exemplo).

_Stop_
     O bota~o _Stop_ faz com que cessem todos os movimentos.  O bota~o
     _Stop_ afeta todos os objetos em movimento, na~o apenas o objeto
     alvo.  Sua tecla de atalho e' `H'.

     O comando de teclado `h', que na~o corresponde a um bota~o do
     painel, cessa o movimento atual para o objeto alvo somente.

_Look At_
     O bota~o _Look At_ faz com que a ca^mera atual seja movida para
     uma posic,a~o tal que a referida ca^mera esteja olhando para o
     objeto alvo, e de forma que o objeto alvo mais ou menos ajuste-se
     a` janela.

     O comando _Look At_ na~o funciona perfeitamente em espac,os na~o
     Euclideanos.

_Center_
     O bota~o _Center_ desfaz transformac,a~o do objeto alvo, movendo o
     objeto alvo de volta a` sua posic,a~o inicial padra~o, que e' onde
     ele estava quando voce^ originalmente o chamou a partir do
     Geomview.

_Reset_
     O bota~o _Reset_ cessa todo movimento e faz com que todos os
     objetos sejam movidos de vota a`s suas posic,o~es iniciais padra~o.


   O painel de ferramentas (_Tools_) possui um bota~o _Main_, para
invocar o painel principal no caso de esse painel ter sido dispensado
ou sepultado, e um bota~o _Done_ para fechar o painel de ferramentas
_Tools_.

   O painel principal do menu de movimento (_Motion_) tem controles
especiais que afetam como movimentos do mouse sa~o interpretados; as
modificac,o~es sa~o tambe'm acessi'veis atrave's de comandos GCL. *Note
`(ui-motion ...)': ui-motion.

_[ui] Inertia_
     Normalmente, ao mover objetos tem-se ine'rcia: se o mouse estiver
     ainda se movendo quando o bota~o for liberado, o objeto
     selecionado continua a mover-se.  Quando a ine'rcia (_Inertia_)
     for desabilitada, objetos cessam seu movimento no momento em que
     voce^ libera o mouse.

_[uc] Constrain Motion_
     E' necessa'rio algumas vezes ter ao alcance da ma~o o movimento de
     um objeto em uma direc,a~o alinhada com um eixo coordenado:
     exatamente na horizontal ou na vertical.  Selecionando restringir
     movimento (_Constrain Motion_) a interpretac,a~o de movimentos do
     mouse e' modificada para permitir isso; arrastros de mouse
     aproximadamente horizontais ou aproximadamente verticais
     transformam-se em movimentos exatamente horizontais ou exatamente
     verticais.  Note que o movimento e' ainda ao longo dos eixos X ou
     Y da ca^mera na qual voce^ move o mouse, na~o necessa'riamente no
     sistema de coordenadas do objeto.

_[uo] Own Coordinates_
     E' necessa'rio algumas vezes ter ao alcance da ma~o o movimento de
     objetos objetos com relac,a~o ao sistema de coordenadas onde o
     referido objeto foi definido, em lugar de com relac,a~o ao sistema
     de coordenadas da ca^mera atrave's da qual esse objeto esta' sendo
     visto.  Enquanto _Own Coordinates_ estiver selecionado, todos os
     movimentos sa~o interpretados da forma citada nesse item:
     arrastando o mouse para a direita no modo translac,a~o corresponde
     a mover o objeto em sua pro'pria direc,a~o +X, e assim por diante.
     Pode ser especialmente u'til conjuntamente com o bota~o Restringir
     Movimento (_Constrain Motion_).


* Menu:

* Ponto de Interesse::           Pontos de Interesse.


File: geomview-pt_BR,  Node: Ponto de Interesse,  Prev: Movimentos do Mouse,  Up: Movimentos do Mouse

3.5.1 Selecionando um Ponto de Interesse
----------------------------------------

E' algumas vezes u'til especificar um ponto em particular sobre algum
objeto em uma janela do Geomview como o ponto de centro para movimentos
do mouse.  Voce^ pode fazer isso segurando a tecla shift e clicando o
bota~o direito do mouse (i.e. clique no bota~o direito uma vez enquanto
mante'm pressionada a tecla shift do teclado) com o cursor sobre o
ponto desejado.  Esse ponto torna-se enta~o o _ponto de interesse_.  O
ponto de interesse deve estar sobre um objeto existente.

   Selecionado um ponto de interesse simplifica o exame de uma pequena
porc,a~o de um grande objeto.  Mantendo a tecla shift pressionada e
clicando sobre o ponto de interesse com o bota~o direito do mouse, e
selecionando o modo o'rbita (_Orbit_).  Use o bota~ do meio do mouse
para aproximar, e o esquerdo para orbitar o ponto, examinando a regia~o
de diferentes direc,o~es.

   Quando voce^ tiver selecionado um ponto de interesse, o atual objeto
do centro e' modificado para um objeto chamado "CENTER", que e' um
objeto invisi'vel localizado no ponto de interesse.  Adicionalmente,
movimentos de mouse para a janela na qual voce^ fez a selec,a~o sa~o
ajustados de forma que o ponto de interesse acompanhe o mouse.

   Voce^ pode mudar o ponto de interesse a qualquer momento
selecionando um novo ponto de interesse shift-clicando o bota~o direito
do mouse novamente.  Voce^ pode cancelar o ponto de interesse
completamente shift-clicando o bota~o direito do mouse com o cursor no
plano de fundo (i.e. na~o sobre qualquer objeto).  Isso modifica o
objeto do centro de volta a seu valor padra~o, "target".

   O objeto que possui o nome de "CENTER", que serve como um objeto do
centro para o ponto de interesse, e' um tipo especial de geom chamado
"alien".  Esse "Alien" na~o aparece no navegador de alvos (_Targets_).
Por padra~o esse objeto "Alien" na~o tem geometria associada e
conceque^ntemente e' invisi'vel.  Voce^ pode, Todavia, explicitamente
fornecer ao Alien alguma geometria usando um comando GCL, fazendo com
que o Alien aparece no navegador de alvos.  Use o comando `geometry'
para fazer isso: `(geometry CENTER GEOMETRY)', onde GEOMETRY e'
qualquer geometria va'lida.  Por exemplo, `(geometry CENTER { <
xyz.vect })' faz com que o arquivo `xyz.vect', que e' um dos arquivos
de exemplo padronizados distribui'dos com Geomview, seja usado na
geometria para CENTER. Veja *note `(geometry ...)': geometry.

   O que acontece internamente quando voce^ seleciona um ponto de
interesse e' que o centro e' ajustado para o objeto chamado CENTER, e
aquele objeto e' posicionado no ponto de interesse.  Adicionalmente,
para que movimentos de mouse acompanhem o ponto de interesse, o atual
comprimento focal da ca^mera e' escolhido para ser a dista^ncia da
ca^mera ate' o ponto de interesse.  Voce^ pode realizar isso via GCL
com os seguintes comandos:
     (if (real-id CENTER) nil (new-alien CENTER {}))
     (ui-center CENTER)
     (transform-set CENTER universe universe translate X Y Z)
     (merge camera CAM-ID { focus D })
   onde `(X,Y,Z)' sa~o as coordenadas (universe) do ponto de interesse,
e D e' a dista^ncia daquele ponto a` atual ca^mera, CAM-ID.  O primeiro
comando acima cria o "alien" CENTER se esse Alien na~o existir ainda.


File: geomview-pt_BR,  Node: Aparencia,  Next: Cameras,  Prev: Movimentos do Mouse,  Up: Interacao

3.6 Modificando a Forma de Ver as Coisas
========================================

Geomview utiliza uma hierarquia de apare^ncias para controlar o caminho
atrave's do qual olha-se coisas.  Uma apare^ncia ("appearance") e' uma
especificac,a~o de informac,a~o sobre como alguma coisa pode ser
desenhada.  Isso pode incluir muitas caracteri'sticas como cor, brilho,
propriedades do material, etc.  Apare^ncias trabalham de uma maneira
hiera'rquica: se uma certa propriedade de apare^ncia, por exemplo cor
de face, na~o for especificada em uma apare^ncia particular de algum
objeto, esse bojeto e' desenhado usando aquele propriedade de uma
hierarquia superior.  Se ambas as apare^ncias de hierarquias, a atual e
a superior, especificam uma propriedade, a hierarquia atual tem
precede^ncia a menos que a hierarquia superior na~o for escolhida para
sobrescreve^-la.

   Todo geom no Geomview tem uma apae^ncia associada.  Existe tambe'm
uma apare^ncia associada ao geom do tipo "World", que comporta-se como
hierarquia superior a cada apare^ncia individual de qualquer geom.
Finalmente, existe uma apare^ncia ba'sica global, que e' a hierarquia
superior da apare^ncia "World".

   A apare^ncia ba'sica especifica valores razoa'veis para toda
informac,a~o de apare^ncia, e por padra~o nenhuma outra apare^ncia
especifica qualquer coisa, o que significa que as apare^ncias erdam
seus valores a a partir da apare^ncia ba'sica.  Isso significa que por
padra~o todos os objetos sa~o desenhados usando a apare^ncia ba'sica.

   Se voce^ modificar uma certa propriedade de apare^ncia de um geom,
aquela propriedade e' usada na construc,a~o daquele geom.  A apare^ncia
de hierarquia superior e' usada para quaisquer propriedades que voce^
na~o explicitamente escolheu.

   Geomview possui tre^s paine'is que levam voce^ a modificar
apare^ncias.

* Menu:

* Painel de Aparencia::         Cor etc.
* Painel de Materiais::         Propriedades do Material da Superfi'cie.
* Painel de Iluminacao::        Para^metros de Iluminac,a~o.


File: geomview-pt_BR,  Node: Painel de Aparencia,  Next: Painel de Materiais,  Prev: Aparencia,  Up: Aparencia

3.6.1 The Appearance Panel
--------------------------

O painel de Apare^ncia (_Appearance_) leva voce^ a modificar as mais
comuns propriedades de apare^ncia do objeto alvo.
 [image src="figs/ap.png" ]

Figura 3.5: O Painel de Apare^ncia.

   Se o alvo for um geom individual, enta~o modificac,a~oes que voce^
fizer no painel de apare^ncias aplicam-se a apare^ncia daquele objeto
geome'trico.  Se o alvo for o "World", enta~o as modificac,o~es no
painel de apare^ncias aplicam-se a` apare^nca do objeto atual _e_ a
apare^ncia de todos os outros objetos individuais.  (Usua'rios acham que
esse comportamento e' mais deseja'vel que ter as modificac,o~es somente
aplicadas a apare^ncia do "World".)  Se o alvo for uma ca^mera, enta~o
as modificac,o~es do painel de apare^ncia aplica-se ao geom que ocupou
mais recentemente a posic,a~o de alvo.

   Os cinco boto~es pro'ximos ao canto superior esquerdo sob a palavra
_Show_ (mostrar) controlam que partes do geom alvo sa~o desenhadas.

_Faces_
     Esse bota~o especifica se faces sa~o desenhadas.

_Edges_
     Esse bota~o especifica se arestas sa~o desenhadas.

_Normals_
     Esse bota~o especifica se vetores normais a` superfi'cie sa~o
     desenhados.

_BBox_
     Esse bota~o especifica se a caixa associada e' desenhada.

_Vects_
     Esse bota~o especifica se objetos VECT sa~o desenhados.  VECTs
     sa~o um tipo de objeto OOGL que representa pontos e segmentos de
     reta em espac,o tridimencional; os VECTs sa~o distintos de arestas
     ou de outros tipos de objetos, e e' deseja'vel algumas vezes ter
     controle separado sobre se eles sa~o desenhados.


   Os quatro boto~es sob _Color_ rotulados _Faces_, Arestas (_Edges_),
Normais (_Normals_), e _BBox_ permitem a voce^ especificar a cor do
aspecto correspondente de um geom alvo.  Clicando sobre um deles faz
com que aparec,a um painel de escolha de cores.
 Figura 3.6: Painel de Escolha de Cor.

   Esse painel oferece dois conjuntos de boto~es deslizantes: H(ue)
S(Saturation) V(alue), ou R(ed) G(reen) B(lue), cada um no intervalo
real fechado de 0 a 1.  O quadrado mostra a cor atual, que e' fornecida
numericamente em ambos os sitemas HSV e RGB nas caixas de texto
correspondentes.

   No sistema de cores HSV, hue H mostra vermelho em 0, verde em .333,
azul em .667, e volta ao vermelho em 1.0.  Saturac,a~o fornece a
frac,a~o de branco misturada na cor, de 0 para cinza puro a 1 para a
cor pura.  Valor fornece o brilho, de 0 para preto a 1 para brilho
ma'ximo.

   Pressionado o bota~o _RGB_ ou o bota~o _HSV_ ao centro do topo do
painel alterna os boto~es deslizantes para outro sistema de cores.
Voce^ pode ajustar cores ou atrave's dos boto~es deslizantes, ou
atrave's de digitac,a~o nas caixas de texto RGB ou HSV.

   Clique _OK_ para aceitar as cores que voce^ tiver escolhido, ou
_Cancel_ para reter as escolhas anteriores de cor.

   O navegador _SHADING_ permite a voce^ especificar o modelo de
sombreamento que Geomview utilizara' para desenhar o geom alvo.

`Constant'
     Toda face do objeto e' desenhada com uma cor constante que na~o
     depende da localizac,a~o da face, nem da ca^mera, nem tambe'm das
     fontes de luz.  Se o objeto na~o contiver cores por face ou por
     ve'rtice, a cor difusa de apare^ncia do objeto e' usada.  Se o
     objeto contiver cores por face, essas cores sera~o usadas.  Se o
     objeto contiver cores por ve'rtice, cada face e' pintada usando a
     cor de seu primeiro ve'rtice.

`Flat'
     Cada face do objeto e' desenhada com uma cor que depende da
     localizac,a~o relaiva da face, da ca^mera, e das fontes de luz.  A
     cor e' constante ao longo da face mas pode mudar conforme muda a
     face, a ca^mera, ou o movimento das luzes.

`Smooth'
     Cada face do objeto e' desenhada com cores lisamente interpoladas
     baseadas nos vetores normais em cada ve'rtice.  Se o objeto na~o
     contiver normais por ve'rtice, "Smooth" tem o mesmo efeito que o
     modo de sombreamento "Flat".  Se o objeto tiver normais por
     ve'rtice rasoa'veis, o efeito e' alisamento sobre as arestas e
     entre as faces.

`CSmooth'
     Cada face do objeto e' desenhada com as cores exatamente
     especificada(s), independente de iluminac,a~o, orientac,a~o, e
     propriedades de material.  Se o objeto for definido com cores por
     ve'rtice, as cores sera~o interpoladas lisamente ao longo da face;
     de outra forma o efeito e' o mesmo que ocorre no estilo de
     sombreamento "Constant".

`VCflat'
     Uma combinac,a~o de `CSmooth' e sombreamento `Flat'. Dessa forma o
     sombreamento e' constante em cada face, de acordo com a
     orientac,a~o relativa das fontes de luz, a ca^mera e a superfi'cie
     normal da face.


   O bota~o _Facing Normals_ no painel de apare^ncia (_Appearance_)
indica se Geomview pode arranjar aqueles vetores normais ou se na~o pode
sempre conforme a visualizac,a~o.  Se um vetor normal direciona-se
afastando-se do visualizador a cor da face correspondente ou ve'rtice
correspondente usualmente e' mais forte do que e' desejado.  Geomview
pode evitar isso atrave's do uso da normal oposta em ca'lculos de
sombreamento.  Esse comportamento e' o padra~o.  Usando _Facing Normals_
podemos fornecer estranha suavidade pesada ou estranhos efeitos de
tonalidade de luz, embora, proximo ao horizonte de um objet
distantemente liso facetado.  Pressione esse bota~o para usar as
normais fornecidas com o objeto.

   Os tre^s campos no canto inferior esquerdo do painel de apare^ncia
(_Appearance_) sa~o:

_Line Width_
     A espessura, em pixels, para linhas desenhadas pelo Geomview.

_Normal Length_
     Isso e' atualmente um fator de homotetia; quando vetores normais
     forem desenhados, Geomview desenha-os de forma que tenham um
     comprimento que e' seu comprimento natural vezes esse nu'mero.

_Patch Dicing_
     Geomview desenha retalhos de Bezier primeiro convertendo-so em
     malhas.  Esse para^metro especifica a resoluc,a~o da malha: se
     _Patch Dicing_ for N, enta~o uma malha N por N e' usada para
     desenhar cada retalho de Bezier.  Se _Patch Dicing_ for 1, a
     resoluc,a~o reverte-se para um valor padra~o interno.


   O bota~o _Revert_ no painel de apare^ncia (_Appearance_) desfaz todas
as escolhas na apare^ncia do alvo.  Isso faz com que o geom alvo herde
todas as suas propriedades de apare^ncia de seus pais.

   O bota~o do painel de apare^ncia (_Appearance_) determina se
controles de apare^ncia devem sobrescrever escolhas feitas nos objetos
em si mesmos - por exemplos, escolhendo a cor de face ira' afetar todas
as faces de objetos com faces multicoloridas.  De outra forma,
controles de apare^ncia somente fornecem escolhas que na~o forem
especificadas nos objetos em si mesmos na~o especificarem.  Por
padra~o, _Override_ esta' habilitado.  Esse bota~o aplica-se a todos os
objetos, e a todos os paine'is relacionados a apare^ncia.

   Normalizac,a~o e' um tipo de homotetia; Geomview pode alterar o
tamanho de um objeto proporcionalmente de forma que esse objeto se
ajuste dentro de uma certa regia~o.  O objetivo principal da
normalizac,a~o e' permitir a voce^ facilmente visualizar um objeto sem
ter que se preocupar com o tamanho do mesmo.  Estamos substituindo
gradualmente o recurso de normalizac,a~o do Geomview por recursos mais
robustos de posicionamento de ca^mera.  Em geral, o melhor caminho de
garantir que voce^ esta' vendo tudo de um objeto e' usar o bota~o _Look
At_ do painel de ferramentas (_Tools_).  A normalizac,a~o pode ser
completamente substitui'da por esse bota~o do painel de ferramentas e
por outros recursos em uma versa~o futura do Geomview.

   Normalizac,a~o e' uma propriedade que aplica-se a cada geom
separadamente.  o navegador _NORMALIZE GEOMETRY_ afeta a propriedade de
normalizac,a~o do geom alvo.  Se o geom alvo for "World", a
normalizac,a~o afetara' todos os geoms.

_None_
     Sem normalizac,a~o.

_Individual_
     Normaliza o geom atual para ajustar-se dentro de uma esfera
     unita'ria.

_Sequence_
     Assemelha-se a "Individual", exceto quando um objeto esta'
     mudando.  Enta~o, "Individual" com muita precisa~o ajusta a caixa
     associada em torno do objeto quando esse objeto modifica-se e
     normaliza-se adequadamente, enquanto "Sequence" normaliza a unia~o
     de todas as variantes do objeto e normaliza ade-quadamente.

_Keep_
     Mantem a transformac,a~o de normalizac,a~o inalterada quando o
     objeto modifica-se.  _Keep_ pode ser u'til para aplicar a
     normalizac,a~o "Individual" ou a normalizac,a~o "Sequence" a`
     primeira versa~o de um objeto que se modifica para trazer esse
     mesmo objeto ao campo de visa~o.



File: geomview-pt_BR,  Node: Painel de Materiais,  Next: Painel de Iluminacao,  Prev: Painel de Aparencia,  Up: Aparencia

3.6.2 O Painel de Materiais
---------------------------

O painel de materiais (_Materials_) controla as propriedades materiais
das surperfi'cies.  O painel de materiais trabalha com o objeto alvo da
mesma forma que o painel de apare^ncia (_Appearance_) faz.
 Figura 3.7: O Painel de Materiais.

_Translucent_
     Esse bota~o determina se a capacidade de ser translu'cido esta'
     habilitada. Geomview suporta tre^s diferentes formas da capacidade
     de ser translu'cido (transluce^ncia):

    _Alpha-blending com BSP-tree depth-sorting_
          Esse e' o ni'vel mais acurado de prefere^ncia de
          visualizac,a~o imediata, mas consome vastos montantes de
          tempo de computac,a~o e memo'ria. No modo simples de
          transluce^ncia objetos sa~o mostrados corretamente em
          relac,a~o a si mesmos; todavia multiplos objetos
          translu'cidos podem aparecer na ordem inadequada na tela. A
          noc,a~o _objeto_ significa aqui: geometria de ni'vel mais
          alto como mostrado no navegador de alvo de geometria.

    _Screen Door Translucency_
          Se a ma'quina suporta OpenGL enta~o existe suporte para tipo
          de transluce^ncia por mascaramento de sai'da (completamente)
          de pixels transparentes por meio de uma mascara de
          ponteamento. Essa forma e' atualmente muito experimental, e o
          resultado e' de certa forma o ideal, mas funciona e e'
          ra'pido.

    _Alphe-blending sem depth-sorting_
          Esse e' a antiga forma de fazer uma transluce^ncia ra'pida e
          com muitas falhas. Essa e' ra'pida, mas os resultados sa~o
          completamente incorretos.

     Quando a transpare^ncia estiver habilitada, um instanta^neo
     RenderMan ira' conter a informac,a~o alfa, um renderizador
     obediente pode enta~o gerar figuras de alta qualidade, incluindo a
     transluce^ncia correta.

_Alpha_
     O bota~o deslizante determina a opacidade/transpare^ncia quando a
     transpare^ncia estiver habilitada.  0 (zero) significa totalmente
     transparente, 1 significa totalmente opaco.

_Diffuse Reflectance_
     Esse bota~o deslizante controla a reflecta^ncia difusa de uma
     superfi'cie.  Isso tem a ver com o quanto a superfi'cie dispersa a
     luz que reflete.

_Shininess_
     Esse bota~o deslizante controla o quanto brilhante a superfi'cie
     e'. Esse bota~o  determina o tamanho de destaques especulares
     sobre a superfi'cie.  Valores pequenos fornecem a` superfi'cie uma
     apare^ncia sombria.

_Ambient Reflectance_
     Esse bota~o deslizante controla o quanto da luz ambiente uma
     superfi'cie reflete.

_Specular Reflectance_
     Esse bota~o deslizante controla a reflecta^ncia especular de uma
     superfi'cie.  Isso tem a ver com como a superfi'cie reflete
     diretamente os raios luminosos.  Valores maiores fornecem
     destaques de brilho especular.

_Done_
     Esse bota~o dispensa o painel de materiais (_Materials_).



File: geomview-pt_BR,  Node: Painel de Iluminacao,  Prev: Painel de Materiais,  Up: Aparencia

3.6.3 O Painel de Luzes
-----------------------

O painel de luzes (_Lights_) controla o nu'mero, a posic,a~o, e a cor
das fontes de luz usadas no sombreamento.
 [image src="figs/light.png" ]

O Painel de Iluminac,a~o.

   O painel de iluminac,a~o (_Lighting_) e' diferente do painel de
apare^ncia (_Appearance_) e dos paine'is de material (_Material_) no
sentido de que o painel de iluminac,a~o sempre trabalha com a apare^ncia
base.  Isso ocorre pelo fato de fazer sentido usar o mesmo conjunto de
luzes para desenhar todos os objetos na sua cena.

_LIGHTS_
     O navegador de luzes (_LIGHTS_) mostra a luz atualmente
     selecionada.  Modificac,o~es sa~o feitas usando os outros meios de
     escolha sobre esse painel aplicado a essa luz.  Existe sempre pelo
     menos uma luz, a luz ambiente.

_Intensity_
     Esse bota~o deslizante controla a intensidade da luz atual.

_Color_
     Esse bota~o faz surgir um modificador de corres que lhe permite
     selecionar a cor da luz que atualmente ilumina o objeto.

_Add_
     Esse bota~o adiciona uma luz.

_Delete_
     Esse bota~o exclui a luz atual.

_Show Lights_
     Esse bota~o permite a voce^ ver e modificar a posic,a~o das fontes
     de iluminac,a~o em uma janela de ca^mera.  Cada luz e' movida ao
     longo de um cilindro que e' suposto para lembrar a voce^ um raio
     de luz.  Quando voce^ clica sobre o bota~o _Show Lights_ Geomview
     entra no modo "light edit", durante o qual voce^ pode rotacionar a
     iluminac,a~o atual mantendo pressionado o bota~o esquerdo do mouse
     e movendo o mouse.  Iluminac,a~o colocada dessa forma esta~o
     infinitamente distantes, de forma que o que voce^ esta'
     modificando e' a posic,a~o angular.  Clique sobre o bota~o _Show
     Lights_ novamente para retornar ao modo anterior de movimento e
     para sair movendo os raios de luz.

_Done_
     Esse bota~o dispensa o painel de iluminac,a~o (_Lighting_).


   Os paine'is do Geomview _Appearance_, _Materials_, e _Lighting_ sa~o
construi'dos para permitir a voce^ fazer facilmente a maioria das coisas
relacionadas a apare^ncia que voce^ pode querer fazer.  A hierarquia de
apare^ncia que Geomview suporta internamente, todavia, e' muito
complexa e existem certas operac,o~es que voce^ na~o pode fazer com os
paine'is.  A linguagem de comandos do Geomview (GCL) fornece suporte
completo a operac,o~es sobre apare^ncia.  Em particular, o comando
`merge-baseap' pode ser usado para modificar a apare^ncia de base (a
qual, exceto para iluminac,a~o, na~o pode ser modificada atrave's de
paine'is do Geomview).  O comando `merge-ap' pode ser usado para
modificar a apare^ncia de um geom individualmente.  Apare^ncias podem
tambe'm serem especificadas nos arquivos OOGL; para detalhes veja,
*note Aparencias::. *note `(merge-baseap ...)': merge-baseap. *note
`(merge-ap ...)': merge-ap.


File: geomview-pt_BR,  Node: Cameras,  Next: Gravando,  Prev: Aparencia,  Up: Interacao

3.7 Cameras
===========

Uma ca^mera no Geomview e' o objeto que corresponde a uma janela de
ca^mera.  Por padra~o existe somente uma ca^mera, mas e' possi'vel ter
tantas quantas voce^ quiser.  Voce^ pode controlar certos aspectos do
objeto visi'vel atualmente na janela de ca^mera arrastando em cada
janela de ca^mera via o painel _Cameras_.
 Figura 3.8: O Painel de Ca^mera.

   Se o objeto alvo for uma ca^mera, o painel de ca^meras (_Cameras_)
afeta essa ca^mera.  Se o objeto alvo na~o for uma ca^mera, o painel de
ca^meras (_Cameras_) afeta a ca^mera atual ("current camera").  A
ca^mera atual e' a  ca^mera da janela que o cursor do mouse esta' nela,
ou estava mais recentemente se o cursor na~o estiver em uma janela de
ca^mera.  Dessa forma, se voce^ usa teclas de atalho para as ac,o~es no
painel de ca^meras (_Cameras_) enquanto o cursor estiver em uma janela
de ca^mera, as ac,o~es aplicam-se a aquela  ca^mera, a menos que voce^
tenha explicitamente selecionado outra ca^mera.

   Para criar novas janelas de ca^mera, use a tecla de atalho `v+', ou
veja o menu arquivo (_File_) no painel principal (_Main_).

_Single-Buffering_
     Normalmente, janelas do Geomview sa~o armazenadas em a'reas de
     memo'ria duplas (_double-buffered_): Geomview desenha a figura
     seguinte em uma janela escondida, enta~o alterna as a'reas de
     memo'ria para fazer essa janela completamente visi'vel em algum
     momento.  Sobre muitos sistemas operacionais, a memo'ria para a
     a'rea de memo'ria escondida vem da apropriac,a~o indevida de
     metade dos bits de cada pixel de tela, reduzindo a resoluc,a~o de
     cor.  Quando a opc,a~o a'rea de memo'ria simples
     (single-buffering) for habilitada, as peli'culas de tela de cada
     cena esta' sendo desenhada, mas voce^ pode pegar imagens planas
     com reduc,a~o de granularidade estremecendo artefatos.  A'rea de
     memo'ria simples e' possi'vel se Geomview for compilado com GL ou
     com OpenGL, mas na~o com gra'ficos desenhados com recursos u'nicos
     e exclusivos do X.

_Dither_
     Muitos monitores oferecem menos que 24 bits por pixel (8 bits para
     cada vermelho, verde, e azul) convencionalmente suficiente para
     mostrar gradac,o~es de cor simplesmente.  Quando tenta mostrar uma
     cor na~o acuradamente disponi'vel no monitor, Geomview normalmente
     estremece (_dithers_), modificando as cores do pixel para algumas
     vezes mais brilhante, algumas vezes mais escuro que o valor
     desejado, de forma que a cor disponi'vel sobre uma a'rea e' uma
     melhor aproximac,a~o para a cor verdadeira que um pixel simples
     pode ter.  Efetivamente perdas de resoluc,a~o espacial sa~o para
     ganhar resoluc,a~o de cor.  Esse compartamento na~o e' sempre
     deseja'vel, todavia.  Desabilitando _Dither_ fornece menor
     granularidade, mas a precisa~o de cores e' menor, das imagens.

_Software Shading_
     Esse bota~o controla se Geomview faz ca'lculos de sombreamento via
     software.  O padra~o e' permitir que o hardware manuseie esses
     ca'lculos, e no espac,o Euclideano esse caminho e' o melhor sempre
     porque e' o caminho mais ra'pido.  No espac,o hiperbo'lico e
     tambe'm no espac,o esfe'rico, todavia, os ca'lculos de
     sombreamento que o hardware faz sa~o incorretos.  Clique sobre
     esse bota~o para habilitar a forma correta mas lenta do ca'lculo
     de sombreamento via software.

_Background Color_
     Esse bota~o faz surgir um modificador de cores que voce^ pode usar
     para escolher a cor de fundo da janela da ca^mera.

_PROJECTION_
     Esse navegador permite a voce^ selecionar entre projec,a~o
     perspectiva ou projec,a~o ortogra'fica para essa ca^mera.

_Near clip_
     Essa caixa de texto determina a dista^ncia nas coordenadas do
     objeto mundo do pro'ximo plano de corte a partir do ponto de
     visa~o.  Deve ser um nu'mero positivo.

_Far clip_
     Essa caixa de texto determina a dista^ncia nas coordenadas do
     objeto mundo do plano de corte mais distante a partir do ponto de
     visa~o.  Deve ser um nu'mero positivo e em geral deve ser maior
     que o valor de _Near clip_.

_FOV_
     Essa caixa de texto e' o campo de visa~o da ca^mera, medido em sua
     menor direc,a~o.  No modo perspectiva, essa caixa corresponde a um
     a^ngulo em graus.  No modo ortogra'fico, essa caixa de texto
     corresponde ao tamanho linear do campo de visa~o.  Esse nu'mero
     pode ser modificado com o mouse no modo _Cam Zoom_.

_Focal Length_
     A dista^ncia focal pretende pretende sugerir a dista^ncia da
     ca^mera a um plano imagina'rio de interesse.  Seu valor e' usado
     quando alternamos entre as visualizac,o~es ortogra'fica e
     perspectiva (e durante visualizac,a~o stereo), de forma a
     preservar o tamanho aparente de objetos sendo desonesto quanto a`
     dista^ncia focal da ca^mera.  Dista^ncia focal tambe'm afeta a
     interpolac,a~o de movimentos de translac,a~o efetuados usando o
     mouse.  A velocidade do movimento para adiante (nos modos
     translac,a~o, vo^o e no modo orbital) e' proporcional a`
     dista^ncia focal; e objetos desonestos quanto a` dista^ncia focal
     da ca^mera translacionam lateralmente na mesma raza~o que o cursor
     do mouse.  Finalmente, no modo de projec,a~o N-Dimencional,
     ca^meras sa~o substitui'das de volta atrave's da dista^ncia focal
     a partir da projec,a~o tridimensional da ori'gem do objeto mundo.

_Lines Closer_
     Esse nu'mero tem a ver com o caminho pelo qual as linhas sa~o
     desenhadas.  Normalmente a a'rea de armazenamento tempora'rio do
     algori'tmo que controla as coordenadas do eixo z podem
     confundir-se na hora de desenhar linhas que localizam-se
     exatamente sobre superfi'cies (tais como as arestas de um objeto);
     devido a erros de arredondamento de ma'quina, algumas vezes as
     linhas parecem estar em frente a` superfi'cie e algumas vezes elas
     parecem estar por detra's da superfi'cie.  O valor _Lines Closer_
     e' um fator de correc,a~o -- Geomview modifica sutilmente todas as
     linhas que o algori'tmo da a'rea de armazanamento tempora'ria
     desenha fechando para a ca^mera atrave's desse fator.  O nu'mero
     deve ser um inteiro pequeno; tente 5 ou 10.  O valor zero (0)
     desabilita esse recurso completamente.  Escolhendo valores grandes
     tornara' as linhas visi'veis mesmo quando elas devam ser
     escondidas.

_SPACE MODEL_
     Essa opc,a~o determina o modelo usado para desenhar o objeto
     mundo.  E' mais u'til em espac,os hiperbo'licos e esfe'ricos.
     Voce^ provavelmente na~o necessitara' tocar esse navegador se
     voce^ permanecer no espac,o Euclideano.  Para mais informac,a~o
     sobre esses modelos, veja *note Geometrias Nao-Euclidianas::.
    _Virtual_
          Esse e' o modelo padra~o e representa a visualizac,a~o
          natural de dentro do espac,o.

    _Projective_
          Corresponde ao modelo projetivo do espac,o hiperbo'lico e do
          espac,o esfe'rico.  Geoms movem-se obedecendo as isometrias
          do espac,o, e ca^meras movem-se atrave's de movimentos
          Euclideanos.  Por padra~o em modelos projetivos, a esfera
          unita'ria Euclidiana e' desenhada.  No espac,o hiperbo'lico
          essa esfera localiza-se no infinito.  No espac,o Euclideano o
          modelo projetivo e' o mesmo que o modelo virtual exceto que a
          esferea e' desenhada por padra~o.

    _Conformal_
          Corresponde ao modelo conformal do espac,o hiperbo'lico e do
          espac,o esfe'rico.  Geoms movem-se obedecendo as isometrias
          do espaco, e ca^meras move-se atrave's de movimentos
          Euclideanos.  No espac,o Euclidiano, o modelo conformal
          equivale a inverter tudo na esfera unita'ria.

_Draw Sphere_
     Essa opc,a~o controla se Geomview desenha a esfera unita'ria ou
     na~o.  Por padra~o a esfera unita'ria aparece no modelo projetivo
     e no modelo conformal.  No espac,o hiperbo'lico a esfera e'
     colocada no infinito.  No espac,o esfe'rico corresponde a` esfera
     equatorial.

_Done_
     Esse bota~o dispensa o painel de _Cameras_.



File: geomview-pt_BR,  Node: Gravando,  Next: Comandos,  Prev: Cameras,  Up: Interacao

3.8 Gravando Seu Trabalho
=========================

O painel _Save_ do Geomview permite a voce^ armazenar objetos do
Geomview e outra informac,a~o em arquivos que voce^ pode recuperar
dentro do Geomview ou a partir de outros programas.
 Figura 3.9: O Painel Gravar.

   Para usar o painel _Save_ voce^ seleciona o formato desejado no
navegador perto da palavra _Save_, informe o nome do objeto que voce^
quer gravar no campo de texto perto da palavra _for_, e informe o nome
do local no qual voce^ deseja gravar o arquivo no campo longo de texto
perto da palavra _in_.  Voce^ pode ou pressionar `<Enter>' ou clicar
sobre o bota~o _OK_.  Quando o arquivo tiver sido gravado no local
desejado, o painel _Save_ desaparecera'.  Caso voce^ queira dispensar o
painel _Save_ sem gravar um arquivo, clique no bota~o _Cancel_.

   Caso voce^ especifique `-' como nome de arquivo, Geomview mostra o
arquivo na sai'da padra~o, i.e. na janela de shell a partir da qual
voce^ invocou o Geomview.

   Os possi'veis formatos sa~o fornecidos abaixo.  O tipo de objeto que
pode ser escrito com cada formato e' fornecido entre pare^ntesis.

_Commands (qualquer objeto)_
     A opc,a~o "Commands" escreve um arquivo de comandos GCL contendo
     todas as informac,o~es sobre o objeto.  Chamando o arquivo
     posteriormente ira' restaurar o objeto bem como todas as outras
     informac,o~es sobre o referido objeto, tais como apare^ncia,
     transformac,o~es, etc.

_Geometry alone (geom)_
     A opc,a~o "Geometry alone" escreve um arquivo OOGL contendo apenas
     a geo-metria do objeto.

_Geometry [in world] (geom)_
     A opc,a~o "Geometry [in world]" escreve um arquivo OOGL contendo a
     geometria do objeto, transformado sob a transformac,a~o atual do
     Geomview para esse objeto.  Use a opc,a~o "Geometry [in world]"
     caso voce^ tenha movido o objeto de sua posic,a~o inicial e queira
     a nova posic,a~o em relac,a~o ao objeto mundo.

_Geometry [in universe] (geom)_
     A opc,a~o "Geometry [in universe]" grava um arquivo OOGL contendo
     apenas a geometria do geom, transformado sob transformac,o~es
     sofridas pelo objeto e tambe'm sob transformac,o~es sofridas pelo
     objeto mundo.

_RMan [->tiff] (camera)_
     A opc,a~o "RMan [->tiff]" escreve um arquivo que quando for
     renderizado cria uma imagem tiff. Transpare^ncia e textura (a mais
     recente somente ate' certo ponto) estara' disponi'vel.

_RMan [->frame] (camera)_
     A opc,a~o "RMan [->frame]" escreve um arquivo RenderMan que quando
     for rede-rizado faz com que uma imagem aparec,a em uma janela na
     tela. Transpare^ncia e textura (a mais recente somente ate' certo
     ponto) estara' disponi'vel.

_SGI snapshot (camera)_
     A opc,a~o "SGI snapshot" escreve um arquivo de varredura SGI.  Uma
     campainha toca quando o instanta^neo for completado.  Somente
     disponi'vel em sistemas SGI.

_PPM GLX-offscreen snapshot (camera)_
     Renderiza uma cena completa novamente dentro da memo'ria
     off-screen; GLX fornece os meios para usar um Pixmap como a'rea de
     renderizac,a~o. A vantagem de renderizar dentro da memo'ria
     _off_-screen em relac,a~o a pegar um instanta^neo de tela e' que a
     janela de ca^mera na~o precisa ser mapeada e tambe'm na~o precisa
     aparece na hora do intanta^neo e' realizado. De forma que com o
     intanta^neo off-screen se pode seguramente colocar a janela de
     ca^mera no formato de i'cone (mas na~o fecha'-la!), ativar a
     protec,a~o de tela e ir dormir enquanto algum script avanc,a as
     cenas e grava os instanta^neos.

_PPM Screen snapshot (camera)_
     Grava os instanta^neos a partir da janela fornecida e grava no
     formato de imagem PPM.  Se voce^ especificar uma seque^ncia de
     caracteres comec,ando com um barra vertical (`|') como nome de
     arquivo, isso e' interpretado com um comando de redirecionamento
     do shell para o qual os dados do PPM devera~o ser canalizados,
     como em `| pnmtotiff > snap.tiff' ou em `| convert -geometry 50%
     ppm:- snap.gif'.

     Instanta^neos de tela PPM esta~o somente disponi'veis com GL e
     open GL, na~o com gra'ficos X somente.  A janela pode ocupar
     inteiramente tela.  Geomview ira' garantir que na~o haja outras
     janelas reproduzindo-a enquanto o instanta^neo e' gravado. E'
     provavelmente melhor usar instanta^neos GLX-_off-screen_, como
     acima exposto.

_PPM software snapshot (camera)_
     Escreve um instanta^neo da janela atualmente visualizada, como uma
     imagem PPM, apra o arquivo fornecido.  O nome do arquivo pode ser
     um comando do shell Bourne precedido por uma barra vertical (`|'),
     da mesma forma que com o insta^nta^neo de tela PPM (PPM screen
     snapshot).  O instanta^neo de software, apesar disso, e' produzido
     atrave's do uso de software renderizador interno (relacionado ao
     renderizador do sistema X-window).  Na~o e' importante se a janela
     esta' visi'vel ou na~o, e e' independente do GL ou do OpenGL.
     Tambe'm essa opc,a~o na~o suporta alguns recursos, tais como
     mapeamento de textura.

_Postscript snapshot (camera)_
     Escreve um instanta^neo Postscript da visa~o da ca^mera.  O
     instanta^neo e' feito atrave's da decomposic,a~o da cena em linhas
     e poli'gonos, ordenando por intensidade, e gerando linhas no
     formato Postscript e poli'gonos para cada uma.  Vantagens desse
     processo sobre o processo baseado em pixes do instanta^neo de
     imagens: a resoluc,a~o e' muito alta, de forma que arestas parecem
     na posic,a~o correta mesmo em impressoras de alta resoluc,a~o, ou
     imagens de resoluc,a~o compara'vel sa~o tipicamente muito mais
     compactas.  Desvantagens: ordenac,a~o por intensidade fornece bons
     resultados em algumas cenas, mas pode ser grandemente ruim como no
     algori'tmo de remoc,a~o de cenas ocultas em outras cenas.
     Tambe'm, Postscript na~o oferece sombreamento interpolado linear,
     somente sombreamento linear simples para cada faceta.

_Camera (camera)_
     Escreve um arquivo OOGL de uma ca^mera.

_Transform [to world] (qualquerobjeto)_
     Escreve um arquivo de transformac,a~o OOGL fornecendo
     transformac,a~o do Geomview para o objeto.

_Transform [to universe] (qualquerobjeto)_
     Escreve um arquivo de transformac,a~o OOGL fornecendo uma
     transformac,a~o que e' a composic,a~o de transformac,a~o do
     Geomview para o objeto e a transformac,a~o sofrida pelo objeto
     mundo.

_Window (camera)_
     Escreve um arquivo de janela OOGL para uma ca^mera.

_Panels_
     Escreve um arquivo GCL contendo comandos que gravam o estado de
     todos os paine'is do Geomview.  Chamando esse arquivo
     posteriormente ira' restaurar as posic,o~es de todos os paine'is.



File: geomview-pt_BR,  Node: Comandos,  Next: Atalhos de Teclado,  Prev: Gravando,  Up: Interacao

3.9 O Painel de Comandos
========================

O painel de comandos (_Commands_) permite a voce^ digitar comandos GCL.
Quando voce^ pressionar `<Enter>', Geomview interpreta o comando e
imprime qualquer sai'da resultante ou uma mensagens de erro para a
sai'da padra~o.  Voce^ pode editar o texto e pressionar `<Enter>'
tantas vezes quantas voce^ quiser, em geral, mesmo que voce^ pressione
(`<Enter>') com o cursor no painel de comandos ( _Commands_), Geomview
tenta interpretar se aquele texto que voce^ tiver digitado no campo de
texto como um comando.
 [image src="figs/command.png" ]

Figura 3.10: O Painel de Comandos.


File: geomview-pt_BR,  Node: Atalhos de Teclado,  Prev: Comandos,  Up: Interacao

3.10 Atalhos de Teclado
=======================

A maioria das ac,o~es que voce^ pode fazer atrave's dos paine'is do
Geomview possui as equivalentes teclas de atalho de forma que voce^
pode fazer a mesma ac,a~o digitando uma seque^ncia de teclas usando o
teclado.  Isso e' u'til para usua'rios avanc,ados que forem
familiarizados com as capacidades do Geomview e que queiram trabalhar
rapidamente sem ter montes de paine'is confundindo a tela.  Teclas de
atalho comumente sa~o indicadas entre colche^tes ([ ]) pro'ximo ao item
correspondente em um painel.  Por exemplo, a tecla de atalho para o
modo de rotac,a~o (_Rotate_) e' 'r'; isso e' indicado por "[r]"
aparecendo antes da palavra "Rotate" no navegador _MOTION MODE_.  Para
utilizar essa tecla de atalho apenas pressione a tecla `r' enquanto o
cursor do mouse estiver sobre qualquer janela do Geomview.  Voce^ na~o
precisa pressionar a tecla `<Enter>' ou teclas de `<SPACE>'.

   Alguns atalhos consistem de mais que uma tecla.  Nesses casos apenas
digite as teclas indicadas uma apo's a outra e na ordem indicada, sem
`<Enter>' apo's cada tecla.  Atalhos de teclado sa~o sensi'veis a`
caixa alta/baixa.  Voce^ pode cancelar atalhos compostos por va'rias
teclas que voce^ tiver iniciado a digitac,a~o digitando qualquer tecla
inva'lida como de atalho, por exemplo a barra de espac,o.

   Comandos de teclado aplicam-se enquanto o cursor estiver em qualquer
janela de ca^mera e na maioria dos paine'is de controle.

   Muitas teclas de atalho permitem argumentos nume'ricos que voce^
digitar como um prefixo a tecla(s) de comando.  Por exemplo, a tecla de
atalho para _Near clip_ no painel de ca^mera e' `v n'.  Para escolher o
pro'ximo plano de corte para `0.5', digite `0.5vn'.  Comandos que na~o
recebem um prefixo nume'rico modificam ou mudam para zero o valor atual.

   A maioria dos comando permitem um dos seguintes prefixos de
selec,a~o.  Se nenhum objeto for fornecido o comando aplica-se ao
objeto alvo.

`g'
     objeto geome'trico mundo ("world")

`g#'
     #'e'simo objeto geome'trico ("geom")

`g*'
     Todos os objetos geome'tricos ("geoms")

`c'
     ca^mera atual

`c#'
     #'e'sima ca^mera

`c*'
     Todas as ca^meras

   Por exemplo, `g4af' significa modifique a face desenhada do objeto
_g4_.

   Simplesmente digitando um prefixo de selec,a~o, como `g4', na~o
seleciona um objeto ainda; isso somente acontece quando um comando,
como `ae', segue o prefixo.  Para selecionar um objeto como alvo sem
fazer nada mais para isso, use o comando `p'.  Enta~o `g3p' seleciona o
objeto g3.

   O campo de texto no canto superior esquerdo faz o painel principal
(_Main_) mostrar o estado da tecla de atalho atual.

   Para adic,a~o de teclas de atalho ao painel de comandos, existe
tambe'm um atalho para selecionar um objeto alvo: digite o nome curto do
objeto seguido por `p'.  Por exemplo, para selecionar o objeto _g3_,
digite `g 3 p'.  Essa forma funciona somente com nomes curtos -- aqueles
que aparecem entre colche^tes ([ ]) no navegador de alvos (_Targets_) do
painel principal _Main_.

   Abaixo encontra-se um suma'rio de todas as teclas de atalho.

Desenho

    `af'
          Faces

    `ae'
          Arestas

    `an'
          Normais

    `ab'
          Caixas Associadas

    `aV'
          Vetores

Sombreamento

    `0as'
          Constante

    `1as'
          Mono'tono

    `2as'
          Linear

    `3as'
          Linear, na~o iluminado

    `aT'
          permite transpare^ncia

    `at'
          mapeamento de textura

Outro

    `av'
          vira as normais pelo avesso: sempre visualizador de face

    `#aw'
          Espessura da linha (em pixels)

    `aC'
          manuseia poli'gonos co^ncavos

    `#vc'
          fechador de arestas que na~o pertencem a faces (tente 5-100)

Cor

    `Cf'
          faces

    `Ce'
          arestas

    `Cn'
          normais

    `Cb'
          caixas associadas

    `CB'
          fundo

Movimentos

    `r'
          rotac,a~o

    `t'
          translac,a~o

    `z'
          modificac,o~es proporcionais de tamanho (FOV - campo de
          visa~o)

    `f'
          vo^o

    `o'
          orbita

    `s'
          homotetia

    `w'
          recentralizar o alvo

    `W'
          recentralizar tudo

    `h'
          pare

    `H'
          pare tudo

    `@'
          selecione o centro do movimento (e.g. `g 3 @')

    `L'
          Olhe para objeto

Visualizando

    `0vp'
          visa~o Ortogra'fica

    `1vp'
          visa~o em perspectiva

    `vd'
          Habilite outras ca^meras de visa~o

    `#vv'
          campo de visa~o

    `#vn'
          pro'xima dista^ncia de corte

    `#vf'
          dista^ncia de corte afastada

    `v+'
          adicione nova ca^mera

    `vx'
          cursor ligado/desligado

    `vb'
          face de tra's de um poli'gono separada habilitada/desabilitada

    `#vl'
          dista^ncia focal

    `v~'
          Tonalidade feita via software ligada/desligada

Paine'is

    `Pm'
          Principal

    `Pa'
          Apare^ncia

    `Pl'
          Iluminac,a~o

    `Po'
          Obscuro

    `Pt'
          Ferramentas

    `Pc'
          Ca^meras

    `PC'
          Comandos

    `Pf'
          arquivos

    `Ps'
          Salvar

    `P-'
          ler comandos pelo tty

    `PA'
          Cre'ditos ("about")

Luzes

    `ls'
          mostrar luzes

    `le'
          editar luzes

Espac,o

    `me'
          Euclidiano

    `mh'
          Hiperbo'lico

    `ms'
          Esfe'rico

Modelo

    `mv'
          Virtual

    `mp'
          Projetivo

    `mc'
          Conformal

Outro

    `0N'
          normalizac,a~o: nenhuma

    `1N'
          normalizac,a~o: individual

    `2N all'
          normalizac,a~o: todos

    `ui'
          movimento: Ine'rcial

    `uc'
          movimento: Contrac,a~o para o eixo

    `uo'
          movimento: coordenadas pro'prias do objeto

    `<'

    `Pf'
          carregar arquivo geome'trico ou de comandos

    `dd'
          apagar objeto alvo

    `>'

    `Ps'
          grave o estado atual em um arquivo

    `TV'
          mudar para o modo NTSC

    `p'
          selecionar como objeto alvo (e.g. `g 3 p')     Sem preixo,
          seleciona o objeto sob o     cursor do mouse (da mesma forma
          que duplo-clicando o bota~o direito do mouse)


File: geomview-pt_BR,  Node: Formatos dos Arquivos da OOGL,  Next: Customizacao,  Prev: Interacao,  Up: Top

4 Formatos dos Arquivos da OOGL
*******************************

Os objetos que voce^ pode carregar dentro do Geomview sa~o chamados
objetos OOGL.  OOGL significa "Object Oriented Graphics Library"
(biblioteca gra'fica orientada a objetos); e' a biblioteca sobre a qual
Geomview e' construi'do.

   Existem muitos tipos diferentes de objetos OOGL.  Esse capi'tulo
fornece descric,o~es sinta'ticas de formatos de arquivo para objetos
OOGL.

   Exemplos da maioria dos tipos de arquivo podem ser encontrados no
direto'rio `data/geom' do Geomview.

* Menu:

* Convencoes::                    Conventions and general remarks.
* Formatos de Arquivo de Objeto:: Formatos de Arquivo de Objeto.
* Objetos nao-geometricos::         Non-geometric objetos.


File: geomview-pt_BR,  Node: Convencoes,  Next: Formatos de Arquivo de Objeto,  Prev: Formatos dos Arquivos da OOGL,  Up: Formatos dos Arquivos da OOGL

4.1 Convenc,o~es
================

* Menu:

* Sintaxe comum::                   Sintaxe Comum a Todos os formatos de arquivo da OOGL.
* Nomes de arquivos::               Nomes de Arquivo.
* Vertices::                        Ve'rtices.
* ND-Vertices::                     Ve'rtices N-dimensionais.
* Direcoes de superficies normais:: Direc,a~o de superfi'cies normais.
* Matrizes de transformacao::       Matrizes de transformac,a~o.
* Matrizes de transformacao ND::    Matrizes de transformac,a~o N-dimensional.
* Formato binario::                 Formato bina'rio.
* Referencias::                     Objetos embargados e refere^ncias externa a objeto.
* Aparencias::                      Apare^ncias.
* Mapeamento de Textura::           Mapeamento de textura.


File: geomview-pt_BR,  Node: Sintaxe comum,  Next: Nomes de arquivos,  Prev: Convencoes,  Up: Convencoes

4.1.1 Sintaxe Comum a Todos os Formatos de Arquivo da OOGL
----------------------------------------------------------

A maioria dos formatos de arquivo de objeto OOGL sa~o do formato livre
ASCII -- qualquer quantidade de espac,os em branco (caracteres na~o
imprimi'veis, tabulac,o~es, caractere de nova linha) pode aparecer
entre os sinalizadores (nu'meros, palavras chave, etc.).  Paradas de
linha sa~o na maioria das vezes sempre insignificantes, com algumas
excesso~es devidamente ressaltadas.  Comenta'rios comec,am com # e
continuam ate' o fim da linha; esses comenta'rios sa~o permitidos em
qualquer lugar onde um caractere de nova linha for permitido tambe'm.

   Formatos bina'rios sa~o tambe'm definidos para muitos objetos; Veja
*note Formato binario::, e as descric,o~es individuais do objeto.

   Objetos ti'picos OOGL comec,am com uma palavra chave designando o
tipo de objeto, possivelmente com modificadores indicando a presenc,a
de informac,o~es de cor, etc.  Em alguns formatos a palavra chave e'
opcional, por questo~es de compatibilidade com formatos de arquivo
definidos em outros lugares.  O tipos de objeto e' enta~o determinado
por suposic,a~o sobre o sufixo do arquivo (se houver) ou pelos dados em
si mesmos.

   Palavras chave sa~o sensi'veis a` caixa alta/baixa.  Algumas
palavras chave possuem letras de prefixo adicionais indicando a
presenc,a de cor ou outros dados; nesse caso a ordem dos prefixos e'
importante, e.g. `CNMESH' e' significativo mas `NCMESH' e' inva'lido.


File: geomview-pt_BR,  Node: Nomes de arquivos,  Next: Vertices,  Prev: Sintaxe comum,  Up: Convencoes

4.1.2 Nomes de Arquivo
----------------------

Quando objetos OOGL sa~o lidos de arquivos localizados em disco, a
biblioteca OOGL usa o sufixo do arquivo para supor o tipo de arquivo.

   Se o sufixo for desconhecido, ou estiver ause^nte (e.g. para um
objeto sendo lido a partir da sai'da de um outro comando diretamente,
ou lido diretamente de dentro de um outro objeto OOGL), todos os tipos
conhecidos de objeto sa~o tentados por sua vez ate' que se aceite os
dados como va'lidos.


File: geomview-pt_BR,  Node: Vertices,  Next: ND-Vertices,  Prev: Nomes de arquivos,  Up: Convencoes

4.1.3 Ve'rtices
---------------

Muitos objetos compartilham um estilo comum de representar ve'rtices com
opc,o~es de superfi'cie normal de ve'rtice e cor.  Todos os ve'rtices
dentro de um objeto possuem o mesmo formato, especificado pela palavra
chave no cabec,alho.

   Todos os dados para um ve'rtice esta~o agrupados juntos (em
oposic,a~o a e.g. fornecimento de coordenadas para todos os ve'rtices,
em seguida cores para todos os ve'rtices, e assim por diante).

   A sintaxe e'

`X  Y  Z'
     (coordenadas do ve'rtice tridimensionais em ponto flutuante) ou

`X  Y  Z  W'
     (coordenadas do ve'rtice tetradimensionais em ponto flutuante)

   opcionalmente seguida por

`NX  NY  NZ'
     (superfi'cie normalizada tridimensional se presente)

   opcionalmente seguida por

`R  G  b  A'
     (componente qua'drupla em ponto flutuante se presente, cada
     componente no intervalo 0..1.  A componente A (alfa) representa a
     opacidade: 0 transparente, 1 opaco.)

     opcionalmente seguida por

`S T'

`ou'

`S T U'

   (duas ou tre^s valores coordenados de textura).

   Valores sa~o separados por espac,os em branco, e quebras de linha
sa~o imateriais.

   Letras na palavra chave de cabec,alho do objeto devem aparecer numa
ordem especi'fica; isto e' a ordem reversa na qual os dados sa~o
fornecidos para cada ve'rtice.  Enta~o ve'rtices de objeto do tipo
`CN4OFF' possuem primeiramente as componentes quadridimensionais de
posicionamento no espac,o, a seguir as componentes normais
tridimensionais, finalmente as componentes quadridimensionais de cor.
Voce^ pode modificar a ordem dos dados modificando o cabec,alho de
palavra chave; um `NCOFF' e' apenas na~o reconhecido.


File: geomview-pt_BR,  Node: ND-Vertices,  Next: Direcoes de superficies normais,  Prev: Vertices,  Up: Convencoes

4.1.4 Ve'rtices N-dimensionais
------------------------------

Muitos objetos compartilham um estilo comum de representac,a~o de
ve'rtice com opcionais de superfi'cie normal e cor.  Todos os ve'rtices
dentro de um objeto possuem o mesmo formato, especificado pela palavra
chave do cabec,alho.

   Todos os dados para um ve'rtice esta~o agrupados juntos (em
oposic,a~o a e.g. fornecendo coordenadas para todos os ve'rtices, a
seguir cores para todos os ve'rtices, e assim por diante).

   A sintaxe para ve'rtices N-dimensionais (N > 3) e'

`X[1]  X[2]  X[3] X[4] ...'
     (N coordenadas do ve'rtice em ponto flutuante) ou

`X[0] X[1]  X[2]  X[3] X[4] ...'
     ((N+1) coordenadas do ve'rtice em ponto flutuante, se o
     modificador `4' tiver sido especificado na linha de cabec,alho do
     objeto)

   Note, todavia, que objetos N-dimensionais internamente sempre possuem
pontos (N+1)-dimensionais; a primeira componente X[0] - se presente no
arquivo do objeto file - e' usada como divisor homoge^neo. Isso e'
diferente do caso tridimensional comum onde o modificador `4' gera um
objeto quadridimensional onde a componente quadridimensional
implicitamente e' escolhida para 1.

   Componentes de cor usualmente podem ser especificadas da mesma forma
que para ve'rtices tridimensionais, Veja *note Vertices::, enquanto
especificando componentes de cor em normais na~o faz sentido.


File: geomview-pt_BR,  Node: Direcoes de superficies normais,  Next: Matrizes de transformacao,  Prev: ND-Vertices,  Up: Convencoes

4.1.5 Direc,o~es de superfi'cies normais
----------------------------------------

Geomview utiliza vetores normais para determinar como um objeto e'
compartilhado.  A direc,a~o da normal e' importante nesse ca'lculo.

   Quando normais forem fornecidos com um objeto, a direc,a~o da normal
e' determinada pelos dados fornecidos.

   Quando normais na~o forem fornecidos com o objeto, Geomview calcula
vetores normais automaticamente; nesse caso normais apontam para
adiante do lado do qual os ve'rtices aparecem na ordem anti-hora'ria.

   Sobre superfi'cies parame'tricas (retalhos de Bezier), o vetor
normal no ponto P(u,v) esta' na direc,a~o dP/du multiplicado
vetorialmente por dP/dv.


File: geomview-pt_BR,  Node: Matrizes de transformacao,  Next: Matrizes de transformacao ND,  Prev: Direcoes de superficies normais,  Up: Convencoes

4.1.6 Matrizes de transformac,a~o
---------------------------------

Alguns objetos incorporam matrizes quadradas reais de ordem 4 para
transformac,o~es sobre objetos homoge^neos.  Essas matrizes atuam
atrave's de multiplicac,a~o a` direita de vetores.  Dessa forma, se p
for um vetor linha de 4 elementos representando coordenadas homoge^neas
de um ponto no objeto OOGL, e A for a matrix 4x4, enta~o o ponto
resultante da transformac,a~o e' p' = p A.  Essa convenc,a~o matricial
e' comum em computac,a~o gra'fica; e' a matriz transposta daquela
muitas vezes usada em matema'tica, onde pontos sa~o vetores coluna
multiplicados a` direita pelas matrizes.

   Dessa forma para transformac,o~es Euclideanas, as componentes para
translac,a~o aparecem na quarta linha (os u'ltimos quatro elementos) da
matriz A.  A u'ltima coluna da matriz A (quarto, oitavo, de'cimo
segundo e de'cimo sexto elementos) sa~o tipicamente 0, 0, 0, e 1
respectivamente.


File: geomview-pt_BR,  Node: Matrizes de transformacao ND,  Next: Formato binario,  Prev: Matrizes de transformacao,  Up: Convencoes

4.1.7 Matrizes de transformac,a~o ND
------------------------------------

No contexto do espac,o N-dimensional (N > 3) alguns objetos incorporam
(N+1)x(N+1) matrizes reais para transformac,o~es sobre objetos
homoge^neos.  Essas matrizes atuam atrave's de multiplicac,a~o a`
direita de vetores.  Dessa forma, se p for um vetor linha de
(N+1)-elementos representando coordenadas homoge^neas de um ponto no
objeto OOGL, e A e' a matriz quadrada de ordem (N+1), enta~o o ponto
resultante da transformac,a~o e' p' = p A.

   Note que (a excessa~o de matrizes de transformac,a~o 4x4, veja *note
Matrizes de transformacao::) a componente homoge^nea e' localizada nos
elementos com i'ndice zero, de forma que componentes de transformac,a~o
para transformac,o~es Euclideanas aparecem na zero-e'sima linha
(primeiros (N+1) elementos). A primeira coluna da matriz A (a coluna
com i'ndice zero) e' tipicamente 1, 0, ..., 0.


File: geomview-pt_BR,  Node: Formato binario,  Next: Referencias,  Prev: Matrizes de transformacao ND,  Up: Convencoes

4.1.8 Formato bina'rio
----------------------

Muitos objetos OOGL aceitam formatos o formato de arquivo bina'rio bem
como o formato de arquivo ASCII.  Esses arquivos comec,am com a
indicac,a~o usual (e.g. `CQUAD') seguida pela palavra `BINARY'.  Dados
bina'rios iniciam-se no byte imediatamente seguinte ao primeiro
caractere de nova linha apo's a palavra `BINARY'.  Espac,os em branco e
um simples comenta'rio podem atrapalhar, e.g.

     OFF BINARY	# binary-format "OFF" data follows

   Dados bina'rios compreendem inteiros de 32 bits e os inteiros em
ponto flutuante de 32 bits conforme definido pela IEEE (IEEE Standard
for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985 -
Institute of Electrical and Electronics Engineers), ambos os formatos
seguem a` forma de ordenac,a~o "big-endian" (i.e., com o byte mais
significativo em primeiro lugar).  Esse e' o formato nativo para tipos
de dado int e tipos de dado float em sistemas do tipo Sun-3, Sun-4, e
Irises, ale'm de muitos outros sistemas.

   Formatos de dados bina'rios assemelham-se aos formatos
correspondentes em ASCII, com tipos de dado "int" e tipos de dado
"float" nos lugares que voce^ esta' acostumado a encontrar.  Existe
algumas excesso~es todavia, especificamente dos formatos d arquivo
`QUAD', `OFF' e `COMMENT'.  Detalhes sa~o fornecidos no arquivo
individual das descric,o~es do formato especi'fico.  Veja em *note
QUAD::, *note OFF::, e em *Note COMMENT::.

   Objetos OOGL bina'rios podem ser livremente misturados em fluxos de
objetos ASCII:

     LIST
     { = MESH BINARY
     ... dados bina'rios de uma malha aqui ...
     }
     { = QUAD
     	1 0 0   0 0 1   0 1 0  0 1 0
     }

   Note que dados ASCII continuam seguindo imediatamente o u'ltimo byte
dos dados bina'rios.

   Naturalmente, e' impossi'vel incluir comenta'rios dentro de um
objeto em formato bina'rio OOGL, todavia comenta'rios podem aparecer no
cabec,alho antes do ini'cio dos dados bina'rios.


File: geomview-pt_BR,  Node: Referencias,  Next: Aparencias,  Prev: Formato binario,  Up: Convencoes

4.1.9 Refere^ncias a Objetos Embutidos e a Objetos Externos
-----------------------------------------------------------

Alguns tipos de objeto OOGL (`LIST', `INST') permitem refere^ncias a
outros objetos OOGL, que podem aparecer literalmente no fluxo de dados,
serem chamados a partir de arquivos em disco, ou serem comunicados a
partir de outro lugar via objetos nomeados.  Comandos GCL tambe'm
aceitam objetos geome'tricos atrave's desses meios citados.

   A sintaxe gene'rica e'

      <oogl-object>  ::=
     	[ "{" ]
     	    [ "define" `symbolname' ]
     	    [ ["="] `object-keyword' ...
     		 | "<" `filename'
     		 | ":" `symbolname' ]
     	[ "}" ]

   onde os itens entre aspas duplas sa~o seque^ncias de caracteres
literais (que aparecem sem as aspas), os itens entre colche^tes ([])
sa~o opcionais, e a barra vertical (|) denota alternativas.  Chaves,
quando estiverem presentes, apenas indicam coincide^ncia; o par mais
externo de chaves e' geralmente requerido quando o objeto estiver em um
contexto maior, e.g. quando for parte de um objeto maior ou inclui'do
em um fluxo de comando do Geomview.

   Por exemplo, cada uma das tre^s linhas seguintes:
     	{ define fred   QUAD 1 0 0  0 0 1  0 1 0  1 0 0 }

     	{ define fred = QUAD 1 0 0  0 0 1  0 1 0  1 0 0 }

     	{ appearance { +edge } LIST { < "file1" } { : fred } }

     	VECT 1 2 0   2 0   0 0 0   1 1 2
   e' um bojeto OOGL va'lido.  O u'ltimo exemplo e' va'lido somente
quando estiver delimitado precisamente e residindo precisamente no seu
pro'prio arquivo em disco.

   A construc,a~o com ":" permite refere^ncia a si'mbolos, criados com
`define'. Um valor inicial de um si'mbolo e' um objeto nulo.  Quando um
si'mbolo for (re)definido, todas as refere^ncias a esse si'mbolo sa~o
automaticamente modificadas.

   A construc,a~o "`define' NOME" permite definir um simbolo global para
um objeto especificado. Se "NOME" referir-se a um objeto que ja'
existia anteriormente, enta~o o antigo objeto e' descartado e
substitui'do pela nova definic,a~o. Veja *note `(read ...)': read.
*note `(hdefine ...)': hdefine.

   A construc,a~o "<" faz com que um arquivo em disco seja lido.  Note
que isso na~o e' um mecanismo textual gene'rico de uso da diretiva de
programac,a~o "include"; um objeto OOGL completo deve aparecer no
arquivo referenciado na construc,a~o  "<".

   Arquivos lidos usando "<" sa~o procurados primeiramente no
direto'rio do arquivo que e' refrenciado em "<", se existir; se essa
busca falhar, o caminho normal de busca (veja *note `(load-path ...)':
load-path.) e' usado.  A busca padra~o olha primeiro no direto'rio
atual, a seguir nos direto'rios de dados do Geomview.

   Ressaltando, espac,os em branco e caracteres indicadores de final de
linha sa~o insignificantes, e comenta'rios de "#" podem aparecer em
qualquer lugar.


File: geomview-pt_BR,  Node: Aparencias,  Next: Mapeamento de Textura,  Prev: Referencias,  Up: Convencoes

4.1.10 Apare^ncias
------------------

Objetos geome'tricos podem ter informac,o~es de apare^ncia associada,
especificando tonalidade, brilho, cor, visualizac,a~o wire-frame vs.
shaded-surface, e assim por diante.  Apare^ncias sa~o erdadas atrave's
de hierarqui'as de objetos, e.g. anexando uma apare^ncia a uma lista
(`LIST') significa que a apare^ncia e' aplicada a todos os membros de
`LIST'.

   Algumas propriedades relacionada a apare^ncia sa~o relegadas a
subestruturas tais como "material", "lighting" e "texture". Seja
cuidadoso para notar quais propriedade pertencem a qual estrutura.
Qualquer objeto geome'trico pode ser precedido por uma definic,a~o de
apare^ncia como no sguinte exemplo:

     {
        appearance { +edge }
        LIST { < "arquivo1" } { QUAD 1 0 0  0 0 1  0 1 0  1 0 0 }
     }

   Apare^ncias sa~o tambe'm objetos OOGL no seu pro'prio direito e pode
ser fornecido nomes simbo'licos e refere^ncia a elas. Veja (*note
Referencias::) e em *note Objetos de apare^ncia: Objetos de aparencia.

Texture Mapping
     Existe uma sec,a~o separada com relac,a~o a definic,a~o de
     texturas: (*note Mapeamento de Textura::).

Transparency
     Objetos de renderizac,a~o translu'cida na~o sa~o suportados por
     todos os desenhadores que funcionam no Geomview. O renderizador
     OpenGL tem suporte limitado para isso: objetos de ni'vel mais alto
     (i.e. aqueles que aparecem no navegador de objetos do painel
     principal (veja *note O Painel Principal: Interacao Basica.) sa~o
     renderizados corretamente por meio de alpha-blending). Tambe'm, os
     instanta^neos do RenderMan ira~o incluir valores de opacidade.

   Aqui esta' um exemplo de estrutura de apare^ncia incluindo valores
para todos atributos.  A ordem dos atributos na~o e' importante.  Como
usual, espac,os em branco ssa~o irrelevates.  Atributos Booleanos podem
ser precedidos por "+" ou "-" para torna'-los habilitados ou
desabilitados; "+" e' assumido se somente o nome do atributo aparecer.
Outros valores esperados de atributo.

   Um "*" prefixado a um atributo, e.g. "*+edge" ou "*linewidth 2" ou
"material { *diffuse 1 1 .25 }", seleciona a situac,a~o atual para
sobrescrever ("override") para aquele atributo.

     appearance {
       +face               # (Faz) desenho de faces dos poli'gonos.  Habili-
                           # tado por padra~o.
       -edge               # (Na~o faz) desenho de arestas de poli'gonos.
       +vect               # (Faz) desenho de vetores (VECTs).  Habilitado
                           # por padra~o.

       transparent screendoor
                           # (Habilita) transpare^ncia. Habilitac,a~o de
                           # transpare^ncia.
                           # na~o (necessariamente) resulta em cores corretas
                           # no Geomview, mas os valores de alfa sa~o usados
                           # em instanta^neos RenderMan.
                           # As palavras chave permitidas sa~o ``screendoor''
                           # (mascarando pixels de sai'da por meio de um
                           # modelo de ponteamento), ``blending'' para
                           # alpha-blending ( harmonizac,a~o de alfa)
                           # com BSP-tree (a'rvore BSP) particionando o
                           # espac,o e ordenando com precisa~o
                           # (lento) e ``naive'' para harmonizac,a~o de
                           # alfa sem mesmo ordenar com precisa~o, na~o
                           # para falar sobre particionamento de espac,o.
                           # Omitindo a palavra chave o padra~o sera'
                           # harmonizac,a~o de alfa com a'rvore
                           # particionando o espac,o e ordenando com
                           # precisa~o.
       -normal             # (Faz) desenho de vetores normais a uma
                           # superfi'cie.

       normscale 1         # ... com comprimento 1.0 em coordenadas do
                           # objeto.

       +evert              # faz a inversa~o de normais de poli'gono onde
                           # necessa'rio de forma que sempre tenha
                           # ca^mera naquela face

       +texturing          # (Habilita) mapeamento de textura
       +linear             # (Habilita) me'dia linear de elementos de textura
                           # mais fechados

       +mipmap             # (Habilita) mapeamento mip de textura
       +mipinterp          # (Habilita) mapeamento mip linear

       -backcull           # (Na~o faz) descarte da orientac,a~o de faces
                           # no sentido anti-hora'rio

       -concave            # (Na~o faz) presunc,a~o e manuseio de poli'-
                           # gonos co^ncavos

       -shadelines	      # (Na~o faz) linhas de tonalidade como se elas esti-
                           # vessem iluminando cilindros
                           # Esses quatro (mipinterp, backcull, concave,
                           # shadelines) sa~o somente efetivos onde o
                           # sistema gra'fico suporta'-los, a saber em GL e
                           # Open GL.

       -keepcolor	      # Normalmente, quando informac,a~o de cor N-D posi-
                           # cional esta' habilitada como
                           # com o comando do geomview (ND-color ...), todas
                           # as cores de objetos sa~o afetadas.  Mas, objetos
                           # com o atributo "+keepcolor" sa~o imunes a infor-
                           # mac,o~es de cor N-D.

       shading smooth      # ou ``shading constant'' ou ``shading flat'' ou
                           # ou ``shading csmooth'' ou ``shading vcflat''.
                           # smooth = tonalidade de Gouraud, flat = facetado,
                           # csmooth = linearmente interpolado mas na~o
                           # iluminado, vcflat = tonalidade mono'tona, mas
                           # cores linearmente interpoladas.

       linewidth 1         # linhas, pontos, e arestas sa~o da largura de
                           # 1 pixel.

       patchdice 10 10     # subdivide retalhos de Bezier esmiuc,adamente em
                           # u e v

       material {         # Aqui esta' uma definic,a~o material;
                           # pode tambe'm ser lido de um arquivo como em
                           #  ``material < arquivo.mat''

           ka  1.0         # coeficiente de reflexa~o ambiente.
           ambient .3 .5 .3 # cor do ambiente (em componentes de vermelho,
                           # verde, azul). A contribuic,a~o ambiente para a to-
                           # nalidade e' o produto de ka, a cor do ambiente,
                           # pela cor da luz ambiente.

           kd  0.8         # coeficiente de reflexa~o difusa.
           diffuse .9 1 .4 # cor difusa.
                             # (No modo ``shading constant'' (tonalidade
                             # constante), a superfi'cie
                             # e' colorida com a cor difusa.)

           ks 1.0          # coeficiente de reflexa~o especular.
           specular 1 1 1  # cor especular (destacada).
           shininess  25   # expoente especular; grandes valores fornecem
                           # destaques falsos.

           backdiffuse .7 .5 0 # cor da face de tra's para superfi'cies com
                           # dois lados. Se definido, esse campo determina
                           # a cor difusa para o lado de tra's de uma super-
                           # fi'cie. E' implementada atrave's de tonalidade
                           # via software, e por tonalidade via hardware
                           # sob sistemas GL que suportam iluminac,a~o de
                           # dois lados, e sob Open GL.

           alpha   1.0     # opacidade; 0 = transparente (invisi'vel),
                           # 1 = opaco. Ignorado quando a transpare^ncia
                           # estiver desabilitada.

           edgecolor   1 1 0  # cor de linha & aresta

           normalcolor 0 0 0  # cor para vetores normais a uma superfi'cie
       }

       lighting {         # Modelo de iluminac,a~o

           ambient  .3 .3 .3  # luz ambiente

           replacelights   # ``Use somente as seguintes luzes para
                           # iluminar os objetos sob essa
                           # apare^ncia.''
                           # Sem "replacelights" (substituic,a~o de luzes),
                           # quaisquer luzes listadas sa~o adicionadas
                           # a esses na cena.

                           # Agora uma colec,a~o exemplo de luzes:
           light {
               color  1 .7 .6      # cor da luz
               position  1 0 .5 0  # posic,a~o da luz [distant light]
                                   # fornecida em coordenadas homoge^neas.
                                   # Com a quarta componente = 0,
                                   # isso significa uma luz vindo da
                                   # direc,a~o (1,0,.5).
           }

           light {                        # Outra luz.
               color 1 1 1
               position  0 0 .5 1  # luz na posic,a~o finita ...
               location camera     # especificada em coordenadas de ca^mera.
                                   # (Uma vez que a ca^mera olha adiante -Z,
                                   # esse exemplo coloca a luz
                                   # .5 unidade atra's do olho.)
               # Possi'vel palavra chave de localizac,a~o ("location"):
               #  global   posic,a~o da luz global em coordenadas de objeto mundo
               #             (bem, universo). Esse e' o padra~o se nenhuma
               #             localizac,a~o for especificada.
               #  camera   posic,a~o da ca^mera em coordenadas do sistemade
               #             ca^mera
               #  local    posic,a~o local em coordenadas do sistema onde
               #                   a apare^ncia foi definida
           }
       }                   # fim do modelo de iluminac,a~o
       texture {
             clamp st               # ou ``s'' ou ``t'' ou ``none''
             file lump.tiff         # arquivo fornecendo imagem de mapa de
                                    # textura
             alphafile mask.pgm.Z   # arquivo fornecendo imagem de ma'scara
                                    # de transpare^ncia
             apply blend            # ou ``modulate'' ou ``decal''
             transform  1 0 0 0     # superfi'cie (s,t,0,1) * tfm -> coor-
                        0 1 0 0     # denadas de textura
                        0 0 1 0
                       .5 0 0 1

             background 1 0 0 1     # relevante para ``apply blend''
       }
     }                     # fim de apare^ncia

   Existem regras para heranc,a de atributos de apare^ncia quando
muitas apare^ncia sa~o impostas em diferentes ni'veis na hierarqui'a.

   Por exemplo, Geomview instala uma apare^ncia de parada de seguranc,a
que fornece valores padra~o para a maioria dos para^metros; seu painel
de controle instala outras apare^ncias que fornecem novos valores para
uns poucos atributos; a geometria fornecida pelo usua'rio pode tambe'm
conter apare^ncias.

   A regra geral e' que a apare^ncia dos filhos (aquelas fechadas para
as primitivas geome'tricas) vencem.  Adicionalmente, controles de
apare^ncia com situac,a~o atual em sobrescrever ("override") (e.g.
`*+face ou material { *diffuse 1 1 0 }') vencem sobre as outras que
estiverem sem o atributo de sobrescrever.

   Os controles de apare^ncia do Geomview usam o recurso de
sobrescrever "override" de forma a ser efetivo mesmo se objetos
fornecidos pelo usua'rio contiverem suas pro'prias escolhas de
apare^ncia.  Todavia, Se um objeto fornecido pelo usua'rio contiver um
campo de apare^ncia com o recurso de sobrescrever ativado, esse campo
de apare^ncia sera' imune aos controles do Geomview.


File: geomview-pt_BR,  Node: Mapeamento de Textura,  Prev: Aparencias,  Up: Convencoes

4.1.11 Mapeamento de Textura
----------------------------

Alguns programas que trabalham sem contato direto com o usua'rio
suportam objetos mapeados em textura, atualmente apenas o OpenGL e a
interface RenderMan no momento dessa escrita. Existe tambe'm alguns
recursos com a interface RMan quando em uso um canal alfa na imagem de
textura. Aqueles programas que na~o trabalham diretamente com  o
usua'rio cujo suporte a textura na~o existe silenciosamente ignoram
tentativas de uso de mapeamento de textura. Uma textura e' especificada
como parte de uma estrutura de apare^ncia (Veja *note Aparencias::).
Resumidamente, se fornece uma imagem de textura (Veja tambe'm *note
Objetos de imagem: image.), a qual e' considerada contida em um quadrado
no espac,o parametrizado `(s,t)' no intervalo 0 <= s <= 1, 0 <= t <= 1.
Enta~o se fornece uma primitiva geome'trica, com cada ve'rtice
acompanhado com as coordenadas de textura `(s,t)'.  Se a texturizac,a~o
estiver habilitada, a porc,a~o apropriada da imagem de textura e'
colada sobre cada face do objeto texturizado.

   Na~o existe (atualmente) nenhuma provisa~o para heranc,a de parte de
uma estrutura de textura; se a palavra chave `texture' e' mencionada em
uma apare^ncia, essa mensa~o suplanta qualquer outra especificac,a~o de
textura.

   O atributo de apare^ncia `texturing' controla se texturas sa~o
usadas; na~o existe perda de performace tendo campos "texture { ... }"
definidos quando a utilizac,a~o de texturas esta' desabilitada.

   Os campos de textura disponi'veis sa~o:

     clamp   none  -ou-  s  -ou-  t  -ou-  st
       Determina o significado de coordenadas de textura fora do intervalo
       0..1. Com `clamp none', o padra~o, coordenadas sa~o
       interpretadas modulo 1, enta~o (s,t) = (1.25,0), (.25,0), e (-.75,0)
       referem-se todos ao mesmo ponto no espac,o das texturas.  Com
       `clamp s' ou `clamp t' ou `clamp st', individualmente
       ou ambos de s-coordenadas ou t-coordenadas menor que 0 ou
       maior que 1 sa~o remapeadas para 1 ou para 0, respectivamente.

     image { <especificac,a~o de imagem> (*note Objetos de imagem: image.) }
       Especifica a atual imagem de textura. Imagens de textura podem ter
       1, 2, 3 ou 4 canais:
         1 canal:  lumina^ncia
         2 canais: lumina^ncia e alfa (opcidade:0 transparente, 1 opaco)
         3 canais: dados RGB
         4 canais: dados RGBA

       Veja *note Objetos de imagem: image, para a definic,a~o atual de
       objetos de imagem. O canal usado por alfa e' somente interpretado
       como ma'scara: onde a ma'cara e' zero, pixels sa~o simplesmente
       omitidos. Uma excec,a~o e' o caso onde _apply_
       e' igual a _modulate_ e a transluce^ncia esta' habilitada:
       nesse caso o valor de alfa resultante e' o resultado da
       multiplicac,a~o da cor da superfi'cie pelo valor de alfa do
       canal alfa da textura.

     file      nomearquivo
     alphafile nomearquivo
       _Isso e' considerado obsoleto, e somente mantido por compatibilidade,
       o moderno caminho e' usar o novo objeto imagem OOGL. Veja
       *note Objetos de imagem: image.  O material documentado aqui pode
       ainda funcionar apesar disso_

       Especifica arquivos de imagem contendo a textura.

       A palavra chave _file_ especifica um arquivo com informac,o~es de cor
       ou de brilho; _alphafile_ se presente, especifica uma ma'scara de
       transpare^ncia ("alpha"); onde a ma'scara for zero, pixels simplesmente
       sa~o omitidos.  Muitos formatos de arquivo de imagem esta~o
       disponi'veis; o tipo de arquivo deve ser indicado pelos u'ltmos poucos
       caracteres do nome do arquivo:
         .ppm ou .ppm.Z ou .ppm.gz  24-bit 3-color imagem no formato PPM
         .pgm ou .pgm.Z ou .pgm.gz  8-bit tons de cinza imagem no formato PGM
         .sgi ou .sgi.Z ou .sgi.gz  8-bit, 24-bit, ou 32-bit imagem SGI
         .tiff                      8-bit ou 24-bit imagem TIFF
         .gif                       imagem GIF
       Para esse recurso trabalhar, alguns programas devem estar disponi'veis
       no caminho de busca do Geomview:
         zcat  para arquivo .Z
         gzip  para arquivos .gz
         tifftopnm para arquivos .tiff
         giftoppm para arquivos .gif

       Se uma imagem `alphafile' for fornecida, essa imagem deve ser do mesmo
       tamanho que a imagem `file'.

       _Objetos imagem fornecem um caminho mais flexi'vel para especificar dados de
       textura. Veja *note Objetos de imagem: image._

     apply   modulate  -ou-  blend  -ou-  decal
       Indica como a imagem de textura e' aplicada a` superfi'cie.
       Aqui a "surface color" (cor da superfi'cie) significa a cor que a
       superfi'cie pode ter   na ause^ncia de mapeamento de textura.

       Com `modulate', o padra~o, a cor de textura (ou iluminac,a~o,
       se texturizado por meio de uma imagem de escala de cinza) e' multiplicada
       pela cor da superfi'cie.

       Com `blend', textura harmoniza-se entre cor de fundo (`background')
       e a cor da superfi'cie.  O para^metro `file' deve especificar uma
       imagem de escala de cinza.  Onde a imagem de textura e' 0, a cor da
       superfi'cie permanece inalterada; onde for 1, a superfi'cie e'
       colorida na cor dada por `background'; e cor e' interpolada para
       valores imediatos.

       Com `decal', o para^metro `file' deve especificar uma
       imagem de tres cores.  Se um para^metro `alphafile' estiver presente,
       seus valores interpolam-se entre a cor da superfi'cie (onde alpha=0)
       e a cor de textura (onde alpha=1).  Iluminac,a~o na~o afeta a
       cor de textura no modo `decal'; efetivamente a textura e'
       tonalidademente constante.

     background  R G B A
       Especifica uma cor com 4 componentes, com nu'meros R, G, B, e A em
       ponto flutuante normalmente no intervalo 0..1, usados quando
       `apply blend' for selecionado.

     transform `matriz-de-transformac,a~o'
       Espera uma lista de 16 nu'meros, ou um dos outros caminhos de
       representar uma transformac,a~o (`: nomecabec,alho' ou
       `< nomearquivo'). A matriz 4x4 de transformac,a~o e'
       aplicada a coordenadas de textura, no sentido de um vetor linha de
       4 componentes (s,t,0,1) multiplicado a` esquerda pela matriz, para
       produzir novas coordenadas (s',t') a`s quais atualmente indexam a
       textura.


File: geomview-pt_BR,  Node: Formatos de Arquivo de Objeto,  Next: Objetos nao-geometricos,  Prev: Convencoes,  Up: Formatos dos Arquivos da OOGL

4.2 Formatos de Arquivo de Objeto
=================================

* Menu:

* QUAD::                        Lista de quadrila'teros.
* MESH::                        Grade retangular associada.
* BBOX::                        Caixa associada simples.
* BBP and BEZ::                 Lista retalhos de superfi'cies de belzier.
* OFF::                         Poliedros: poli'gonos com ve'rtices compartilhados.
* VECT::                        Lista de pontos e linhas.
* SKEL::                        Lista de pontos e linhas, com ve'rtices compartilhados.
* SPHERE::                      Esfera
* INST::                        Insa^ncia transformada de outro objeto.
* LIST::                        Lista de outros objetos.
* TLIST::                       Colec,a~o de matrizes de transformac,a~o 4x4.
* GROUP::                       Formato obsoleto para colec,a~o de objetos.
* DISCGRP::                     Grupo deiscreto de objetos.
* COMMENT::                     Objeto comenta'rio, para informac,o~es na~o exibidas.


File: geomview-pt_BR,  Node: QUAD,  Next: MESH,  Prev: Formatos de Arquivo de Objeto,  Up: Formatos de Arquivo de Objeto

4.2.1 QUAD: colec,a~o de quadrila'teros
---------------------------------------

O sufixo convencional para um arquivo `QUAD' e' `.quad'.

   A sintaxe do arquivo e'

        [C][N][4]QUAD  -ou-  [C][N][4]POLY		   # Palavra chave
        VE'RTICE  VE'RTICE  VE'RTICE  VE'RTICE  # ve'rtices 4-D para algum N
        VE'RTICE  VE'RTICE  VE'RTICE  VE'RTICE
        ...

   A palavra chave inicial e' `[C][N][4]QUAD' ou `[C][N][4]POLY', onde
o prefixos opcionais `C' e `N' indicam que cada ve'rtice inclui cores e
retas normais respectivamente.  Isto e', esses arquivos iniciam-se com
uma das palavras

   `QUAD' `CQUAD' `NQUAD' `CNQUAD' `POLY' `CPOLY' `NPOLY' `CNPOLY'

   (mas na~o com `NCQUAD' ou `NCPOLY').  `QUAD' e `POLY' sa~o
sino^nimos; ambas as formas sa~o permitidas apenas por compatibilidade
com ChapReyes.

   Seguindo a palavra chave esta' um nu'mero arbitra'rio de grupos de
quatro ve'rtices, cada grupo descrevendo um quadrila'tero.  Veja a
sintaxe de ve'rtice acima.  O objeto termina no caractere de fim de
arquivo, ou com uma chave fechada se incorporado dentro de uma
refere^ncia de objeto (veja acima).

   Um formato de arquivo `QUAD BINARY' e' aceito; veja *note Formato
binario::.  A primeira palavra de dados bina'rios deve ser um inteiro
de 32 bits fornecendo o nu'mero de quads no objeto; seguindo esse
inteiro encontra-se uma se'rie de inteiros em ponto flutuante de 32
bits, arranjados apenas como no formato ASCII.


File: geomview-pt_BR,  Node: MESH,  Next: BBOX,  Prev: QUAD,  Up: Formatos de Arquivo de Objeto

4.2.2 MESH: Malha retangularmente conectada
-------------------------------------------

O sufixo convencional para um arquivo `MESH' e' `.mesh'.

   A sintaxe do arquivo e'

     [U][C][N][Z][4][u][v][n]MESH # Palavra chave
     [NDIM]                       # Dimensa~o do espac,o, presente
                                   # somente se nMESH
     NU NV                        # dimenso~es da grade da malha
                                  # NU*NV ve'rtices, no formato especificado
                                  # pela palavra chave inicial
     VE'RTICE(u=0,v=0)  VE'RTICE(1,0)  ... VE'RTICE(NU-1,0)
     VE'RTICE(0,1) ...    VE'RTICE(NU-1,1)
     ...
     VE'RTICE(0,NV-1) ... VE'RTICE(NU-1,NV-1)

   A palavra chave e' `[U][C][N][Z][4][u][v][n]MESH'.  Os caracteres
opcionais prefixados significam:

`U'
     Cada ve'rtice inclue uma textura de 3 para^metros de espac,o de
     componente.  As primeiras duas componentes sa~o para^metros usuais
     de textura `S' e `T' para quele ve'rtice; o terceiro pode ser
     especificado como zero.

`C'
     Cada ve'rtice (veja Vertices acima) inclui uma cor de quatro
     componentes.

`N'
     Cada ve'rtice inclui um vetor normal a` superfi'cie.

`Z'
     Dos valores dos 3 eixos coordenados (x , y e z) de ve'rtice
     somente a componente Z esta' presente; X e Y sa~o omitidos, e
     assumidos ambos como sendo iguais a`s coordenadas de malha (u,v)
     de forma que X varia de 0 .. (Nu-1), Y varia de 0 .. (Nv-1) onde
     Nu e Nv sa~o as dimensso~es de malha - veja acima.

`4'
     Ve'rtices sa~o quadridimensionais, cada ve'rtice consiste em 4
     valores em ponto flutuante.  `Z' e `4' na~o podem ambos estarem
     presentes ao mesmo tempo.

`u'
     A malha e' ajustada na direc,a~o u, de forma que o (0,v)'e'simo
     ve'rtice esta' conectado ao (NU-1,v)'e'simo para todo v.

`v'
     A malha e' ajustada na direc,a~o v, de forma que o (u,0)'esimo
     ve'rtice esta' conectado ao (u,NV-1)'e'simo para todo u.  Dessa
     forma uma malha u-ajustada ou v-ajustada e' topologicamente um
     cilindro, enquanto uma malha uv-ajustada e' um toro.

`n'
     Especifica uma malha cujos ve'rtices existem em um espac,o de
     dimensa~o mais alta.  A dimensa~o segue a palavra chave "MESH".
     Cada ve'rtice enta~o tem NDIM componentes.

   Note que a ordem dos caracteres do prefixo e' significativa; uma
malha colorida, u-ajustada e' uma `CuMESH' na~o uma `uCMESH'.

   Seguindo o cabec,alho da malha esta~o os inteiros NU e NV, as
simenso~es da malha.

   Enta~o segue-se NU*NV ve'rtices, cada um desses ve'rtices na forma
fornecida atrave's do cabec,alho.  Eles aparecem na seque^ncia
v-crescente, i.e. se chamarmos cada ve'rtice de (u,v) enta~o os
ve'rtices aparecera~o na ordem

     (0,0) (1,0) (2,0) (3,0) ...  (NU-1,0)
     (0,1) (1,1) (2,1) (3,1) ...  (NU-1,1)
     ...
     (0,Nv-1)		...  (NU-1,NV-1)

   O formato `MESH BINARY' e' aceito; Veja *note Formato binario::.  Os
valores de NU e NV sa~o inteiros de 32-bit; todos os outros valores
sa~o nu'meros em ponto flutuante de 32-bit.


File: geomview-pt_BR,  Node: BBOX,  Next: BBP and BEZ,  Prev: MESH,  Up: Formatos de Arquivo de Objeto

4.2.3 BBOX: Caixas associada simples
------------------------------------

Esse e' um objeto-brinquedo muito simples: Toma 2 ve'rtices e desenha um
(hiper-) cubo que e' a caixa associada dos dois ve'rtices.

   Sintaxe:

       BBOX
       X[0] Y[0] Z[0]
       X[1] Y[1] Z[1]

   ou

       4BBOX
       X[0] Y[0] Z[0] W[0]
       X[1] Y[1] Z[1] W[1]

   ou

       nBBOX
       NDIM # > 3
       X[0] Y[0] Z[0] W[0] ...
       X[1] Y[1] Z[1] W[1] ...

   ou

       4nBBOX
       NDIM # > 3
       D[0] X[0] Y[0] Z[0] W[0] ...
       D[0] X[1] Y[1] Z[1] W[1] ...

   Na~o existe formato bina'rio BBOX. O modificador `4' tem diferentes
significados dependendo da dimensa~o da caixa associada: `4BBOX'
significa que as 4 componentes dos ve'rtices constroem uma caixa
associada tetradimensional. Usando `4' em conjunc,a~o com `n' - `4nBBOX
NDIM' - significa que os ve'rtices especificados no arquivo possuem
NDIM+1 componentes, mas a componente no i'ndice 0 e' o divisor
homoge^neo (em oposic,a~o ao caso comum tridimensional onde o divisor
homoge^neo pode ser `w' - a terceira - componente).


File: geomview-pt_BR,  Node: BBP and BEZ,  Next: OFF,  Prev: BBOX,  Up: Formatos de Arquivo de Objeto

4.2.4 Superfi'cies de Bezier
----------------------------

O sufixo de arquivo convencional para arquivos de superfi'cie de Bezier
e' `.bbp' ou `.bez'.  O arquivo com qualquer dos dois sufixos pode
conter qualquer dos dois tipos de parte de superfi'cie de Bezier.

   Sintaxe:

       [ST]BBP -ou- [C]BEZ<NU><NV><ND>[_ST]
     			# NU, NV sa~o direc,o~es nos eixos u e v
     			# graus de polino^mios variam 1..6
     			# ND = dimensa~o: 3->3-D, 4->4-D (racional)
     			# (O sinal '<' e o sinal '>' na~o aparecem na entrada.)
     			# NU,NV,ND sa~o cada um di'gito decimal simples.
     			# a forma BBP implica NU=NV=ND=3 de forma que BBP = BEZ333.

     		# Qualquer nu'mero de partes de superfi'cie de Bezier segue o cabec,alho
     			# (NU+1)*(NV+1) pontos de controle do pedac,o da sperfi'cie de Bezier
     			# cada 3 ou 4 nu'meros em ponto flutuante conforme o cabec,alho
       VERTEX(u=0,v=0)  VERTEX(1,0) ... VERTEX(NU,0)
       VERTEX(0,1)			   ... VERTEX(NU,1)
       ...
       VERTEX(0,NV)		   ... VERTEX(NU,NV)

     			# coordenadas de textura ST se mencionado no cabec,alho
       `S'(u=0,v=0)	`T'(0,0)	`S'(0,NV) `T'(0,NV)
       `S'(NU,0)	`T'(NU,0)	`S'(NU,NV) `T'(NU,NV)

     			# nu'mero em ponto flutuante com 4 componentes no intervalo (0..1) de
     			# cores R G B A para cada canto se mencionado no cabec,alho
       `RGBA'(0,0)   `RGBA'(0,NV)
       `RGBA'(NU,0)  `RGBA'(NU,NV)

   Esses formatos representam colec,o~es de partes de superfi'cies de
Bezier, de graus maiores que 6, e com ve'rtices 3-D ou 4-D (racionais).

   A palavra chave de cabec,alho pode assumir as formas `[ST]BBP' ou
`[C]BEZ<NU><NV><ND>[_ST]' (os si'mbolos '<' e '>' na~o sa~o parte da
palara chave.

   O prefixo `ST' sobre `BBP', ou o sufixo `_ST' sobre `BEZuvn',
indicam que cada pedac,o de superfi'cie inclui quatro pares de pontos
com coordenadas em ponto flutuante no espac,o de textura, um em cada
canto do pedac,o.

   O prefixo `C' sobre `BEZuvn' indica um pedac,o colorido, incluindo
quatro conjuntos de quatro componentes com os nu'meros que especificam
as cores em ponto flutuante (vermelho, verde, azul, e alfa) no
intervalo 0..1, uma cor para cada canto.

   NU e NV, cada um e' um simples di'gito no intervalo 1..6, sa~o os
graus do polino^mio do pedac,o nas direc,o~es u e v respectivamente.

   ND e' o nu'mero de componentes no ve'rtice de cada pedac,o, e deve
ser ou `3' para 3-D ou `4' para coordenadas homoge^neas, isto e',
pedac,os racionais.

   Pedac,os `BBP' sa~o pedac,os bicu'bicos com ve'rtices
tridimensionais, de forma que `BBP' = `BEZ333' e `STBBP' = `BEZ333_ST'.

   Qualquer nu'mero de pedac,os segue o cabec,alho.  Cada pedac,o
compreende uma se'rie de ve'rtices do pedac,o, seguido por coordenadas
opcionais de textura (s,t), seguidas por cores opcionais no formato
(r,g,b,a).

   Cada pedac,o tem (NU+1)*(NV+1) ve'rtices na ordem v-crescente, de
forma que se designarmos um ve'rtice atrave's de seus i'ndices (u, v)
de controle de ponto a ordem e'
          (0,0) (1,0) (2,0) ...  (NU,0)
          (0,1) (1,1) (2,1) ...  (NU,1)
          ...
          (0,NV)            ...  (NU,NV)
   com cada ve'rtice contendo ou 3 ou 4 nu'meros em ponto flutuantes
como especificado pelo cabec,alho.

   Se o cabec,alho chama por coordenadas ST, quatro pares de nu'meros em
ponto flutuante seguem: o espac,o de coordenadas de textura para (0,0),
(NU,0), (0,NV), e os cantos (NU,NV) do pedac,o, respectivamente.

   Se o cabec,alho chama por cores, segue quatro grupos de quatro
componentes (vermelho, verde, azul, alfa) d cores em ponto flutuante,
um para cada canto do pedac,o.

   A se'rie de pedac,os termina em um caractere de fim de arquivo, ou
com uma chave fechada se incorporado em uma refere^ncia de objeto.


File: geomview-pt_BR,  Node: OFF,  Next: VECT,  Prev: BBP and BEZ,  Up: Formatos de Arquivo de Objeto

4.2.5 Arquivos do Tipo OFF
--------------------------

O sufixo convencional para arquivos `OFF' e' `.off'.

   Sintaxe:

     [ST][C][N][4][n]OFF	# Palavra chave do cabec,alho
     [NDIM]		# Dimensa~o do espac,o dos ve'rtices, presente somente se nOFF
     			# estiver tambe'm presente
     NVE'RTICES  NFACES  NARESTAS   # NArestas na~o e' usado nem checado

     X[0]  Y[0]  Z[0]	# Ve'rtices, possivelmente com normais,
     			# cores, e/ou coordenadas de textura, nessa ordem,
     			# se os prefixo `N', `C', `ST'
     			# estiverem presentes.
     			# Se 4OFF, cada ve'rtice possui 4 componentes,
     			# incluindo uma componente final homoge^nea.
     			# Se nOFF, cada ve'rtice possui NDIM componentes.
     			# Se 4nOFF, cada ve'rtice possui NDIM+1 componentes.
     ...
     X[NVE'RTICES-1]  Y[NVE'RTICES-1]  Z[NVE'RTICES-1]

         			# Faces
         			# NV = # ve'rtices na referida face
         			# V[0] ... V[NV-1]: i'ndices dos ve'rtices
         			#		no intervalo 0..NVE'RTICES-1
     NV  V[0] V[1] ... V[NV-1]  COLORSPEC
     ...
         			# COLORSPEC colar conti'nuo V[NV-1]
         			# ate' o aparecer um caractere de fim de linha; pode ser de 0 a 4
         			# nu'meros
         			# nenhum: padra~o
         			# inteiro: i'ndice do mapa de cores
         			# 3 ou 4 inteiros: valores RGB[A] no intervalo 0..255
     			# 3 ou 4 nu'meros em ponto flutuante: valores RGB[A] no intervalo 0..1

   Arquivos `OFF' (nome  para "object file format" formato de arquivo
de objeto) representa colec,o~es de poli'gonos planos com ve'rtices
possivelmente compartilhados, um caminho conveniente para descrever
poliedros.  Os poli'gonos podem ser co^ncavos mas na~o existe suporte
para poli'gonos contendo buracos.

   Um arquivo `OFF' pode comec,ar com a palavra chave `OFF'; isso e'
recomendado mas tambe'm e' opcional, muitos arquivos existentes
precisam dessa palavra chave.

   Tre^s inteiros ASCII seguem a palavra chave `OFF': NVE'RTICES,
NFACES, e NARESTAS.  Esses sa~o o nu'mero de ve'rtices, faces, e
arestas, respectivamente.  Atualmente o software na~o utiliza nem
verifica NARESTAS; ele na~o precisa ser correto mas deve estar presente.

   As coordenadas do ve'rtice seguem: dimensa~o * NVE'RTICES valores em
ponto flutuante.  Esses valores em ponto flutuante esta~o
implicitamente numerados de 0 a NVE'RTICES-1.  A dimensa~o e' ou 3 (o
padra~o) ou 4 (especificado pelo caractere chave `4' diretamente antes
da palavra chave `OFF').

   Seguindo esses acima citados esta~o as descric,o~es das faces,
tipicamente escritos com uma linha por face.  Cada linha tem a forma
     N  VERT1 VERT2 ... VERTN  [COR]
   Aqui N e' o nu'mero de ve'rtices sobre a considerada face, e VERT1 a
VERTN sa~o i'ndices dentro da lista de ve'rtices (no intervalo
0..NVE'RTICES-1).

   O modificador opcional COR no final da linha acima pode tomar
va'rias formas.  Caracteres de fim de linha sa~o significativos nesse
ponto: a descric,a~o COR inicia-se apo's VERTN e termina com o
caractere de fim de linha (ou pro'ximo caractere cerquilha #
representativo de comenta'rio).  Uma COR pode ser:

ause^ncia de caractere
     a cor padra~o

um inteiro
     i'ndice dentro "do" mapa de cores; veja abaixo

tre^s ou quatro inteiros
     valores de RGB e possivelmente alfa no intervalo 0..255

tre^s ou quatro nu'meros em ponto flutuante
     valores RGB e possivelmente alfa no intervalo 0..1

   Para o caso de um inteiro, o mapa de cores e' lido diretamente do
arquivo `cmap.fmap' em sua forma atual no direto'rio `data' do
Geomview.  Algum melhor mecanismo para fornecer um mapa de cor sera'
fornecido provavelmente algum dia.

   O significado de "cor padra~o" varia.  Se nenhuma face do objeto tem
uma cor, tudo recebe como heranc,a a cor material padra~o do ambiente.
Se alguma mas na~o todas as faces possuem cores, o padra~o e' cinza
(R,G,B,A=.666).

   Um formato `[ST][C][N][n]OFF BINARY' e' aceito; veja *note Formato
binario::.  Esse formato assemelha-se ao formato ASCII em quase tudo
que voce^ poderia esperar, com inteiros de 32-bit para todos os
contadores e i'ndices de ve'rtice e nu'meros em ponto flutuante de
32-bit para posic,o~es de ve'rtice (e coordenadas de textura ou cores
de ve'rtice ou retas normais se algum dos formatos
`COFF'/`NOFF'/`CNOFF'/`STCNOFF'/etc. estiver presente).

   Excec,a~o: cada um dos i'ndices de face do ve'rtice sa~o seguidos
por um inteiro indicando quantas componentes de cor o acompanham.
Componentes de cor de face devem ser nu'meros em ponto flutuante, na~o
valores inteiros.  Dessa forma uma face triangular  pouco colorida pode
ser representada como

     int int int int int
     3   17   5   9   0

   enquanto a mesma face colorida com vermelho pode ser

     int int int int int float float float float
      3  17   5   9   4   1.0   0.0   0.0   1.0


File: geomview-pt_BR,  Node: VECT,  Next: SKEL,  Prev: OFF,  Up: Formatos de Arquivo de Objeto

4.2.6 Arquivos do Tipo VECT
---------------------------

O sufixo convencional para arquivos `VECT' e' `.vect'.

   Sintaxe:

     [4]VECT
     NLINHASPOLIGONAIS  NVE'RTICES  NCORES

     NV[0] ... NV[NLINHASPOLIGONAIS-1]     # nu'mero de ve'rtices
                                                # em cada linha poligonal

     NC[0] ... NC[NLINHASPOLIGONAIS-1]     # nu'mero de cores fornecido
                                                # em cada linha poligonal

     VERT[0] ... VERT[NVERTICES-1]  # Todos os ve'rtices
                                                # (3*NVertices nu'meros em
                                                # ponto flutuante)

     COLOR[0] ... COLOR[NCORES-1]  # Todas as cores
                                                # (4*NCores nu'meros em ponto
                                                # flutuante, RGBA)

   Objetos do tipo `VECT' representam listas de linhas poligonais
(seque^ncia de caracteres que representam segmentos de reta,
possivelmente fechados).  Uma linha poligonal degenerada pode ser usada
para representar um ponto.

   Um arquivo `VECT' inicia-se com a palavra chave `VECT' ou com `4VECT'
e tre^s inteiros: NLINHAS, NVE'RTICES, e NCORES.  Aqui NLINHAS e' o
numero de linhas poligonais no arquivo, NVE'RTICES o nu'mero total de
vertices ve'rtices, e NCORES o nu'mero de cores como explanado abaixo.

   A seguir vem NLINHAS que sa~o inteiros de 16-bit

                  NV[0] NV[1] NV[2] ... NV[NLINHAS-1]

   fornecendo o nu'mero de ve'rtices em cada linha poligonal.  Um
nu'mero negativo indica uma linha poligonal fechada; 1 denota ponto
composto por um pixel simples.  O somato'rio (dos valores absolutos) de
NV[I] deve ser igual a NVE'RTICES.

   A seguir vem NLINHAS que sa~o formadas por inteiros de 16-bit NC[I]:
o nu'mero de cores em cada linha poligonal. Normalmente um dos tre^s
valores abaixo:

0
     Nenhuma cor e' especificada para esta linha poligonal.  Seu
     desenho na mesma cor que a linha poligonal anterior.

1
     Uma cor simples e' especificada.  A linha poligonal completa e'
     desenhada nessa cor.

abs(NV[I])
     Cada ve'rtice tem uma cor.  Ou cada segmento e' desenhado na
     correspondente cor, ou as cores sa~o linearmente interpoladas ao
     longo dos segmentos de reta, dependendo da implementac,a~o.

   A seguir vem NVE'RTICES grupos de 3 ou 4 nu'meros em ponto
flutuante: as coordenadas de todos os ve'rtices.  Se a palavra chave
for 4VECT enta~o existira~o 4 valores por ve'rtice.  O primeiro grupo
abs(NV[0]) forma a primeira linha poligonal, o grupo seguinte
abs(NV[1]) forma a segunda e assim por diante.

   Finalmente NCORES grupos de 4 nu'meros em ponto flutuante fornecendo
valores de vermelho, verde, azul e alfa (opacidade).  O primeiro grupo
NC[0] aplica-se a` primeira linha poligonal, e assim por diante.

   Um formato VECT BINARY e' aceito; veja *note Formato binario::.  O
formato bina'rio segue exatamente o formato ASCII, com inteiros de
32-bit Big-Endian onde aparecem os nu'meros inteiros comuns, e com
inteiros de 16-bit Big-Endian onde aparecem inteiros de 16-bit;
nu'meros em ponto flutuante de 32-bit Big-Endian onde aparecem os
valores reais.  NOTA REALMENTE GRANDE: Os contadores de ve'rtice NV[I]
e os contadores de cor NC[I] sa~o inteiros de 16-bit Big-Endian.


File: geomview-pt_BR,  Node: SKEL,  Next: SPHERE,  Prev: VECT,  Up: Formatos de Arquivo de Objeto

4.2.7 Arquivos do Tipo SKEL
---------------------------

Arquivos do Tipo `SKEL' representam colec,o~es de pontos e linhas
poligonais, com ve'rtices compartilhados.  O sufixo convencional para
arquivos `SKEL' e' `.skel'.

   Sintaxe:

     [C][4][n]SKEL
     [NDIM]                    # Dimensa~o dos ve'rtices, presente somente
     				    # se nSKEL tambe'm estiver presente
     NVE'RTICES  NLINHASPOLIGONAIS

     X[0]  Y[0]  Z[0]  # Ve'rtices
     				    # se 4SKEL, cada ve'rtice tera' 4 componentes
     				    # se nSKEL, each ve'rtice tera' NDim componentes
                                         # se C[4][n]SKEL coordenadas de
                                         # ve'rtice sa~o seguidas por uma
                                         # especificac,a~o de cor RGBA
     ...
     X[NVE'RTICES-1]  Y[NVE'RTICES-1]  Z[NVE'RTICES-1]

                             # linhas poligonais
                             # NV = ve'rtices sobre essa linha poligonal
                             # (1 = ponto)
                             # V[0] ... V[NV-1]: i'ndices de ve'rtice
                             #               no intervalo 0..NVE'RTICES-1
     NV  V[0] V[1] ... V[NV-1]  [COLORSPEC]
     ...
                             # COLORSPEC continua adiante de V[NV-1]
                             # ate'm encontrar um fim de linha; pode ser
                             # vazia, ou 3 ou 4 nu'meros.
                             # vazia: cor padra~o
     			# 3 ou 4 nu'meros em ponto flutuante: valores RGB[A] no intervalo 0..1

   A sintaxe e' semelhante a` sintaxe dos arquivos `OFF', com uma
tabela de ve'rtices seguidos de uma seque^ncia de descric,o~es de
linhas poligonais, cada descric,a~o referindo-se a ve'rtices atrave's
de i'ndices na tabela.  Cada linha poligonal tem uma cor opcional.

   Para objetos `nSKEL', cada ve'rtice tem NDIM componentes.  Para
objetos `4nSKEL', cada ve'rtice tem NDIM+1 componentes; a componente
final e' o divisor homoge^neo.

   Um formato [4][N]SKEL BINARY e' aceito; veja *note Formato binario::.
Esse formato assemelha-se ao formato ASCII na maioria das formas que
voce^ pode esperar, com inteiros de 32-bit para todos os contadores e
i'ndices de ve'rtice e nu'meros em ponto flutuante de 32-bit para
posic,o~es de ve'rtice.

   Excec,a~o: cada i'ndice do ve'rtice de linhas poligonais e' seguido
de um inteiro indicando quantas componentes de cor o acompanham.
Componentes de cor de linhas poligonais devem ser inteiros em ponto
flutuante, na~o valores inteiros.  Dessa forma uma pouco colorida linha
poligonal com 3 ve'rtices pode ser representada como

     int int int int int
     3   17   5   9   0

   enquanto a mesma linha poligonal colorida em vermelho pode ser

     int int int int int float float float float
      3  17   5   9   4   1.0   0.0   0.0   1.0


File: geomview-pt_BR,  Node: SPHERE,  Next: INST,  Prev: SKEL,  Up: Formatos de Arquivo de Objeto

4.2.8 SPHERE Files
------------------

O sufixo convencional para arquivos `SPHERE' e' `.sph'.

     [ST][E|H|S]SPHERE # Palavra chave
     # coordenadas de textura geradas automaticamente, somente permitido
     # com objetos _ST_SPHERE [SINUSOIDAL|CYLINDRICAL|RECTANGULAR|
     # STEREOGRAPHIC|ONEFACE]
     # os pro'ximos quatro campos sa~o requeridos
     RADIUS
     XCENTER YCENTER ZCENTER

   A palavra chave e' `[ST][E|H|S]SPHERE'.  Os caracteres prefixados
opcionais significam:

`ST'
     A esfera e' desenhada com coordenadas de textura geradas
     automaticamente. Veja abaixo.

`E'
     Assume-se que a esfera encontra-se dentro do espac,o Euclidiano.

`H'
     Assume-se que a esfera encontra-se dentro de um espac,o
     Hiperbo'lico. Veja *note Geometrias Nao-Euclidianas::.

`S'
     Assume-se que a esfera encontra-se dentro de um espac,o esfe'rico.
     Veja *note Geometrias Nao-Euclidianas::.

   Objetos do tipo esfera sa~o desenhados usando malhas que sa~o
retangulares em um sistema de coordenadas polares, com o plano
equatorial paralelo ao plano `x,y'. Sua suavidade superficial, e o
tempo gasto para desenha'-la, depende da escolha dos cortes quadrados,
10x10 por padra~o.  Para Geomview, o painel de apare^ncia, o comando de
teclado `<N>ad', ou um atributo de apare^ncia `dice nu nv' escolhe isso.

   Coordenadas de textura sa~o geradas para objetos `STSPHERE'; a
palavra chave seguindo a palavra chave inicial `STSPHERE' define o
caminho para fazer isso. A palavra chave que segue a papavra chave
inicial segue as convenc,o~es do script perl `mktxmesh' que acompanha o
direto'rio _Orrery_ na a'rvore de direto'rios instalados que acompanha
o Geomview.

SINUSOIDAL
     projec,a~o sinusoidal de a'rea equivalente

CYLINDRICAL
     projec,a~o cili'drica: S e' a longitude, T e' a latitude

RECTANGULAR
     projec,a~o retangular: S e' a longitude, T e'  `sin(latitude)'
     (i.e. a coordenada `z' no sistema de coordenadas da esfera)

STEREOGRAPHIC
     projec,a~o estereogra'fica a partir do po'lo sul (`z=-1')

ONEFACE
     visa~o ortogra'fica extendida do hemisfe'rio `+y' sobre ambos,
     espelhando


File: geomview-pt_BR,  Node: INST,  Next: LIST,  Prev: SPHERE,  Up: Formatos de Arquivo de Objeto

4.2.9 Arquivos do Tipo INST
---------------------------

O sufixo convencional para um arquivo `INST' e' `.inst'.

   Na~o existe formato INST BINARY.

   Um `INST' aplica uma transformac,a~o 4x4 (ou (N+1)x(N+1) no contexto
de ND-viewing) a outro objeto OOGL.  Um arquivo do tipo `INST'
inicia-se com `INST' seguido de as sec,o~es mostradas adiante que podem
vir em qualquer ordem:
     geom OOGL-OBJECT
   especifica o objeto OOGL a ser instanciado.  Veja *note
Referencias::, para a sintaxe de um OOGL-OBJECT.   palavra chave `unit'
e' um sino^nimo para `geom'.
     transform   ["{"] `transformac,a~o 4x4' ["}"]
   especifica uma matriz de transformac,a~o simples.  Ou a matriz pode
aparecer literalmente como 16 nu'meros, ou a matriz pode aparecer como
uma refere^ncia a um objeto "transform", i.e.
         "<" arquivo-contendo-matriz-4x4
   ou
         ":" si'mbolo-representando-transformac,a~o-de-objeto
   Outra forma de especificar a transformac,a~o e'
     transforms
         OBJETO-OOGL
   O OBJETO-OOGL deve ser um objeto `TLIST' (lista de
transformac,o~es), ou uma `LIST' cujos membros dessa lista sa~o objetos
`TLIST' mais recentes.  Com efeito, a palavra chave `transforms' toma
uma colec,a~o de matrizes 4x4 e replica o objeto `geom', fazendo uma
co'pia para cada matriz 4x4.

   Se nem a palavra chave `transform' nem a palavra chave `transforms'
aparecerem, ne-nhuma transformac,a~o e' aplicada (atualmente a
identidade e' aplicada).  Voce^ pode usar isso para, e.g., empacotar
uma apare^ncia em torno de um objeto externo fornecido, atrave's de uma
LIST de membros simples pode-se fazer isso mais eficientemente.

   Veja *note Matrizes de transformacao::, para o formato de matriz.

   A co'pia de um objeto geome'trico simples por meio de um objeto
`TLIST' (veja `transforms' acima) pode ser u'til para transformar
coordenadas de textura atrave's de outra lista de transformac,o~es;
essa lista pode ser especificada por
     txtransforms
         OBJETO-TLIST
   O nu'mero de transoformac,o~es de textura deve coincidir com o
nu'mero de transformac,o~es geome'tricas. O objeto `SPHERE' (Veja *note
Sphere Objects: SPHERE.) utiliza essa te'cnica para gerar um esfera
completamente texturizada fora de alguma frac,a~o de uma esfera
(usualmente um octante).

   Uma transformac,a~o (N+1)-dimensional pode ser especificada por

     ntransform ["{"] N+1 N+1 `(N+1)x(N+1) floats' ["}"]
   A linha acima fornece uma matriz de transformac,a~o N+1-dimensional.
Ou a matriz pode aparecer literalmente como (N+1)x(N+1) nu'meros, ou
pode existir uma refere^ncia a um objeto `ntransform', i.e.
         "<" arquivo-contendo-matriz-(N+1)x(N+1)
   ou
         ":" si'mbolo-representando-objeto-ntransform

   Veja *note Matrizes de transformacao ND::, para o formato de matriz.

   Mais dois campos INST sa~o aceitos: `location' e `origin'.

   Note que `location' bem como `origin' sa~o ignorados se esse objeto
`INST' realiza uma `ntransform'. Tambe'm, se a visualizac,a~o ND esta'
ativada (comando `ND-axes', veja *note GCL::) enta~o objetos `INST' com
`origin' diferente de `local' na~o ira~o ser desenhados, embora o
material `location' possa trabalhar (ou na~o).

     location [global ou camera ou ndc ou screen ou local]
   Normalmente um INST especifica uma posic,a~o relativa a seu objeto
pai; o campo `location' permite colocar um objeto em qualquer lugar.
   * `location global' anexa o objeto ao ambiente do sistema de
     coordenadas global (tambe'm conhecido como "universe") - o mesmo
     dos objetos mundo do Geomview, das geometrias alieni'genas, e
     ca^meras sa~o colocados.

   * `location camera' coloca o pai do objeto como sendo uma ca^mera.
     (Dessa forma se houverem multiplas visualizac,o~es, essas
     visualizac,o~es podem aparecer em uma diferente posic,a~o espacial
     em cada visualizac,a~o.)  O centro de visa~o da camera esta' em
     volta da parte negativa do seu eixo z; X positivo esta' a` direita
     e adiante, Y positivo esta' acima e adiante.  Normalmente as
     unidades do espac,o da ca^mera sa~o as mesmas das coordenadas
     globais.  Quando uma ca^mera e' colocada de volta a` sua posic,a~o
     inicial, a ori'gem global esta' localizada em (0,0,-3.0).

   * `location ndc' coloca os parentes do objeto no cubo unita'rio
     normalizado no qual a projec,a~o da ca^mera (perspectiva ou
     ortogra'fica) mapeia o objeto mundo visi'vel.  X, Y, e Z esta~o no
     intervalo de -1 a +1, com Z = -1 estando mais pro'ximo e Z = +1
     adiante do plano de corte, e X e Y nas direc,o~es a` direita e
     adiante e acima e adiante respectivamente.  Dessa forma alguma
     coisa como
          INST  transform  1 0 0 0  0 1 0 0  0 0 1 0  -.9 -.9 -.999 1
                location ndc
                geom < label.vect
     cola `label.vect' dentro do canto infeiror esquerdo de cada janela,
     e em frente de tudo mais que estiver pro'ximo, assumindo o
     conteu'do `label.vect' como localizado no quadrante positivo do
     plano XY.  E' tentado usar -1 em lugar de como a componente Z da
     posic,a~o, mas o -1 pode colocar o objeto apenas nas proximidades
     em lugar de muito perto do plano de corte e tornar o objeto
     (parcialmente) invisi'vel, devido a algum erro de ca'lculo com
     nu'meros em ponto flutuante.

   * `location screen' coloca o objeto objeto em coordenadas de tela.
     O intervalo de Z e' ainda de -1 a +1 como para coordenadas ndc; X
     e Y sa~o medidos em pixels, e a posic,a~o de (0,0) localiza-se no
     canto _inferior esquerdo_ da janela, avanc,ado para a direita e
     adiante e para cima e adiante.

   `location local' e' o padra~o; o objeto esta' posicionado
relativametne a seus genitores.

     origin [global ou camera ou ndc ou screen ou local] x y z
   O campo `origin' reposiciona o conteu'do da INST de forma que o
local da ori'gem seja o ponto especificado do sistema de coordenadas
fornecido.  A menos que `location' seja especificado, essa opc,a~o na~o
muda a orientac,a~o, somente a escolha da ori'gem.  Ambas as opc,o~es
`location' e `origin' podem ser usadas juntas.

   Enta~o por exemplo
     { INST
       location screen
       origin ndc 0 0 -.99
       geom { < xyz.vect }
       transform { 100 0 0 0  0 100 0 0  0 0 -.009 0   0 0 0 1 }
     }

   coloca a ori'gem de xyz.vect no centro da janela, apenas
transformando o plano de corte mais pro'ximo.  O comprimento da unidade
das arestas X e Y sa~o ajustados proporcionalmente para ter o
comprimento de apenas 100 unidades de tela - pixels - ,
independentemente do tamanho da janela.

* Menu:

* Exemplos INST::               alguns exemplos de arquivos do tipo `INST'.


File: geomview-pt_BR,  Node: Exemplos INST,  Prev: INST,  Up: INST

4.2.9.1 Exemplos INST
.....................

Aqui esta~o alguns exemplos de arquivos `INST'

     INST
          unit < xyz.vect
          transform {
             1 0 0 0
             0 1 0 0
             0 0 1 0
             1 3 0 1
          }

     { appearance { +edge  material { edgecolor 1 1 0 } }
         INST geom < mysurface.quad }

     {INST transform {: T} geom {<dodec.off}}

     { INST
          transforms
              { LIST
          	{ < some-matrices.prj }
          	{ < others.prj }
          	{ TLIST <still more of them> }

              }
          geom
              { # material copiado a partir de todas as matrizes acima
          	...
              }
     }

   O exemplo adiante assemelham-se ao exemplo de `origin' na sec,a~o
acima, mas fazem com que as arestas X e Y sejam 1/4 do tamanho da
janela (1/4, na~o 1/2, uma vez que o intervalo das coordenadas ndc de X
e Y estejam de -1 a +1).
     { INST
       location ndc
       geom { < xyz.vect }
       transform { .5 0 0 0  0 .5 0 0  0 0 -.009 0   0 0 -.99 1 }
     }


File: geomview-pt_BR,  Node: LIST,  Next: TLIST,  Prev: INST,  Up: Formatos de Arquivo de Objeto

4.2.10 Arquivos do Tipo LIST
----------------------------

O sufixo convencional para um arquivo `LIST' e' `.list'.

   Uma lista de objetos OOGL

   Sintaxe:

     LIST
         OOGL-OBJECT
         OOGL-OBJECT
         ...

   Note que na~o existe separac,a~o expli'cita entre os objetos oogl,
de forma que eles podem ser colocados entre chaves ({ }) por questo~es
de clareza.  Da mesma forma na~o existe um marcador expli'cito para o
final da lista; a menos que o arquivo aparec,a sozinho em um arquivo de
disco, a construc,a~o completa pode tambe'm ser empacotada entre
chaves, como em:

        { LIST { QUAD ... } { < xyz.quad } }

   Uma `LIST' vazia, i.e. `{ LIST }', e' va'lida, e e' o caminho mais
fa'cil para criar um objeto vazio.  Por exemplo, para remover uma
definic,a~o de si'mbolo voce^ pode escrever

        { define algumsi'mbolo  { LIST } }


File: geomview-pt_BR,  Node: TLIST,  Next: GROUP,  Prev: LIST,  Up: Formatos de Arquivo de Objeto

4.2.11 Arquivos do Tipo TLIST
-----------------------------

O sufixo convencional para um arquivo `TLIST' e' `.grp' ("grupo") ou
`.prj' (matrizes "projetivas").

   Colec,o~es de matrizes 4x4, usadas na sec,a~o `transforms' de/e
objeto `INST'.

   Sintaxe:

     TLIST			# palavra chave
     <matriz 4x4 (16 nu'meros em ponto flutuante)>
     ...				# qualquer nu'mero de matrizes 4x4
     transform {             # refere^ncia a um objeto de transformac,a~o
     <objeto de transformac,a~o (pode ser um manipulador)>
     }
     tlist {                 # TLIST aninhada
     <objeto TLIST OOGL (pode ser um manipulador)>
     }

   Objetos `TLIST' sa~o usados somente dentro de cla'usulas
`transforms' de um objeto `INST'.  Objetos `TLIST' fazem com que os
objetos `geom' `INST's sejam instanciados uma vez sob cada uma das
transformac,o~es na `TLIST'.  O efeito e' como aquele de um `LIST' de
`INST's cada uma com uma transformac,a~o simples, e todas as
transformac,o~es referindo-se ao mesmo objeto, mas e' mais eficiente.

   `TLIST's podem ser aninhadas: efetivamente isto significa que todas
as transformac,o~es em cada objeto `TLIST' aninhado sa~o multiplicadas
(a` esquerda) atrave's das transformac,o~es no objeto `TLIST' mais
externo.

   Esteja informado de que uma `TLIST' e' um tipo de geom, distinto de
um objeto `transform'.  Alguns contextos esperam um geom, alguns
contextos esperam um `transform'.  Por exemplo em
     INST transform { : MEUT } geom { ... }
   MEUT deve ser um objeto transform, que pode ter sido criado com a GCL
     (read transform { define meuT 1 0 0 1 ... })
   enquanto em
       INST transforms { : MEUSTS } geom { ... }
       ou
       INST transforms { LIST {: MEUSTS} {< more.prj} } geom { ... }
   MEUSTS deve ser um objeto geom, definido e.g. com
       (read geometry { define MEUSTS { TLIST 1 0 0 1 ... } })

   O formato `TLIST BINARY' e' aceito.  Dados bina'rios iniciam-se com
um inteiro de 32-bit fornecendo o nu'meros de transformac,o~es, seguido
por aquele nu'mero de matrizes 4x4 no formato em nu'mero de ponto
flutuante de 32-bit.  A ordenac,a~o dos elementos da matriz e' a mesma
do formato ASCII.


File: geomview-pt_BR,  Node: GROUP,  Next: DISCGRP,  Prev: TLIST,  Up: Formatos de Arquivo de Objeto

4.2.12 Arquivos do Tipo GROUP
-----------------------------

Esse formato e' obsoleto, mas ainda e' aceito.  It combined the
functions of `INST' and `TLIST', taking a series of transformations and
a single Geom (`unit') objeto, and replicating the objeto under each
transformation.

     GROUP ... < matrices > ... unit { OOGL-OBJECT }

   is still accepted and effectively translated into

     INST
     	transforms { TLIST ... <matrices> ... }
     	unit { OOGL-OBJECT }


File: geomview-pt_BR,  Node: DISCGRP,  Next: COMMENT,  Prev: GROUP,  Up: Formatos de Arquivo de Objeto

4.2.13 Arquivos do Tipo DISCGRP
-------------------------------

Esse formato e' para grupos discretos, tais como aparecem na teoria dos
coletores (manifolds) ou em modelos de simetria.  Esse formato tem sua
pro'pria pa'gina de manual.  Veja discgrp(5).


File: geomview-pt_BR,  Node: COMMENT,  Prev: DISCGRP,  Up: Formatos de Arquivo de Objeto

4.2.14 Objetos do Tipo COMMENT
------------------------------

O objeto COMMENT e' um mecanismo para codificar dados arbitra'rios
dentro de um objeto OOGL. O objeto COMMENT pode ser usado para manter
trilhas de dados ou para passagem de dados de retorno e passar dados
adiante entre mo'dulos externos.

   Sintaxe:

     COMMENT                 # palavra chave

     NOME TIPO   # nome individual e especificador de tipo
     { ... }             # dados arbitra'rios

   Os dados, que devem ser contidos dentro de chaves, podem incluir
qualquer coisa exceto chaves na~o balanceadas (aberta mas sem o
fechamento correspondente ou fechada mas sem a abertura
correspondente).  O campo TIPO pode ser usado para identificar dados de
interesse de um programa em particular apesar de nomear convenc,o~es.

   Objetos `COMMENT' sa~o intendidos como estando associados com outros
objetos apesar da inclusa~o em um objeto `LIST'. (Veja *note LIST::.)
A sintaxe da cerquilha "#" OOGL de comenta'rio na~o e' suficiente para
troca de dados uma vez que esses comenta'rios sa~o removidos quando um
objeto OOGL e' lido dentro do Geomview.  O objeto `COMMENT' e'
preservado quando chamado dentro do Geomview e e' mantido intacto na
sai'da.

   Aqui esta' um exemplo associando uma localizac,a~o na internet a uma
pec,a de geometria:

     { LIST
      { < Tetrahedron}
      {COMMENT GCHomepage HREF { http://www.geomview.org/ }}
     }

   Um formato de `COMMENT' bina'rio e' aceito. Esse formato bina'rio de
comenta'rio na~o e' consistente com outros formatos bina'rios OOGL.
Veja *note Formato binario::. O `nome' e o `tipo' sa~o seguidos por

     N BYTE1 BYTE2 ... BYTEN

   Em lugar de dados contidos dentro de chaves.


File: geomview-pt_BR,  Node: Objetos nao-geometricos,  Prev: Formatos de Arquivo de Objeto,  Up: Formatos dos Arquivos da OOGL

4.3 Objetos nao-geometricos
===========================

A sintaxe desses objetos e' fornecida na forma usada em *note
Referencias::, onde itens "entre aspas duplas" devem aparecer
literalmente mas sem aspas duplas, itens entre colche^tes ([ ]) sa~o
opcionais, e a barra vertical "|" separa escolhas alternativas.

* Menu:

* Objetos de aparencia::        Objetos de apare^ncia.
* image objects::               Objetos de imagem.
* transform objects::           Matrizes de transformac,a~o.
* ntransform objects::          Matrizes de Transformac,a~o N-dimensional.
* Objeto camera::               Ca^meras.
* window objects::              Janelas.


File: geomview-pt_BR,  Node: Objetos de aparencia,  Next: image objects,  Prev: Objetos nao-geometricos,  Up: Objetos nao-geometricos

4.3.1 Objetos de aparencia
--------------------------

Apare^ncias sa~o objetos OOGL com caracteri'sticas pro'prias, que
simplesmente significam que e' possi'vel fornecer a eles nomes
simbo'licos (Veja *note Referencias::). Existem outras sec,o~es
manuseado detalhes de apare^ncia. Veja *note Aparencias::.


File: geomview-pt_BR,  Node: image objects,  Next: transform objects,  Prev: Objetos de aparencia,  Up: Objetos nao-geometricos

4.3.2 Objetos de imagem
-----------------------

Objetos de imagem sa~o usados para especificar dados de pixmap ou para
texturas (Veja *note Mapeamento de Textura::), ou para imagens de fundo
de ca^meras (Veja *note Objetos de camera: camera.).

   Ao mesmo tempo em que imagens sa~o escritas elas sa~o tambe'm
comprimidas de 1 a 4 canais, um canal fornece um nu'mero simples no
intervalo que vai de 0 a `maxval' para cada ponto de imagem (pixel); e
`maxval' e' colocado em 255. A interpretac,a~o dos dados de imagem
dependente do nu'mero de canais e' como segue:

#Canais        No. do Canal   Interpretac,a~o
-------------------------------------------------------------------------- 
1              1              escala de cinza ou dados de lumina^ncia
2              1              escala de cinza ou dados de lumina^ncia
` '            2              canal alfa (0: transparente, `maxval':
                              opaco)
3              1              canal vermelho
`'             2              canal verde
`'             3              canal azul
4              1              canal vermelho
`'             2              canal verde
`'             3              canal azul
`'             4              canal alfa (0: transparente, `maxval':
                              opaco)

   Dados de imagem podem ser especificados inline (embutidos dentro do
fluxo de dados atual) ou via refere^ncias de arquivos; em ambos os
casos os dados sa~o lidos e interpretados ao mesmo tempo que o objeto
de imagem e' passado. _Essa forma e' diferente da antiga (e
desatualizada) forma de especificac,a~o de textura de imagem, onde os
dados de imagem em uma mi'dia podem eventualmente serem re-lidos pelo
Geomview_.

   A sintaxe geral de objetos de imagem e' como segue:
     <image> ::=
       [ "{" ]             (abertura de chave, geralmente precisam informar
                            o fim do objeto de forma clara.)
       [ "image" ]          (palavra chave opcional; desnecessa'ria se o tipo
                            e' determinado pelo contexto, o que
                            usualmente acontece.)
       [ "define" <nome> ]
                            (define uma imagem chamada <nome>, escolhendo
                            seus valores a partir do material adiante)
       |
           "<" <nomedearquivo>   (significando: leia a imagem de contida
                            em nomedearquivo)
       |
           ":" <nome>       (significando: use a varia'vel NOME,
                            definida em algum lugar; se a varia'vel na~o
                            for definida em algum lugar a imagem
                            e' tida como vazia)
       |
                            (material atual de definic,a~o de imagem; dados
                            da imagem obrigato'riamente ve^m por ultimo,
                            apo's a definic,a~o da largura e da altura
                            e do nu'mero de canais)

           "width"          (largura da imagem, detectado automaticamente
                            a partir dos dados da imagem se possi'vel)

           "height"         (altura da imagem, detectado automaticamente
                            a partir dos dados da imagem se possi'vel)

           "channels"       (nu'mero de canais, detectado automaticamente
                            a partir dos dados da imagem e a partir das
                            especificac,o~es `data' descrita
                            adiante, se possi'vel)

           "maxval"         (na~o suportado, obrigatoriamente deve ser `255' se
                            especificado)

           "data MASCDEST [FILTER] [{] < NOMEDOARQUIVO [}]"
           "data MASCDEST [FILTER] TAMAN_IMAGEM [{][\n]DADOS_LIT_IMAGEM[}]"
                            (dados de imagem ou externos ou embutidos,
                            veja abaixo para uma descric,a~o detalhada do
                            significado de _MASCDEST_ e _FILTER_. Uma imagem
                            pode -e tem, em geral- multiplas sec,o~es de
                            dados.)

       [ "}" ]             (fechamento correspondente da chave)

   Detalhes relativos a` especificac,a~o dos dados de uma imagem:

`MASCDEST'
     Esse e' um campo-bit descrevendo onde os dados da imagem
     especificada devem ser colocados no pixmap de destino. O campo-bit
     e' especificado por meio de um inteiro em um dos formatos
     conhecidos (decimal, octal, hexadecimal). Os canais dos dados
     fonte sa~o sempre enumerados consecutivamente. Se, e.g.
     `NOMEDOARQUIVO' ou `DADOS_LIT_IMAGEM' especificam um imagem
     (provavelmente RGB ...) de tre^s canais e `MASCDEST' for igual a
     `0xD' (i.e. o primeiro bit e' 0), enta~o o terceiro canal do
     pixmap fonte pode ser substitui'do no quarto canal do objeto
     imagem de destino (o canal alfa), o segundo canal pode determinar
     o valor de destino `azul' e o primeiro canal da fonte determina o
     valor de destino correspondente ao `vermelho'.

     O nu'mero de canais dos dados fontes sempre tem que coincidir com
     o nu'mero de bits especificado como `MASCDEST'. Excec,a~o: se o
     pixmap fonte possui somente um canal, enta~o o nu'mero de canais
     dos dados fonte pode ser usado para preencher qualquer nu'mero de
     canais de destino; todos os canais especificados em `MASCDEST'
     sa~o preenchidos com os dados do canal simples do pixmap fonte.

     Geomview conhece as seguintes constantes simbo'licas, que podem
     ser usadas em lugar de especificar o campo-bit `MASCDEST'
     numericamente:
    `LUMINANCE'
          o mesmo que `1', `0x1', `\01'

    `LUMINANCE_ALPHA'
          o mesmo que `3', `0x3', `\03'

    `RGB'
          o mesmo que `7', `0x7', `\07'

    `RGBA'
          o mesmo que `15', `0xf', `\017'

    `ALPHA'
          dependendo do contexto: o nu'mero absoluto de canais deve
          obrigatoriamente ser conhecido; i.e. `data ALPHA ...' deve
          obrigatoriamente ser colocado antes de alguma coisa de forma
          a determinar o nu'mero de canais da imagem, e.g.
               ...
               data RGB ...
               data ALPHA
               ...
          e' va'lido, mas
               <nenhumoutrocanalouespecificac,a~odedadosdeimagem>
               data ALPHA ...
               <todo o resto ...>
          na~o e' va'lido, porque Geomview na~o tem meios de determinar
          o canal de destino a partir do contexto.

    `AUTO'
          Dados de imagem no formato PGM e' interpretado como canal
          simples em escala de cinza, dados RGB PNM como dados de
          imagem RGB. `AUTO' na~o pode trabalhar com dados de imagem no
          formato `raw'.

`FILTER'
     A especificac,a~o `FILTER' e' opcional. se for omitida, enta~o
     Geomview tenta determinar o tipode imagem usando o sufixo de
     `NOMEDOARQUIVO'. Se a~o houver sufixo ou o sufixo for
     desconhecido, ou para dados embutidos de imagem, Geomview esta'
     apto a auto-detectar  o formato do arquivo de imagem SGI (por
     razo~es histo'ricas ...) e formatos de imagem NetPBM (por razo~es
     pra'ticas). A auto-detecc,a~o de formatos NetPBM incluem o novo
     formato de imagem "PAM" que permite (em meio a um monte de outras
     coisas) armazenar um canal alfa juntamente com os dados de
     lumina^nica ou de RGB. Da mesma forma, a sai'da final de qualquer
     dos filtros especificados devem ou ser no formato de arquivo de
     imagem SGI, ou especificar uma imagem PAM, PNM ou PGM.  Se o
     formato de arquivo de imagem na~o puder ser determinado por ou
     pelo sufixo do nome de arquivo ou pela especificac,a~o de filtro
     ou pela auto-detecc,a~o de dados SGI ou NetPBM, enta~o Geomview
     assume que os dados sejam "raw". Veja abaixo.

     Os filtros de descompressa~o podem ser deduzidos ou de um dos
     formatos de imagem conhecidos ou de um especificador de filtro
     expli'cito, e.g. o seguinte e' va'lido:
          data LUMINANCE raw.gzip { < arquivoemtonsdecinzagzipado }
     A linha acima deve ser equivalente a
          data LUMINANCE raw { < arquivoemtonsdecinza },
     fornece dados descomprimidos realizados atrave's de dados de canal
     simples, com o primeiro pixel correspondendo ao canto inferior
     esquerdo (devido ao formato `raw' de imagem, veja abaixo).

     Geomview tem conhecimento interno dos seguintes filtros/sufixos:
    Descompressa~o de Dados

         `z'

         `gz'

         `gzip'
               os dados sa~o direcionados por `gzip -dc'

         `bz2'

         `bzip2'
               os dados sa~o direcionados por `bzip2 -dc'

    Formatos de Imagem

         `tiff'

         `tif'
               Formato de imagem `TIFF'. Somente suportado se o
               executa'vel `tifftopnm' puder ser executado no caminho
               de execuc,a~o atual.

         `png'
               Formato de imagem `PNG'. Somente suportado se o
               executa'vel `pngtopnm' puder ser executado no caminho de
               execuc,a~o atual.

         `jpg'

         `jpeg'
               Formato de imagem `JPEG'. Somente suportado se o
               executa'vel `jpegtopnm' puder ser executado no caminho
               de execuc,a~o atual.

         `gif'
               Formato de imagem `GIF' image file format. Somente
               suportado se o executa'vel `giftoppm' puder ser
               executado no caminho de execuc,a~o atual.

         `raw'
               Dados de imagem em Raw; o nu'mero de canais deve
               coincidir com o nu'mero de bits informado em `MASCDEST'.
               Pixels sa~o especificados com 1 byte por canal. Os
               pixels sa~o organizados em linhas como em
               `liminance[-alpha]' ou em amostras `RGB[A]'. O pixel
               mais a` esquerda e' o primeiro pixel em cada linha de
               dados, a linha de dados mais acima deve vir
               primeiramente (isso e' apenas o mesmo que a convenc,a~o
               de NetPBM, os sistemas de coordenadas de imagem te^m sua
               ori'gem no canto superior esquerdo, da forma usual).

    Filtros Explicitamente Especificados
          Se nenhum dos sufixos especificados acima coincidirem, enta~o
          o sufixo/filtro e' interpretado como um filtro de programa
          externo; o programa do filtro externo deve ler de `STDIN' (da
          entrada padra~o) e escrever para `STDOUT' (a sai'da padra~o).
          A sai'da deve ou ser no formato de imagem SGI, ou no formatos
          de image PNM ou PGM. De outra forma os dados de sai'da sa~o
          interpretados como dados de imagem no formato raw (veja
          acima).

          Alguma coisa como o seguinte pode trabalhar, garantindo que o
          programa `${HOME}/bin/bububfilter' exista, seja executa'vel e
          fac,a alguma coi'sa u'til:
               ...
               data RGB "${HOME}/bin/bububfilter.bzip2" 7
               { # dados bina'rios seguem
               bububub
               }
               ...

          Note que - previamente fornecendo os dados para `bububfilter'
          - Geomview ira' tentar descompactar o material com `bzip2
          -dc'.



   Omitindo dados de imagem: Normalmente, o nu'mero de canais de imagem
e' determinado automaticamente a partir das especificac,o~es dos
`dados' de imagem; se a especificac,a~o de imagem carrega um nu'mero
expli'cito de canais via palavra chave `channels' que excede o nu'mero
de canais encontrado nas especificac,o~es de `dados', ou se a unia~o de
todas as especificac,o~es `MASCDEST' possuem buracos, enta~o omitindo
lumina^ncia e canais RGB sa~o initializados para 0, e um canal alfa
omitido e' inicializado para `maxval', i.e. omitindo os dados do canal
alfa para uma imagem RGBA e' apenas o mesmo que definir uma imagem RGB.


File: geomview-pt_BR,  Node: transform objects,  Next: ntransform objects,  Prev: image objects,  Up: Objetos nao-geometricos

4.3.3 Objetos de Transformac,a~o
--------------------------------

Onde uma matriz simples 4x4 e' esperada - como no campo de `transform'
`INST', a transformac,a~o da ca^mera `camtoworld' e os comandos do
Geomview `xform*' - use um objeto de transformac,a~o.

   Note que uma transformac,a~o e' diferente de uma `TLIST', que e' um
tipo de geometria.  `TLIST's podem conter uma ou mais transformac,o~es
4x4; objetos "transform" devem ter exa-tamente uma.

   Por que temos ambos ("transform" e TLIST)?  Em muitos lugares - e.g.
posicionamento de ca^meras - e' somente significativo ter uma
transofrmac,a~o simples.  Usando um tipo separado de objeto reforc,a
isso.

   A sintaxe para um objeto de transformac,a~o "transform" e'

     <transform> ::=
       [ "{" ]             (Abertura de chave, geralmente necessa'rio para
                            tornar o fim do objeto claramente explicitado.)

        [ "transform" ]    (palavra chave opcional; desnecessa'ria se o tipo
                            for determinado pelo contexto, o que comumente
                            ocorre.)
        [ "define" <nome> ]
                           (define uma transformac,a~o chamada <nome>,
                           escolhendo seus valores do material adiante)

           <dezesseis nu'meros em ponto flutuante>
                           (interpretado como uma transformac,a~o homoge^nea 4x4
     		       fornecida linha por linha, intencionalmente aplicada a um
                            vetor linha multiplicado a` ESQUERDA, de forma que
                            e.g. translac,o~es euclidianas aparec,am na linha
                            inferior)
        |
           "<" <nomedearquivo>  (significando: leia a transformac,a~o a partir
                            daquele arquivo)
        |
           ":" <nome>      (significando: use a varia'vel <nome>,
                             definida em algum lugar; se na~o definido o valor
                             inicial e' a transformac,a~o identidade)

      [ "}" ]              (fechamento de chave correspondente)

   O conjunto pode ser colocado entre { chaves }.  As chaves na~o sa~o
essenciais se exatamente um dos itens acima estiver presente, enta~o
e.g. um array 4x4 de nu'meros em ponto flutuante independente na~o
precisa necessariamente ter chaves.

   Alguns exemplos, em contextos onde eles podem ser usados:

     # Exemplo 1: Um comando GCL para definir uma transformac,a~o
     # chamada "fred"

     (read transform { transform  define fred
              1 0 0 0
              0 1 0 0
              0 0 1 0
             -3 0 1 1
         }
     )

     # Exemplo 2:  Um objeto ca^mera usando a transformac,a~o
     # "fred" para posicionamento de ca^mera
     # Fornecida a definic,a~o acima, isso coloca a ca^mera em
     # (-3, 0, 1), olhando na direc,a~o -Z.

     { camera
             halfyfield 1
             aspect 1.33
             camtoworld { : fred }
     }


File: geomview-pt_BR,  Node: ntransform objects,  Next: Objeto camera,  Prev: transform objects,  Up: Objetos nao-geometricos

4.3.4 Objetos ND-Transform
--------------------------

Onde - no contexto de visualizac,a~o NDimensional - uma matriz simples
(N+1)x(N+1) e' esperada - como no campo `INST' `ntransform', ou a
`ND-xform*' (veja comandos *note GCL::) - use um objeto `ntransform'.

   `ntransform' sa~o matrizes de transformac,a~o NLINHAS x NCOLUNAS
onde usualmente NLINHAS = N+1 no contexto de objetos N-dimensionais e
visualizac,a~o. A componente homoge^nea de uma `ntransform' situa-se na
coluna zero (em oposic,a~o a objetos `transform' comuns onde a
componente homoge^nea situa-se na coluna tre^s). Objetos `ntransform'
trabalham sobre pontos de qualquer dimensa~o: se um ponto e' para ser
transformado atrave's de um objeto `ntransform' e a dimensa~o do ponto
na~o coincide com o nu'mero de linhas do objeto `ntransform', enta~o ou
o ponto esta' implicitamente preenchido com zeros para coincidir com
NLINHAS ou a matriz esta' implicitamente preenchida com unidades abaixo
de sua diagonal principal (e zeros em todas as outras posic,o~es) de
forma que a matriz ira' trabalhar como a matriz identidade sobre as
dimenso~es excedentes do ponto de entrada.

   A sintaxe para um objeto `ntransform' e'

     <ntransform> ::=
       [ "{" ]             (abertura de chave, geralmente necessa'ria para
                            tornar o fim do objeto claramente explicitado.)

        [ "ntransform" ]    (palavra chave opcional; desnecessa'ria se o tipo
                            for determinado pelo contexto, o que
                            comumente ocorre.)

        [ "define" <nome> ]
                            (define uma transformac,a~o chamada <nome>,
                            escolhendo seus valores do material adiante)

          NLINHAS NCOLUNAS
                            (nu'mero de linhas e colunas da matriz,
                            tipicamente N+1 N+1, mas qualquer dimensa~o
                            e' possi'vel)
          <NLINHAS x NCOLUNAS nu'meros em ponto flutuante>
                            (interpretados como uma transformac,a~o homoge^nea
                            NLINHAS x NCOLUNAS fornecida linha por linha,
                            pretensamente a ser aplicada a um vetor linha
                            multiplicado a` ESQUERDA, de forma que e.g.
                            translac,o~es Euclideanas aparecem na linha mais
                            acima -- em oposic,a~o a objetos de
                            transformac,a~o comuns onde as
                            translac,o~es aparecem na linha mais inferior)
        |
           "<" <nomedearquivo>  (significando: leia a transformac,a~o daquele
                            arquivo)
        |
           ":" <nome>      (significando: use a varia'vel <nome>,
                           definida em algum lugar; se na~o for definida o
                           valor inicial e' a transformac,a~o identidade)

      [ "}" ]             (correspondente fechamento de chave)

   O conjunto deve ser delimitado entre { chaves }.  Chaves na~o sa~o
necessariamente essenciais, de forma que e.g. dois inteiros - NLINHAS
NCOLUNAS - seguidos por um array composto de NLINHAS x NCOLUNAS
nu'meros em ponto flutuante independentes pode mas na~o precisa ter
chaves.

   Alguns exemplos, em contextos onde eles possivelmente podem ser
usados:

     # Exemplo 1: Um comando GCL para definir uma transformac,a~o `6x6' chamada
     # "fred", uma mera translac,a~o por meio do vetor `-3 0 1 1 0'. Essa
     # transformac,a~o e' significativa para um espac,o pentadimensional, com uma componente
     # homoge^nea um i'ndice zero.

     (read ntransform { ntransform  define fred
              6 6
              1 -3 0 1 1 0
              0  1 0 0 0 0
              0  0 1 0 0 0
              0  0 0 1 0 0
              0  0 0 0 1 0
              0  0 0 0 0 1
         }
     )

     # Exemplo 2: Escolhe o ND-xform de um objeto -- um geome'trico ou um grupo de
     # cameras. Fornecendo a definic,a~o acima, o ND-xform escolhido coloca o objeto em (-3 0 1 1
     # 0) no espac,o pentadimensional.

     (ND-xform-set focus : fred)

     # ou

     (ND-xform-set g1 : fred)


File: geomview-pt_BR,  Node: Objeto camera,  Next: window objects,  Prev: ntransform objects,  Up: Objetos nao-geometricos

4.3.5 ca^mera
-------------

Um objeto ca^mera especifica as seguintes propriedades de uma ca^mera:

posic,a~o e orientac,a~o
     especificada por ou uma transformac,a~o camera para o objeto mundo
     ou uma transformac,a~o de objeto mundo para a ca^mera; essa
     transformac,a~o na~o inclui a projec,a~o, de forma que essa
     transformac,a~o e' tipicamente apenas uma composic,a~o de
     translac,a~o e rotac,a~o.  Especificado como um objeto transform,
     tipicamente uma matriz 4x4.

"focus" - dista^ncia focal
     Ao inve's de sugerir uma dista^ncia ti'pica da ca^mera ao objeto de
     interesse; usada para o posicionamento padra~o da ca^mera (a
     ca^mera e' colocada em (X,Y,Z) = (0,0,focus) quando resetada) e
     para ajustar o campo de visa~o quando alternando entre os modos de
     visualizac,a~o ortogra'fico e perspectivo.

raza~o de aspecto da janela
     A verdadeira raza~o de aspecto no sentido <Xsize>/<Ysize>.  Essa
     raza~o de aspecto normalmente pode concordar com a raza~o de
     aspecto da janela de camera.  Geomview normalmente ajusta a raza~o
     de aspecto de suas ca^meras para coincidir com suas janelas
     associadas.

dista^ncia de plano de corte pro'ximo e distante
     Note que ambas as dista^ncias devem ser estritamente maiores que
     zero.  Razo~es de dista^ncia <distante>/<pro'ximo> muito grandes
     fazem com que a a'rea de armazenamento tempora'rio do eixo Z
     comporte-se de forma pe'ssima; parte de um objeto pode ser
     visi'vel mesmo se estiver em algum lugar mais distante que outro.

campo de visa~o
     Especificado em uma das duas formas a seguir.
    `fov'
          e' o campo de visa~o - em graus se perpectivo, ou dista^ncia
          linear se ortogra'fico - na _menor_ direc,a~o.

    `halfyfield'
          e' metade do campo projetado no eixo Y, em coordenadas do
          objeto mundo (na~o angulo!), em unidades de dista^ncia a
          partir da ca^mera.  Para uma ca^mera em perpectiva, halfyfield
          e' relacionado ao campo angular:

                  halfyfield = tan( Y_axis_angular_field / 2 )

          enquanto para uma ca^mera em visa~o ortogra'fica temos
          simplesmente:

                      halfyfield = Y_axis_linear_field / 2

     Essa definic,a~o singular de visualizac,a~o e' (a) maneira fa'cil
     de fazer ca'lculos que a envolvam e (b) e' bem definida em ambas
     as formas de visualizac,a~o ortogra'fica e perspectiva.

cor de fundo
     Argumentavelmente (de forma discuti'vel) na~o e' uma propriedade
     de uma ca^mera, mas da cena (do cena'rio). Todavia, como na~o
     existe o objeto "cordefundo" no OOGL, e a cor de fundo pode na~o
     ser uma propriedade do equipamento de desenho, essa propriedade
     pode ser especificada aqui. No momento em que esse manual esta'
     sendo escrito, todavia, a interface gra'fica de usua'rio (GUI)
     sempre sobrescreve a cor de fundo com suas pro'prias escolhas.

imagem de fundo
     Pelas mesmas razo~es mostradas acima,somente a referida GUI na~o
     sobrescreve essa opc,a~o. A imagem e' centralizada em
     "Normalized-Device-Coordinates"/NDC `(0,0,-1)'; a imagem na~o e'
     redimensonada, apenas dese-nhada por tra's de tudo mais como e'.
     Veja *note Objetos de imagem: image.


   A sintaxe para uma ca^mera e':

     <nomecamera> ::=

        [ "camera" ]                 (palavra chave opcional)
         [ "{" ]                    (abertura de chave, geralmente requerida)
             [ "define" <nome> ]

             "<" <nomearquivo>
           |
             ":" <nome>
           |
                                     (ou qualquer nu'mero dos seguintes,
                                      em qualquer ordem...)

             "perspective"  {"0" | "1"}            (padra~o 1)
                                             (de outra forma "ortographic")

             "stereo"       {"0" | "1"}            (padra~o 0)
                                             (de outra forma mono)

             "worldtocam" <transformac,a~o>        (veja a sintaxe de transfor-
                                             mac,a~o acima)

             "camtoworld" <transformac,a~o>
                                     (nenhum ponto na especificac,a~o de ambos
                                      camtoworld e worldtocam; se e'
                                      restingido para ser o inverso de                                                the other)

             "halfyfield" <meio-campo-linear-Y-em-unidade-de-dista^ncia>
                                     (o padra~o e' tan 40/2 graus)
                                     Nota de traduc,a~o:40 e' o valor padra~o
                                     do campo de visa~o (fov).

             "fov"           (campo de visa~o angular se "perspective",
                              campo de visa~o linear em caso contra'rio.
                              Medido em qualquer direc,a~o e' menor,
                              dando a raza~o aspecto.  Quando a raza~o de
                              aspecto muda -- e.g. quando uma janela e'
                              reajustada -- "fov" e' preservado.)

             "frameaspect" <raza~o-de-aspecto>    (X/Y) (padra~o 1.333)

             "near"  <dista^ncia-de-corte-pro'xima>        (padra~o 0.1)

             "far"   <dista^ncia-de-corte-afastada>     (padra~o 10.0)

             "focus" <dista^ncia-focal>                 (padra~o 3.0)

             "bgcolor" <cor RGB(A) em ponto flutuanter>
                                                     (padra~o 1/3 1/3 1/3 1)

             "bgimage" { <especificac,a~o de imagem> }
                                             (padra~o nenhuma imagem de fundo)


          [ "}" ]                       (correspondente fechamento de chave)


File: geomview-pt_BR,  Node: window objects,  Prev: Objeto camera,  Up: Objetos nao-geometricos

4.3.6 Janela
------------

Um objeto janela especifica tamanho, posic,a~o, e outras informac,o~es
relacionadas ao sistema de janelas sobre uma janela de forma que essas
informac,o~es sejam independentes do dispositivo.

   A sintaxe de um objeto janela e':

     nomejanela ::=

     	[ "window" ]			(palavra chave opcional)
     	  [ "{" ]			(abertura de chave, requerida na maioria das vezes)

     	    			(qualquer dos seguintes, em qualquer ordem)

     		"size"  <tamanhox> <tamanhoy>
     				(tamanho da janela)

     		"position"  <xmin> <xmax> <ymin> <ymax>
     				(posic,a~o & tamanho)


     		"noborder"
     				(especifica se a janela pode
     				 ter ou na~o uma borda)

     		"pixelaspect"  <aspecto>
     			    (especifica a raza~o de aspecto real visualizada
     			     de um pixel nessa janela no sentido
     			     tamanhox/tamanhoy, normalmente 1.0.
     			     Para hardware stereo o qual corta o
     			     display verticalmente por um fator de 2,
     			     ``pixelaspect 0.5'' pode funcionar.
     			     O valor e' usado no ca'lculo da
     			     projec,a~o de uma ca^mera associada a
     			     essa janela.)

     	  [ "}" ]			(correspondente fechamento de chave)

   Objetos janela sa~o usados em `janelas' do Geomview e em comandos do
painel de interac,a~o/interface com o usua'rio (`ui-panel') para
escolher propriedades padronizadas para futuras janelas ou mudar as
mesmas propriedades padronizadas de uma janela existente. Veeja *note
`(window ...)': window. Veja tambe'm *note `(ui-panel ...)': ui-panel.


File: geomview-pt_BR,  Node: Customizacao,  Next: Modulos,  Prev: Formatos dos Arquivos da OOGL,  Up: Top

5 Customizac,a~o: arquivos `.geomview'
**************************************

Quando Geomview e' inciado, ele chama e executa comando em um arquivo
de inicializac,a~o dependente do sistema operacional chamado
`.geomview'.  Esse arquivo esta' no subdireto'rio `data' do direto'rio
de distribuic,a~o do Geomview e conte'm comandos GCL para configurar
Geomview de uma forma comum para todos os usua'rios no sistema.

   A seguir, Geomview procura o arquivo `~/.geomview' (`~' corresponde
a seu direto'rio base).  Voce^ pode usar esse arquivo para configurar
seu pro'prio comportamento padra~o do Geomview de forma que ele se
ajuste a`s suas prefere^ncias.

   Apo's a leitura de `~/.geomview', Geomview procura por um arquivo
chamado `.geomview' no direto'rio atual.  Se tal arquivo existir
Geomview le^ esse arquivo, a menos que esse arquivo seja o mesmo que
`~/.geomview' (o que pode ser o caso se voce^ estiver executando o
Geomview a partir de seu direto'rio base).  Voce^ pode usar o
`.geomview' do direto'rio atual para criar uma personalizac,a~o no
Geomview especi'fica para um certo projeto.

   Voce^ pode usar arquivos `.geomview' para controlar todos os tipos
de coisa no Geomview.  Eles podem conter quaisquer declarac,o~es GCL
va'lidas.  Especialmente u'til e' o comando `ui-panel' que controla a
localizac,a~o inicial dos paine'is do Geomview.  Para um exemplo veja o
arquivo dependente do sistema `.geomview' mencionado acima.  Veja *note
GCL::. Veja *note `(ui-panel ...)': ui-panel.

   Uma boa ide'ia colocar juntos todos os comandos que voce^ coloca em
um arquivo `.geomview' em uma declarac,a~o `progn' com o objetivo de
fazer com que Geomview execute todos de uma so' vez.  Caso voce^ na~o
fac,a isso Geomview possivelmente pode executar esses comando
seque^ncialmente sobre os primeiros poucos ciclos de atualizac,a~o
apo's a incializac,a~o.

   Para modificar, e.g. a poli'tica de focalizac,a~o da janela de
ca^mera de forma que ela selecione a poli'tica de focalizac,a~o do
gerenciador de janela (em lugar de ser ativada quando o cursor do mouse
cruza a janela), voce^ pode colocar o seguinte no seu arquivo
`~/.geomview':

     (progn
       (ui-cam-focus focus-change)
       ... # other stuff
     )

   Voce^ pode colocar qualquer comando `GCL' va'lido nos seus arquivos
`.geomview', Veja *note GCL::. Veja *note `(progn ...)': progn. Veja
*note `(ui-cam-focus ...)': ui-cam-focus.


File: geomview-pt_BR,  Node: Modulos,  Next: GCL,  Prev: Customizacao,  Up: Top

6 Mo'dulos Externos
*******************

Um mo'dulo externo e' um programa que interage com Geomview.  Um
mo'dulo comunica-se com Geomview atrave's de GCL e pode controlar
qualquer aspecto do Geomview que voce^ possa controlar atrave's da
interface de usua'rio do Geomview.

   Em muitos casos um mo'dulo externo e' um programa especializado que
imprementa algum algori'tmo matema'tico que cria um objeto geome'trico
que modifica apare^ncia a` medida que o algori'tmo progride. O mo'dulo
informa ao Geomview da nova apare^ncia do objeto a cada passo, de forma
que o objeto aparenta evoluir com o tempo na janela do Geomview.  Dessa
modo Geomview serve como um _ferramenta de exibic,a~o_ para o mo'dulo.

   Um mo'dulo externo pode ser interativo.  Esse mo'dulo pode responder
a eventos de mouse e a eventos de teclado que ocorram em uma janela do
Geomview, dessa forma extendendo a capacidade do Geomview propriamente
dito.

* Menu:

* Interface::                   Como Mo'dulos Externos Interagem com Geomview.
* Example1::                    Mo'dulo Externo Simples.
* Example2::                    Mo'dulo Externo Simples com Painel de Controle FORMS.
* XForms::                      A Biblioteca XForms.
* Example3::                    Mo'dulo Externo com Comunicac,a~o Bi-Direcional.
* Example4::                    Mo'dulo Simples em Tcl/Tk Demonstrando Selecionar.
* Module Installation::         Instalac,a~o de Mo'dulo.


File: geomview-pt_BR,  Node: Interface,  Next: Example1,  Prev: Modulos,  Up: Modulos

6.1 Como Mo'dulos Externos Interagem com o Geomview
===================================================

Mo'dulos externos aparecem no navegador de Mo'dulos (_Modules_) no
painel principal (_Main_) do Geomview.  Para executar um mo'dulo,
clique no bota~o esquerdo do mouse sobre a entrada do mo'dulo no
navegador.  Enquanto o mo'dulo estiver sendo executado, uma linha
adicional para aquele mo'dulo ira' aparecer no navegador.  Essa linha
inicia-se com um nu'mero entre colche^tes, que indica o nu'mero de
_insta^ncia_ do mo'dulo.  (Para alguns mo'dulos faz sentido ter mais de
uma insta^ncia do mo'dulo sendo executado ao mesmo tempo.)  Voce^ pode
encerrar um mo'dulo externo atrave's de um clique sobre sua entrada
vermelha de insta^ncia.

   Por padra~o quando Geomview inicia, mostra todos os mo'dulos que
tiverem sido insta-lados no seu sistema.

   Para instruc,o~es sobre intalac,a~o de algum mo'dulo no seu sistema
de forma que esse mo'dulo aparec,a no navegador de mo'dulos (_Modules_)
toda vez que Geomview estiver sendo executado por algue'm no seu
sistema, veja *note Module Installation::.

   Quando Geomview chama um mo'dulo externo, cria pipes conectados a`s
sai'das e a`s entradas padra~o do modulo. (Pipes sa~o como arquivos
exceto que eles sa~o usados para comunicac,a~o entre programas em lugar
de armazenar coisas em um disco.)  Geomview interpreta qualquer coisa
que o modulo escreve em sua sai'da padra~o como um comando GCL.  Da
mesma forma, Se um mo'dulo externo requisita qualquer dado do Geomview,
Geomview escreve aquele dado para a entrada padra~o do mo'dulo.  Dessa
forma tudo que um mo'dulo tem de fazer com o objetivo de comunicar-se
com Geomview e' escrever comandos para sua sai'da padra~o e
(opcionalmente) receber dados de sua entrada padra~o.  Note que isso
significa que o mo'dulo na~o pode usar a entrada padra~o e a sai'da
padra~o para comunicar-se com o usua'rio.  Se um mo'dulo precisar
comunicar-se com o usua'rio isso pode ser feito ou atrave's de um
painel de controle nele pro'prio ou em caso contra'rio atrave's de
respostas a certos eventos que esse mo'dulo encontrar como sai'da vinda
do Geomview.


File: geomview-pt_BR,  Node: Example1,  Next: Example2,  Prev: Interface,  Up: Modulos

6.2 Exemplo 1: Mo'dulo Externo Simples
======================================

Essa sec,a~o fornece um mo'dulo externo extremamente simples que mostra
uma malha oscilando.  Para experimentar esse exemplo, fac,a uma co'pia
do arquivo `example1.c' (esse arquivo e' distribui'do com Geomview no
subdiretio `doc') em seu direto'rio e compile `example1.c'  com o
comando

     cc -o example1 example1.c -lm

   A seguir coloque a linha

     (emodule-define "Example 1" "./example1")

em um arquivo chamado `.geomview' no seu direto'rio atual.  A seguir
chame o Geomview; E' importante que voce^ compile o programa exemplo,
crie o arquivo `.geomview' e chame o Geomview a partir do mesmo
direto'rio.  Voce^ pode ver "Example 1" no navegador  de mo'dulos
(_Modules_) do painel principal (_Main_) do Geomview; clique sobre essa
entrada no navegador para iniciar o mo'dulo.  Uma superfi'cie deve
aparecer na sua janela de ca^mera e deve estar oscilando.  Voce^ pode
parar o mo'dulo clicando sobre a linha "[1] Example 1" no navegador de
mo'dulos (_Modules_).

     /*
      * example1.c: oscillating mesh
      *
      * This example module is distributed with the Geomview manual.
      * If you are not reading this in the manual, see the "External
      * Modules" chapter of the manual for more details.
      *
      * This module creates an oscillating mesh.
      */

     #include <math.h>
     #include <stdio.h>

     /* F is the function that we plot
      */
     float F(x,y,t)
          float x,y,t;
     {
       float r = sqrt(x*x+y*y);
       return(sin(r + t)*sqrt(r));
     }

     main(argc, argv)
          char **argv;
     {
       int xdim, ydim;
       float xmin, xmax, ymin, ymax, dx, dy, t, dt;

       xmin = ymin = -5;             /* Set x and y            */
       xmax = ymax = 5;              /*    plot ranges         */
       xdim = ydim = 24;             /* Set x and y resolution */
       dt = 0.1;                     /* Time increment is 0.1  */

       /* Geomview setup.  We begin by sending the command
        *            (geometry example { : foo})
        * to Geomview.  This tells Geomview to create a geom called
        * "example" which is an instance of the handle "foo".
        */
       printf("(geometry example { : foo })\n");
       fflush(stdout);

       /* Loop until killed.
        */
       for (t=0; ; t+=dt) {
         UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t);
       }
     }

     /* UpdateMesh sends one mesh iteration to Geomview.  This consists of
      * a command of the form
      *    (read geometry { define foo
      *       MESH
      *       ...
      *    })
      * where ... is the actual data of the mesh.  This command tells
      * Geomview to make the value of the handle "foo" be the specified
      * mesh.
      */
     UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t)
          float xmin, xmax, ymin, ymax, t;
          int xdim, ydim;
     {
       int i,j;
       float x,y, dx,dy;

       dx = (xmax-xmin)/(xdim-1);
       dy = (ymax-ymin)/(ydim-1);

       printf("(read geometry { define foo \n");
       printf("MESH\n");
       printf("%1d %1d\n", xdim, ydim);
       for (j=0, y = ymin; j<ydim; ++j, y += dy) {
         for (i=0, x = xmin; i<xdim; ++i, x += dx) {
           printf("%f %f %f\t", x, y, F(x,y,t));
         }
         printf("\n");
       }
       printf("})\n");
       fflush(stdout);
     }

   O mo'dulo inicia-se definindo uma func,a~o `F(x,y,t)' que especifica
uma superfi'cie va-riando com o tempo.  O propo'sito do mo'dulo e'
animar essa superfi'cie com o passar do tempo.

   O programa principal comec,a definindo algumas varia'veis que
especificam os para^metros com os quais a func,a~o e' para ser mostrada.

   O pro'ximo pedac,o de co'digo no programa principal envia a seguinte
linha para a sai'da padra~o

     (geometry example { : foo })

   Isso diz ao Geomview para criar um geom chamado `example' que e' uma
insta^ncia do manipulador `foo'.  _Manipuladores_ sa~o uma parte do
formato de arquivo OOGL que permite a voce^ nomear uma pec,a do objeto
geome'trico cujo valor pode ser especificado em seu lugar (e nesse caso
atualizado muitas vezes); para maiores informac,o~es sobre
manipuladores, veja *note Formatos dos Arquivos da OOGL::. Nesse caso,
`example' e' o ti'tulo atrave's do qual o usua'rio ira' ver o objeto no
navegador de objeto do Geomview, e `foo' e' o nome interno do
manipulador para o qual o objeto aponta.

   No's enta~o fazemos `fflush(stdout)' para garantir que Geomview
receba esse comando imediatamente.  Em geral, uma vez que pipes podem
ser colocados em uma a'rea de memo'ria tempora'ria de armazenamento, um
mo'dulo externo deve fazer isso sempre que esse mo'dulo externo tenha
que garantir que Geomview tenha atualmente recebido tudo que tenha sido
mostrado na sai'da.

   A u'ltima coisa no programa principal e' um ciclo infinito que
circula atrave's de chamadas ao procedimento `UpdateMesh' com
incremento dos valores de `t'.  `UpdateMesh' envia ao Geomview um
comando da forma

     (read geometry { define foo
     MESH
     24 24
     ...
     })

onde `...' e' uma longa lista de nu'meros.  Esse comando diz ao Geomview
fazer os valores do manipulador `foo' ser a malha especificada.  Ta~o
breve quanto Geomview receba esse comando, o geom sendo mostrado muda
para refletir o novo objeto geome'trico.

   A malha e' fornecida no formato de uma OOGL MESH.  Esse formato
comec,a com a palavra chave `MESH'.  A seguir temos dois nu'meros que
fornecem as dimenso~es x e y da malha; nesse caso elas sa~o ambas 24.
Essa linha e' seguida por 24 linhas, cada linha contendo 24 trios de
nu'meros.  Cada um desses trios representa um ponto sobre  superfi'cie.
Enta~o finalmente existe uma linha com "`})'" nesse formato que termina
o "`{'" que iniciou a declarac,a~o `define' e o "`('" que iniciou o
comando.  Para mais detalhes sobre o formato de dados MESH, veja *note
MESH::.

   Esse mo'dulo pode ser escrito sem o uso de manipuladores escrevendo
comandos da forma

     (geometry example {
     MESH
     24 24
     ...
     })

Nesse primeiro tempo Geomview recebe um comando e dessa forma pode criar
um geom chamado `example' com os dados fornecidos da `MESH'.
Subsequentemente comandos `(geometry example ...)' podem fazer com que
Geomview substitua a geometria do geom `example' com os novos dados da
`MESH'.  Se realizado dessa forma pode na~o ser necessa'rio enviar o
comando inicial `(geometry example { : foo })' como dito acima.  A
te'cnica do manipulador e' u'til, todavia, porque essa te'cnica pode
ser usada em situac,o~es mais gerais onde um manipulador representa
somente parte de um complexo geom, permitindo a um mo'dulo externo
substituir somente aquela parte sem ter que retransmitir o geom
completo.  Para mais informac,o~es sobre manipuladores, veja *note
GCL::. Veja *note Referencias::. Veja *note `(hdefine ...)': hdefine.
Veja *note `(read ...)': read.

   O mo'dulo entra em ciclos atrave's de chamadas a `UpdateMesh' que
fornece como sai'da comandos da forma acima um apo's o outro ta~o
ra'pido quanto possi'vel.  O ciclo continua indefinidamente; o mo'dulo
ira' terminar quando o usua'rio fizer isso clicando sobre sua linha de
insta^ncia no navegador de mo'dulos (_Modules_), ou em caso contra'rio
quando Geomview for encerrado.

   Algumas vezes quando voce^ encerra o mo'dulo clicando sobre sua
entrada de insta^ncia no navegador de mo'dulos (_Modules_), Geomview
ira' encerra'-lo enquanto o mo'dulo esta' no meio de um comando ao
Geomview.  Geomview ira' enta~o receber somente uma pec,a de um comando
e ira' mostrar uma cri'tica mas inofensiva mensagem de erro sobre isso.
uando um mo'dulo tiver um painel de interface com o usua'rio o usua'rio
pode usar um bota~o "Quit" para fornecer uma forma mais elegante para o
usua'rio encerrar o mo'dulo.  Veja o exemplo seguinte.

   Voce^ pode usar esse mo'dulo em uma janela de shell sem o Geomview
para ver os comando que o mo'dulo mostra como sai'da.  Voce^ ira' ter
que encerra'-lo com `ctrl-C' para que ele pare.


File: geomview-pt_BR,  Node: Example2,  Next: XForms,  Prev: Example1,  Up: Modulos

6.3 Exemplo 2: Mo'dulo Externo Simples Usando o Painel de Controle FORMS
========================================================================

Nota de traduc,a~o: Este exemplo e' muito antigo e na~o compila nas
ma'quinas atuais. Ate' o momento de digitac,a~o destas linhas de
traduc,a~o ele na~o tinha sido atualizado permanecendo portanto
inoperante.

   Essa sec,a~o fornece uma nova versa~o do mo'dulo acima -- uma
versa~o que inclue uma interface de usua'rio para controlar a
velocidade da oscilac,a~o.  Usamos a biblioteca FORMS criada por Mark
Overmars para o painel de controle.  A biblioteca FORMS e' uma
colec,a~o de ferramentas para interface de usua'rio de domi'nio
pu'blico para IRISes.  Para experimentar esse exemplo, fac,a uma co'pia
do arquivo `example2.c' (distribui'do com Geomview no subdireto'rio
`doc') no seu direto'rio e compile-o com o comando

     cc -I/u/gcg/ngrap/include -o example2 example2.c \
       -L/u/gcg/ngrap/lib/sgi -lforms -lfm_s -lgl_s -lm

   Voce^ pode substituir a seque^ncia de caracteres `/u/gcg/ngrap'
acima com o nome do caminho do direto'rio de distribuic,a~o do Geomview
em seu sistema.  (A biblioteca forms e' distribui'da com Geomview e as
opc,o~es `-I' e `-L' acima dizem ao compilador onde encontra'-las.)

   Enta~o coloque a linha

     (emodule-define "Example 2" "./example2")

em um arquivo chamado `.geomview' no direto'rio e chame Geomview do
mesmo direto'rio.  Clique sobre a entrada "Example 2" no navegador de
mo'dulos (_Modules_) para chamar o mo'dulo.  Um pequeno painel de
controle devera' aparecer.  Voce^ pode enta~o controlar a velocidade da
oscilac,a~o da malha movendo o bota~o deslizante.

     /*
      * example2.c: oscillating mesh with FORMS control panel
      *
      * This example module is distributed with the Geomview manual.
      * If you are not reading this in the manual, see the "External
      * Modules" chapter of the manual for an explanation.
      *
      * This module creates an oscillating mesh and has a FORMS control
      * panel that lets you change the speed of the oscillation with a
      * slider.
      */

     #include <math.h>
     #include <stdio.h>
     #include <sys/time.h>           /* for struct timeval below */

     #include "forms.h"              /* for FORMS library */

     FL_FORM *OurForm;
     FL_OBJECT *VelocitySlider;
     float dt;

     /* F is the function that we plot
      */
     float F(x,y,t)
          float x,y,t;
     {
       float r = sqrt(x*x+y*y);
       return(sin(r + t)*sqrt(r));
     }

     /* SetVelocity is the slider callback procedure; FORMS calls this
      * when the user moves the slider bar.
      */
     void SetVelocity(FL_OBJECT *obj, long val)
     {
       dt = fl_get_slider_value(VelocitySlider);
     }

     /* Quit is the "Quit" bota~o callback procedure; FORMS calls this
      * when the user cliques the "Quit" bota~o.
      */
     void Quit(FL_OBJECT *obj, long val)
     {
       exit(0);
     }

     /* create_form_OurForm() creates the FORMS panel by calling a bunch of
      * procedures in the FORMS library.  This code was generated
      * automatically by the FORMS designer program; normally this code
      * would be in a separate file which you would not edit by hand.  For
      * simplicity of this example, however, we include this code here.
      */
     create_form_OurForm()
     {
       FL_OBJECT *obj;
       FL_FORM *form;
       OurForm = form = fl_bgn_form(FL_NO_BOX,380.0,120.0);
       obj = fl_add_box(FL_UP_BOX,0.0,0.0,380.0,120.0,"");
       VelocitySlider = obj = fl_add_valslider(FL_HOR_SLIDER,20.0,30.0,
                                               340.0,40.0,"Velocity");
         fl_set_object_lsize(obj,FL_LARGE_FONT);
         fl_set_object_align(obj,FL_ALIGN_TOP);
         fl_set_call_back(obj,SetVelocity,0);
       obj = fl_add_button(FL_NORMAL_BUTTON,290.0,75.0,70.0,35.0,"Quit");
         fl_set_object_lsize(obj,FL_LARGE_FONT);
         fl_set_call_back(obj,Quit,0);
       fl_end_form();
     }

     main(argc, argv)
          char **argv;
     {
       int xdim, ydim;
       float xmin, xmax, ymin, ymax, dx, dy, t;
       int fdmask;
       static struct timeval timeout = {0, 200000};

       xmin = ymin = -5;             /* Set x and y            */
       xmax = ymax = 5;              /*    plot ranges         */
       xdim = ydim = 24;             /* Set x and y resolution */
       dt = 0.1;                     /* Time increment is 0.1  */

       /* Forms panel setup.
        */
       foreground();
       create_form_OurForm();
       fl_set_slider_bounds(VelocitySlider, 0.0, 1.0);
       fl_set_slider_value(VelocitySlider, dt);
       fl_show_form(OurForm, FL_PLACE_SIZE, TRUE, "Example 2");


       /* Geomview setup.
        */
       printf("(geometry example { : foo })\n");
       fflush(stdout);

       /* Loop until killed.
        */
       for (t=0; ; t+=dt) {
         fdmask = (1 << fileno(stdin)) | (1 << qgetfd());
         select(qgetfd()+1, &fdmask, NULL, NULL, &timeout);
         fl_check_forms();
         UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t);
       }
     }

     /* UpdateMesh sends one mesh iteration to Geomview
      */
     UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t)
          float xmin, xmax, ymin, ymax, t;
          int xdim, ydim;
     {
       int i,j;
       float x,y, dx,dy;

       dx = (xmax-xmin)/(xdim-1);
       dy = (ymax-ymin)/(ydim-1);

       printf("(read geometry { define foo \n");
       printf("MESH\n");
       printf("%1d %1d\n", xdim, ydim);
       for (j=0, y = ymin; j<ydim; ++j, y += dy) {
         for (i=0, x = xmin; i<xdim; ++i, x += dx) {
           printf("%f %f %f\t", x, y, F(x,y,t));
         }
         printf("\n");
       }
       printf("})\n");
       fflush(stdout);
     }

   O Co'digo inicia-se pela inclusa~o de alguns arquivos de cabec,alho
necassa'rios para o evento ci'clico e para a biblioteca FORMS.  O
co'digo enta~o declara varia'veis globais para manter um ponteiro para
o objeto FORMS do tipo bota~o deslizante e a velocidade `dt'.  Essas
duas varia'veis sa~o do tipo global porque elas sa~o necessa'rias no
procedimento de retorno do bota~o deslizante chamado `SetVelocity', que
faz todas as chamadas a cada vez que o usua'rio move a barra do bota~o
deslizante. `SetVelocity' atualiza o valor da varia'vel `dt' com o novo
valor do bota~o deslizante.

   `Quit' e' o procedimento de chamada de retorno para o bota~o _Quit_;
esse bota~o fornece um caminho elegante para o usua'rio encerrar o
programa.

   O procedimento `create_panel' chama um conjunto de procedimentos da
biblioteca FORMS para ajustar o painel de controle com o bota~o
deslizante e o bota~o simples.  Para mais informac,a~o sobre o uso de
FORMS para criar paine'is de interface veja a documentac,a~o de FORMS.
Em particular, FORMS vem com um desenhista de painel gra'fico que
conduz voce^ a desenhar seus paine'is de forma interativa e a gerar
co'digos como o co'digo em `create_panel'.

   Esse programa principal exemplo e' similar ao exemplo anterior, mas
inclui codificac,a~o extra para lidar com ajustes e gerenciamento o
painel FORMS.

   Para ajustar o painel chamamos o procedimento GL `foreground' para
fazer com que o processo execute em primeiro plano.  Por padra~o
programas GL executam em segundo plano, e por va'rias razo~es mo'dulos
externos que usam FORMS (que e' baseado em GL) precisa executar em
primeiro plano.  Chamamos enta~o `create_panel' para criar o painel e
`fl_set_slider_value' para ajustar o valor inicial do bota~o
deslizante.  A chamada a `fl_show_form' faz com que o painel aparec,a
na tela.

   As primeiras tre^s linhas do ciclo principal, iniciam-se com
     fdmask = (1 << fileno(stdin)) | (1 << qgetfd());
   monitora e conduz os eventos no painel.  A chamada a `select' impo~e
uma espera a cada passagem pelo ciclo principal.  Essa chamada retorna
ou apo's uma espera de 1/5 de segundo ou quando o evento GL seguinte
ocorrer, ou quando dados aparecerem na entrada padra~o, o que acontecer
primeiro.  A varia'vel `timeout' especifica a quantidade de tempo a
esperar nessa chamada; o primeiro nu'mero (0 nesse exemplo) fornece o
nu'mero de segundos, e o segundo nu'mero (200000 nesse exemplo) fornece
o nu'mero de microsegundos.  Finalmente, `fl_check_forms()' procura e
executa quaisquer eventos FORMS que tenham ocorridos; nesse caso isso
significa uma chamada a `SetVelocity' se o usua'rio iver movido o
bota~o deslizante ou uma chamada a `Quit' se o usua'rio tiver clicado
no bota~o _Quit_.

   O propo'sito da espera no ciclo e' para prevenir que o programa use
excessivamente o tempo da CPU executando seu ciclo pincipal quando na~o
hoverem eventos a serem processados.  Isso na~o e' ta~o crucial nesse
exemplo, e de fato pode tornar a animac,a~o mais lenta ate' certo
ponto, mas em geral com mo'dulos extrnos que possuirem eventos
ci'clicos essa espera e' importante para do something like this because
otherwise the module will needlessly take que os ciplos da CPU sigam
adiante para outros programamas que estejam sendo executados (tais como
Geomview!) mesmo quando estes na~o estiverem fazendo nada.

   A u'ltima linha do ciclo principal ensse exemplo, a chamada a
`UpdateMesh', e' a mesma que no exemplo anterior.


File: geomview-pt_BR,  Node: XForms,  Next: Example3,  Prev: Example2,  Up: Modulos

6.4 A Biblioteca XForms
=======================

XForms e' uma interface de usua'rio ou conjunto de ferramentas muito
fa'cil de encontrar e relativamente simples para X11.  Muitos mo'dulos
externos do Geomview, incluindo os exemplos nesse manual, usam XForms
para criar e gerenciar paine'is de controle. XForms esta' disponi'vel
no si'tio `http://www.nongnu.org/xforms/'. XForms e' free-ware.  Se
voce^ quiser pode usar qualquer outro conjunto de ferramentas como
interface ao inve's de XForms em um mo'dulo externo.  Escolhemos FORMS
pelo fato de omesmo ser livre e relativamente simples.

   Existe um pacote completo baseado na ferramenta autoconf
`gvemod-xforms-example' disponi'vel no si'tio do Geomview
Sourceforge.NET (http://geomview.sourceforge.net).


File: geomview-pt_BR,  Node: Example3,  Next: Example4,  Prev: XForms,  Up: Modulos

6.5 Exemplo 3: Mo'dulo Externo com Comunicac,a~o Bi-Direcional
==============================================================

Os dois mo'dulos exemplo anteriores simplesmente enviam comandos ao
Geomview sem receber nada de volta do Geomview.  Esta sec,a~o descreve
um mo'dulo que se comuica em ambas as direc,o~es.  Existe dois tipos de
comunicac,a~o que podem ir do Geomview para um mo'dulo externo.  Esse
exemplo mostra comunicac,a~o _sem sincronismo_ -- o mo'dulo precisa
estar apto a responder a qualquer momento a expresso~es que o Geomview
possa emitir as quais informam ao mo'dulo de alguma modificac,a~o de
estado dentro do Geomview.

   (O outro tipo de comunicac,a~o e' _com sincronismo_, onde um mo'dulo
envia uma requisic,a~o ao Geomview sobre alguma pec,a de informac,a~o e
espera por uma resposta venha de volta antes de fazer qualquer coisa a
mais.  O principal comando GCL para requisitar informac,a~o desse tipo
e' *note `(write ...)': write.  Esse mo'dulo exemplo na~o faz nada com
comunicac,a~o sincronizada.)

   Na comnicac,a~o sem sincronismo, Geomview envia expresso~es que sa~o
essencialmente ecos de comandos GCL.  O mo'dulo externo envia ao
Geomview um comando expressando interesse em um certo comando, e enta~o
toda vez que Geomview executar o referido comando, o mo'dulo recebe uma
co'pia dele.  O envio de informac,a~o ocorre independentemente de que
envia o comando ao Geomview; a requisic,a~o pode ser resultado do
usua'rio fazendo alguma coisa com o painel do Geomview, ou pode vir de
outro mo'dulo ou de um arquivo que o Geomview leu.  E' dessa forma que
um mo'dulo descobre informac,o~es e age sobre coisas que ocorrem no
Geomview.

   Esse exemplo usa a biblioteca em lisp da OOGL para analisar e agir
sobre as expresso~es que Geomview escreve para a entrada padra~o do
mo'dulo.  Essa biblioteca faz atualmente parte do Geomview propriamente
dito -- escrevemos a biblioteca no processo de implementac,a~o da GCL.
Essa biblioteca lisp da OOGL tambe'm e' conveniente para ser usada em
mo'dulos externos que devem entender um subconjunto da GCL --
especificamente, aqueles comandos que o mo'dulo tem interesse expresso.

   Esse exemplo mostra como um mo'dulo pode receber eventos de
selec,a~o de usua'rio, i.e.  quando o usua'rio clicar  com o bota~o
direito do mouse com o cursor sobre um geom em uma janela de ca^mera do
Geomview.  Quando isso ocorrer Geomview gera uma chamada interna a um
procedimento chamado `pick'; o argumento para o procedimento fornece
informac,a~o sobre a selec,a~o, tal como o objeto que foi selecionado,
as coordenadas co ponto selecionado, etc.  Se um mo'dulo externo tiver
expressado  interesse em chamadas ao procdimento `pick', enta~o sempre
que o procedimento `pick' for chamado Geomview ira' ecoar a chamada a`
entrada padra~o do mo'dulo que manifestou o interesse.  O mo'dulo que
recebe o echo pode enta~o fazer o que desejar caom a informac,a~o do
procedimento pick.

   Esse mo'dulo e' o mesmo que o mo'dulo _Nose_ que vem com o Geomview.
Seu propo'sito e' ilustrar processos de selec,a~o.  Qualquer coisa que
voce^ selecionar sobre um geom por meio de um clique do bota~o direito
do mouse sobre esse geom, o mo'dulo desenha uma pequena caixa na
localizac,a~o onde voce^ tiver clicado.  De forma geral a caixa e'
amarela.  Caso voce^ selecione um ve'rtice, a caixa e' da cor magenta.
Se voce^ selecionar um ponto sobre uma aresta de um objeto, o mo'dulo
ira' tambe'm ressaltar a aresta desenhando caixas da cor ciano em suas
extremidades e desenhar uma linha amarela ao lonfo da aresta.

   Note que para esse mo'dulo fazer alguma coisa voce^ deve ter um geom
carregado no Geomview e voce^ deve cicar com o bota~o direito do mouse
com o cursor sobre uma parte do geom.

     /*
      * example3.c: external module with bi-directional communication
      *
      * This example module is distributed with the Geomview manual.
      * If you are not reading this in the manual, see the "External
      * Modules" chapter of the manual for an explanation.
      *
      * This module is the same as the "Nose" program that is distributed
      * with Geomview.  It illustrates how a module can find out about
      * and respond to user pick events in Geomview.  It draws a little box
      * at the point where a pick occurrs.  The box is yellow if it is not
      * at a vertex, and magenta if it is on a vertex.  If it is on an edge,
      * the program also marks the edge.
      *
      * To compile:
      *
      *   cc -I/u/gcg/ngrap/include -g -o example3 example3.c \
      *      -L/u/gcg/ngrap/lib/sgi -loogl -lm
      *
      * You should replace "/u/gcg/ngrap" above with the pathname of the
      * Geomview distribution directory on your system.
      */

     #include <stdio.h>
     #include "lisp.h"               /* We use the OOGL lisp library */
     #include "pickfunc.h"           /* for PICKFUNC below */
     #include "3d.h"                 /* for 3d geometry library */

     /* boxstring gives the OOGL data to define the little box that
      * we draw at the pick point.  NOTE:  It is very important to
      * have a newline at the end of the OFF objeto in this string.
      */
     char boxstring[] = "\
     INST\n\
     transform\n\
     .04 0 0 0\n\
     0 .04 0 0\n\
     0 0 .04 0\n\
     0 0 0 1\n\
     geom\n\
     OFF\n\
     8 6 12\n\
     \n\
     -.5 -.5 -.5     # 0   \n\
     .5 -.5 -.5      # 1   \n\
     .5  .5 -.5      # 2   \n\
     -.5  .5 -.5     # 3   \n\
     -.5 -.5  .5     # 4   \n\
     .5 -.5  .5      # 5   \n\
     .5  .5  .5      # 6   \n\
     -.5  .5  .5     # 7   \n\
     \n\
     4 0 1 2 3\n\
     4 4 5 6 7\n\
     4 2 3 7 6\n\
     4 0 1 5 4\n\
     4 0 4 7 3\n\
     4 1 2 6 5\n";

     progn()
     {
       printf("(progn\n");
     }

     endprogn()
     {
       printf(")\n");
       fflush(stdout);
     }

     Initialize()
     {
       extern LObject *Lpick();  /* This is defined by PICKFUNC below but must */
       			    /* be used in the following LDefun() call */
       LInit();
       LDefun("pick", Lpick, NULL);

       progn(); {
         /* Define handle "littlebox" for use later
          */
         printf("(read geometry { define littlebox { %s }})\n", boxstring);

         /* Express interest in pick events; see Geomview manual for explanation.
          */
         printf("(interest (pick world * * * * nil nil nil nil nil))\n");

         /* Define "pick" objeto, initially the empty list (= null objeto).
          * We replace this later upon receiving a pick event.
          */
         printf("(geometry \"pick\" { LIST } )\n");

         /* Make the "pick" objeto be non-pickable.
          */
         printf("(pickable \"pick\" no)\n");

         /* Turn off normalization, so that our pick objeto will appear in the
          * right place.
          */
         printf("(normalization \"pick\" none)\n");

         /* Don't draw the pick objeto's bounding box.
          */
         printf("(bbox-draw \"pick\" off)\n");

       } endprogn();
     }

     /* The following is a macro call that defines a procedure called
      * Lpick().  The reason for doing this in a macro is that that macro
      * encapsulates a lot of necessary stuff that would be the same for
      * this procedure in any program.  If you write a Geomview module that
      * wants to know about user pick events you can just copy this macro
      * call and change the body to suit your needs; the body is the last
      * argument to the macro and is delimited by curly braces.
      *
      * The first argument to the macro is the name of the procedure to
      * be defined, "Lpick".
      *
      * The next two arguments are numbers which specify the sizes that
      * certain arrays inside the body of the procedure should have.
      * These arrays are used for storing the face and path information
      * of the picked objeto.  In this module we don't care about this
      * information so we declare them to have length 1, the minimum
      * allowed.
      *
      * The last argument is a block of code to be executed when the module
      * receives a pick event.  In this body you can refer to certain local
      * variables that hold information about the pick.  For details see
      * Example 3 in the Extenal Modules chapter of the Geomview manual.
      */
     PICKFUNC(Lpick, 1, 1,
     {
       handle_pick(pn>0, &point, vn>0, &vertex, en>0, edge);
     },
     /* version for picking Nd-objects (not documented here) */)

     handle_pick(picked, p, vert, v, edge, e)
          int picked;                /* was something actually picked?     */
          int vert;                  /* was the pick near a vertex?        */
          int edge;                  /* was the pick near an edge?         */
          HPoint3 *p;                /* coords of pick point               */
          HPoint3 *v;                /* coords of picked ve'rtice            */
          HPoint3 e[2];              /* coords of endpoints of picked edge */
     {
       Normalize(&e[0]);             /* Normalize makes 4th coord 1.0 */
       Normalize(&e[1]);
       Normalize(p);
       progn(); {
         if (!picked) {
           printf("(geometry \"pick\" { LIST } )\n");
         } else {
           /*
            * Put the box in place, and color it magenta if it's on a ve'rtice,
            * yellow if not.
            */
           printf("(xform-set pick { 1 0 0 0  0 1 0 0  0 0 1 0  %g %g %g 1 })\n",
                  p->x, p->y, p->z);
           printf("(geometry \"pick\"\n");
           if (vert) printf("{ appearance { material { diffuse 1 0 1 } }\n");
           else printf("{ appearance { material { diffuse 1 1 0 } }\n");
           printf("  { LIST { :littlebox }\n");

           /*
            * If it's on an edge and not a vertex, mark the edge
            * with cyan boxes at the endpoins and a black line
            * along the edge.
            */
           if (edge && !vert) {
             e[0].x -= p->x; e[0].y -= p->y; e[0].z -= p->z;
             e[1].x -= p->x; e[1].y -= p->y; e[1].z -= p->z;
             printf("{ appearance { material { diffuse 0 1 1 } }\n\
       LIST\n\
        { INST transform 1 0 0 0 0 1 0 0 0 0 1 0 %f %f %f 1 geom :littlebox }\n\
        { INST transform 1 0 0 0 0 1 0 0 0 0 1 0 %f %f %f 1 geom :littlebox }\n\
        { VECT\n\
               1 2 1\n\
               2\n\
               1\n\
               %f %f %f\n\
               %f %f %f\n\
               1 1 0 1\n\
        }\n\
       }\n",
                    e[0].x, e[0].y, e[0].z,
                    e[1].x, e[1].y, e[1].z,
                    e[0].x, e[0].y, e[0].z,
                    e[1].x, e[1].y, e[1].z);
           }
           printf("    }\n  }\n)\n");
         }

       } endprogn();

     }

     Normalize(HPoint3 *p)
     {
       if (p->w != 0) {
         p->x /= p->w;
         p->y /= p->w;
         p->z /= p->w;
         p->w = 1;
       }
     }

     main()
     {
       Lake *lake;
       LObject *lit, *val;
       extern char *getenv();

       Initialize();

       lake = LakeDefine(stdin, stdout, NULL);
       while (!feof(stdin)) {

         /* Parse next lisp expression from stdin.
          */
         lit = LSexpr(lake);

         /* Evaluate that expression; this is where Lpick() gets called.
          */
         val = LEval(lit);

         /* Free the two expressions from above.
          */
         LFree(lit);
         LFree(val);
       }
     }

   The code begins by defining procedures `progn()' and `endprogn()'
which begin and end a Geomview `progn' group.  The purpose do Geomview
`progn' command is to group commands together and cause Geomview to
execute them all at once, without refreshing any graphics windows until
the end.  It is a good idea to group blocks of commands that a module
sends to Geomview like this so that the user sees their cumulative
effect all at once.

   Procedure `Initialize()' does various things needed at program
startup time.  It initializes the lisp library by calling `LInit()'.
Any program that uses the lisp library should call this once before
calling any other lisp library functions.  It then calls `LDefun' to
tell the library about our `pick' procedure, which is defined further
down with a call to the `PICKFUNC' macro.  Then it sends a bunch of
setup commands to Geomview, grouped in a `progn' block.  This includes
defining a handle called `littlebox' that stores the geometry da little
box.  Next it sends the command

     (interest (pick world * * * * nil nil nil nil nil))

which tells Geomview to notify us when a pick event happens.

   The syntax of this `interest' statement merece some explanation.  In
general `interest' takes one argument which is a (parenthesized)
expression representing a Geomview function call.  It especifica a type
of call that the module is interested in knowing about.  The arguments
can be any particular argument values, ou the special symbols `*' or
`nil'.  For example, the first argument in the `pick' expression above
is `world'.  This means that the module is interested in calls to
`pick' where the first argument, which especifica the coordinate
system, is `world'.  A `*' is like a wild-card; it means that the
module is interested in calls where the corresponding argument has any
value.  The word `nil' is like `*', except that the argument's value is
not reported to the module.  This is useful for cutting down on the
amount of data that must be transmitted in cases where there are
arguments that the module doesn't care about.

   The second, third, fourth, and fifth arguments to the `pick' command
give the name, pick point coordenadas, coordenadas do ve'rtice, and
edge coordenadas of a pick event.  We specify these by `*''s above.
The remaining five arguments to the `pick' command give other
information about the pick event that we do not care about in this
module, so we specify these with `nil''s.  For the details dos
arguments to `pick', *Note GCL::.

   The `geometry' statement defines a geom called `pick' that is
initially an empty list, specified as ` { LIST } '; this is the best
way of specifying a null geom.  The module will replace this with
something useful by sending Geomview another `geometry' command when
the user picks something.  Next we arrange for the `pick' objeto to be
non-pickable, and turn normalization off for it so that Geomview will
display it in the size and location where we put it, rather than
resizing and relocating it to fit into the unit cube.

   The next function in the file, `Lpick', is defined with a strange
looking call to a macro called `PICKFUNC', defined in the header file
`pickfunc.h'.  This is the function for handling pick events.  The
reason we provide a macro for this is that that macro encapsulates a
lot of necessary stuff that would be the same for the pick-handling
function in any program.  If you write a Geomview module that wants to
know about user pick events you can just copy this macro call and change
it to suit yours needs.

   In general the syntax for `PICKFUNC' is
     PICKFUNC(NAME, BLOCK, NDBLOCK)
   where NAME is the name do procedure to be defined, in this case
`Lpick'. The next argument, BLOCK, is a block of code to be executed
when a pick event occurs.  If BLOCK contains a return statement, then
the returned value must be a pointer to a Lisp-objeto, that is of type
`LObject *'. The last argument has the same functionality as the BLOCK
argument, but is only invoked when picking objetos in a higher
dimensional world.

   `PICKFUNC' declares certain local variables in the body do
procedure. When the module receives a `(pick ...)' statement from
Geomview, the procedure assigns values to these variables based on the
information in the `pick' call (variables corresponding to `nil''s in
the `(interest (pick ...))' are not given values).

   There is also a second variant da `PICKFUNC' macro with a slightly
different syntax:
     DEFPICKFUNC(HELPSTR, COORDSYS, ID,
       POINT, PN, VERTEX, VN, EDGE, EN, FACE, FN, PPATH, PPN,
       VI, EI, EIN, FI,
       BODY, NDBODY)
   `DEFPICKFUNC' can be used as well as `PICKFUNC', there is no
functional differene with the exception that the name da C-function is
tied to `Lpick' when using `DEFPICKFUNC' and that the `(help pick)'
GCL-command (*note `(help ...)': help.)  would respond with echoing
HELPSTR.

   The table below lists all variables defined in `PICKFUNC' In the
context of ND-viewing `float' variants dos arguments apply: the BODY
execution block sees the `HPoint3' variables, and the NDBODY block sees
only flat one-dimensional arrays of `float'-type.

   In the ND-viewing context the co-ordinates passed to the pick
function are still the 3-dimensional co-ordinates da ca^mera view-port
where the pick occurred, but padded with zeroes on transformed back to
the co-ordinate system specified by the second argument do `pick'
command.

`char *coordsys;'
     A string specifying the coordinate system in which coordenadas are
     given.  In this example, this will always be `world' because do
     `interest' call above.

`char *id;'
     A string specifying the name do picked geom.

`HPoint3 point; int pn;'

`float *point; int pn;'
     `point' is an `HPoint3' structure giving the coordenadas of the
     picked point.  `HPoint3' is a homogeneous point coordinate
     representation equivalent to an array of 4 floats. `pn' tells how
     many coordenadas have been written into this array; it will always
     be either `0', `4' ou greater than `4'. If it is greater than `4',
     then the NDBODY instruction block is invoked and in this case
     `point' is a flat array of `pn' many `float's.  A value of zero
     means no point was picked, i.e. the user clicado the bota~o
     direito do mouse while the cursor was not pointing at a geom. In
     this case the ordinary BLOCK 3d instruction block is executed.

`HPoint3 vertex; int vn;'

`float *vertex; int vn;'
     `vertex' is an `HPoint3' structure giving the coordenadas of the
     ve'rtice selecionado, if the pick point was near a ve'rtice.  `vn'
     tells how many coordenadas have been written into this array; it
     will always be either `0' ou greater equal `4'. A value of zero
     means the pick point was not near a ve'rtice. In the context of
     ND-viewing `vertex' will be an array of `vn' `float's and `vn'
     will be equal to `pn'.

`HPoint3 edge[2]; int en;'

`float *edge; int en;'
     `edge' is an array of two `HPoint3' structures giving the
     coordenadas do endpoints da picked edge, if the pick point was
     near an edge.  `en' tells how many coordenadas have been written
     into this array; it will always be `0' ou greater equal `8'.  A
     value of zero means the pick point was not near an edge. In the
     context of ND-viewing `edge' will be a flat one-dimensional array
     of `en' many `float's: the first `pn' `float's define the first
     ve'rtice, and the second `pn' many `float's define the second
     ve'rtice; `en' will be two times `pn'.


   In this example module, the remaining variables will never be given
values because their values in the `interest' statement were specified
as `nil'.

`HPoint3 face[]; int fn;'

`float *face; int fn;'
     `face' is a variable length array of FN `HPoint3''s.  `face' gives
     the coordenadas dos ve'rtices da picked face.  `fn' tells how many
     coordenadas have been written into this array; it will always be
     either `0' ou a multiple of `pn'. A value of zero means the pick
     point was not near a face. In the context of ND-viewing `face' is
     a flat one-dimensional array of `fn' many floats of which each
     ve'rtice occupies `pn' many componentes.

`int ppath[]; int ppn;'
     `ppath' is an array of MAXPATHLEN `int''s.  `ppath' gives the path
     through the OOGL heirarchy to the picked primitive.  `pn' tells
     how many integers have been written into this array; it will be at
     most MAXPATHLEN.  A path of {3,1,2}, for example, means that the
     picked primitive is "subobjeto number 2 of subobjeto number 1 of
     objeto 3 in the world".

`int vi;'
     `vi' gives the index do ve'rtice selecionado in the picked
     primitive, if the pick point was near a ve'rtice.

`int ei[2]; int ein'
     The `ei' array gives the indices dos endpoints da picked edge, if
     the pick point was near a ve'rtice.  `ein' tells how many integers
     were written into this array.  It will always be either 0 ou 2; a
     value of 0 means the pick point was not near an edge.

`int fi;'
     `fi' gives the index da picked face in the picked primitive, if
     the pick point was near a face.


   The `handle_pick' procedure actually does the work of dealing with
the pick event.  It begins by normalizing the homogeneous coordenadas
passed in as arguments so that we can assume the fourth coordinate is 1.
It then sends GCL commands to define the `pick' objeto to be whatever
is appropriate for the kind of pick recieved.  Veja *note Formatos dos
Arquivos da OOGL::, and veja *note GCL::, for an explanation do format
dos data in these commands.

   The main program, at the bottom do file, first calls `Initialize()'.
Next, the call to `LakeDefine' defines the `Lake' that the lisp library
will use.  A `Lake' is a structure that the lisp library uses
internally as a type of communiation vehicle.  (It is like a unix
stream but more general, hence the name.)  This call to `LakeDefine'
defines a `Lake' structure for doing I/O with `stdin' and `stdout'.
The third argument to `LakeDefine' should be `NULL' for external modules
(it is used by Geomview).  Finally, the program enters its main loop
which parses and evaluates expressions from standard input.


File: geomview-pt_BR,  Node: Example4,  Next: Module Installation,  Prev: Example3,  Up: Modulos

6.6 Example 4: Simple Tcl/Tk Module Demonstrating Picking
=========================================================

It's not necessary to write a Geomview module in C.  The only
requirement of an external module is that it send GCL commands to its
standard output and expect responses (if any) on its standard input.
An external module can be written in C, perl, tcl/tk, ou pretty much
anything.

   As an example, assuming you have Tcl/Tk version 4.0 ou later, here's
an external module with a simple GUI which demonstrates interaction with
geomview.  This manual doesn't discuss the Tcl/Tk language; see the
good book on the subjeto by its originator John Ousterhout, published
by Addison-Wesley, titled _Tcl and the Tk Toolkit_.

   The `#!' on the script's first line causes the system to interpret
the script using the Tcl/Tk `wish' program; you might have to change its
first line if that's in some location other than /usr/local/bin/wish4.0.
Or, you could define it as a module using
       (emodule-define  "Pick Demo"  "wish pickdemo.tcl")
   in which case `wish' could be anywhere on the UNIX search path.

     #! /usr/local/bin/wish4.0

     # We use "fileevent" below to have "readsomething" be called whenever
     # data is available from standard input, i.e. when geomview has sent us
     # something.  It promises to include a trailing newline, so we can use
     # "gets" to read the geomview response, then parse its nested parentheses
     # into tcl-friendly {} braces.

     proc readsomething {} {
       if {[gets stdin line] < 0} {
             puts stderr "EOF on input, exiting..."
             exit
       }
       regsub -all {\(} $line "\{" line
       regsub -all {\)} $line "\}" line
       # Strip outermost set of braces
       set stuff [lindex $line 0]
       # Invoke handler for whichever command we got.  Could add others here,
       # if we asked geomview for other kinds of data as well.
       switch [lindex $stuff 0] {
             pick     {handlepick $stuff}
             rawevent {handlekey $stuff}
       }
     }

     # Fields of a "pick" response, from geomview manual:
     #     (pick COORDSYS GEOMID G V E F P VI EI FI)
     #          The pick command is executed internally in response to pick
     #          events (right mouse double clique).
     #
     #          COORDSYS = coordinate system in which coordenadas of the following
     #              arguments are specified.   This can be:
     #               world: world coord sys
     #               self:  coord sys of the picked geom (GEOMID)
     #               primitive: coord sys of the actual primitive within
     #                   the picked geom where the pick occurred.
     #          GEOMID = id of picked geom
     #          G = picked point (actual intersection of pick ray with objeto)
     #          V = picked vertex, if any
     #          E = picked edge, if any
     #          F = picked face
     #          P = path to picked primitive [0 ou more]
     #          VI = index of picked ve'rtice in primitive
     #          EI = list of indices of endpoints of picked edge, if any
     #          FI = index of picked face

     # Report when user picked something.
     #
     proc handlepick {pick} {
       global nameof selvert seledge order
       set obj [lindex $pick 2]
       set xyzw [lindex $pick 3]
       set fv [lindex $pick 6]
       set vi [lindex $pick 8]
       set ei [lindex $pick 9]
       set fi [lindex $pick 10]

       # Report result, converting 4-component homogeneous point into 3-space point.
       set w [lindex $xyzw 3]
       set x [expr [lindex $xyzw 0]/$w]
       set y [expr [lindex $xyzw 1]/$w]
       set z [expr [lindex $xyzw 2]/$w]
       set s "$x $y $z "
       if {$vi >= 0} {
             set s "$s  vertex #$vi"
       }
       if {$ei != {}} {
             set s "$s  edge [lindex $ei 0]-[lindex $ei 1]"
       }
       if {$fi != -1} {
             set s "$s  face #$fi ([expr [llength $fv]/3]-gon)"
       }
       msg $s
     }


     # Having asked for notification of these raw events, we report when
     # the user pressed these keys in the geomview graphics windows.

     proc handlekey {event} {
       global lastincr
       switch [lindex $event 1] {
         32 {msg "Pressed space bar"}
          8 {msg "Pressed backspace key"}
       }
     }


     #
     # Display a message on the control panel, and on the terminal where geomview
     # was started.  We use ``puts stderr ...'' rather than simply ``puts ...'',
     # since Geomview interprets anything we send to standard output
     # as a GCL command!
     #
     proc msg {str} {
       global msgtext
       puts stderr $str
       set msgtext $str
       update
     }

     # Load objeto from file
     proc loadobject {fname} {
       if {$fname != ""} {
             puts "(geometry thing < $fname)"
             # Be sure to flush output to ensure geomview receives this now!
             flush stdout
       }
     }


     # Build simple "user interface"

     # The message area could be a simple label rather than an entry box,
     # but we want to be able to use X selection to copy text from it.
     # The default mouse bindings do that automatically.

     entry .msg -textvariable msgtext -width 45
     pack .msg

     frame .f

       label .f.l -text "File to load:"
       pack .f.l -side left

       entry .f.ent -textvariable fname
       pack .f.ent -side left -expand true -fill x
       bind .f.ent <Return> { loadobject $fname }

     pack .f


     # End UI definition.


     # Call "readsomething" when data arrives from geomview.

     fileevent stdin readable {readsomething}

     # Geomview initialization

     puts {
             (interest (pick primitive))
             (interest (rawevent 32))	# Be notified when user presses space
             (interest (rawevent 8))		# ou backspace keys.
             (geometry thing < hdodec.off)
             (normalization world none)
     }
     # Flush to ensure geomview receives this.
     flush stdout

     wm title . {Sample external module}

     msg "Click right mouse in graphics window"


File: geomview-pt_BR,  Node: Module Installation,  Prev: Example4,  Up: Modulos

6.7 Module Installation
=======================

Essa sec,a~o diz como instalar um mo'dulo externo de forma que voce^
possa invoca'-lo dentro do Geomview.  Existem duas maneiras de instalar
um mo'dulo: voce^ pode installar um mo'dulo _privado_ de forma que o
mo'dulo esteja disponi'vel somente para voce^ mesmo sempre que executar
o Geomview, ou voce^ pode instalar um mo'dulo de _sistema_ de forma que
o mo'dulo esteja disponi'vel para todos os usua'rios do seu sistema
sempre que eles executarem o Geomview.

* Menu:

* Private Module Installation:: Mo'dulos para um U'nico Usua'rio.
* System Module Installation::  Mo'dulos para Todos os Usua'rio do Sistema.


File: geomview-pt_BR,  Node: Private Module Installation,  Next: System Module Installation,  Prev: Module Installation,  Up: Module Installation

6.7.1 Private Module Installation
---------------------------------

O comando `emodule-define' providencia que um mo'dulo aparec,a no
navegador de mo'dulos (_Modules_) do Geomview. O comando recebe dois
arumentos que sa~o seque^ncias de caractere; o primeiro e' o nome que
ira' aparecer no navegador de mo'dulos (_Modules_).  O segundo e' o
comando de shell para executar o mo'dulo; esse nome de shell pode
incluir argumentos (veja *note `(emodule-define ...)': emodule-define.).
Geomview executa esse comando em um subshell quando voce^ da' um clique
sobre a entrada do mo'dulo no navegador.  Por exemplo

     (emodule-define "Foo" "/u/home/modules/foo -x")

adiciona uma linha rotulada "Foo" ao navegador de mo'dulos (_Modules_)
o qual faz com que o comando "/u/home/modules/foo -x" seja executado
quando selecionado.

   Voce^ pode colocar comandos `emodule-define' no seu arquivo
`~/.geomview' para providenciar que certos mo'dulos estejam
disponi'veis sempre que voce^ execute Geomview; veja *note
Customizacao::.  voce^ pode tambe'm executar comandos `emodule-define'
a partir do painel de comandos (_Commands_) para adicionar um mo'dulo a
uma co'pia do Geomview que ja' esteja sendo executada.

   Existem muitos outros comandos GCL para controlar as entradas no
navegador de mo'dulos (_Modules_); para detalhes, veja *note GCL::.


File: geomview-pt_BR,  Node: System Module Installation,  Prev: Private Module Installation,  Up: Module Installation

6.7.2 System Module Installation
--------------------------------

Para instalar um mo'dulo de forma que esse mo'dulo esteja disponi'vel
para todos os usua'rios do Geomview fac,a o seguinte

1.
     Crie um arquivo chamado `.geomview-MO'DULO' `MO'DULO' e' o nome do
     mo'dulo.  Esse arquivo deve conter uma linha simples que e' um
     comando `emodule-define' para aquele mo'dulo:
          (emodule-define "Novo Mo'dulo" "novomodulo")
     O primeiro argumento, `"Novo Mo'dulo"' acima, e' a seque^ncia de
     caracteres que ira' aparecer no navegador de mo'dulo (_Modules_).
     A segunda seque^ncia de caracteres, `"novomodulo"' acima, e' o
     comando de Bourne shell para invocar o mo'dulo.  Esse comando de
     shell pode incluir argumentos, e voce^ pode assumir que o mo'dulo
     encontra-se localizado em $PATH que representa os locais de busca
     do shell.

2.
     Coloque uma co'pia do `.geomview-MO'DULO' e o executa'vel do
     mo'dulo propriamente dito no direto'rio
     `/usr/local/libexec/geomview'.


   Apo's esses passos, o novo mo'dulo deve aparecer, em ordem
alfabe'tica, no navegador de mo'dulos (_Modules_) do Geomview do painel
principal (_Main_) da pro'xima vez que o Geomview for inicializado.  A
raza~o desse trabalho e' que quando Geomview for invocado processara'
todos os arquivos `.geomview-*' em seu direto'rio de `mo'dulos'.
Geomview tambe'm lembra o caminho desse direto'rio e coloca aquele
caminho em $PATH do shell no qual Geomview invoca tal mo'dulo.


File: geomview-pt_BR,  Node: GCL,  Next: Geometrias Nao-Euclidianas,  Prev: Modulos,  Up: Top

7 GCL: a Linguagem de Comandos do Geomview
******************************************

GCL tem a sintaxe do lisp - i.e. uma expressa~o da forma (f a b ...)
significa informar os vallores de a, b, ... para a func,a~o f.  GCL e'
muito limitado e GCL na~o e' de forma alguma uma implementac,a~o de
lisp.  GCL e' simplesmente uma linguagem para expressar comandos que
sa~o executados na ordem fornecida, ao contra'rio de uma linguagem de
programac,a~o.  GCL na~o suporta varia'vel ou definic,a~o de func,a~o.

   GCL e' a linguagem que Geomview entende para arquivos que chama bem
como para comunicac,a~o com outros programas.  Para executar um comando
GCL interativamente, voce^ pode trazer o painel de comandos
(_Commands_) que tra's sua digitac,a~o em um comando; Geomview executa
o comando quando voce^ pressiona a tecla <Enter>.  A sai'da de tais
comandos e' mostrada na sai'da padra~o.  Alternativamente, voce^ pode
invocar Geomview com `geomview -c -' que faz com que o Geomview leia
comandos GCL a partir da entrada padra~o.

   Func,o~es GCL retornam um valor, e voce^ pode concaenar chamadas de
func,a~o de forma que outras func,o~es usem esse valor retornado.  Por
exemplo
     (f (g a b))
   avalia `(g a b)' e enta~o avalia `(f x)' onde `x' e' o resultado
retornado por `(g a b)'.  Geomview mante'm esses valores de retorno
internamente normalmente na~o fornece sai'da alguma com os resultados
guardados.  Para mostrar um valor de retorno esse valor de retorno deve
ser fornecido a` func,a~o `echo'.  Por exemplo a func,a~o
`geomview-version' retorna uma seque^ncia de caracteres representado a
versa~o do Geomview que esta' sendo executada, e
     (echo (geomview-version))
   mostra essa seque^ncia de caracteres.

   Muitas func,a~o simplesmente retornam `t' ( de "true" - verdadeiro)
caso tenham sido executadas como esperado ou `nil' ( nenhum )  em caso
de falha; esse e' o caso se a documentac,a~o para a func,a~o na~o
fornece o retorno esperado.  Esses sa~o os si'mbolos do lisp para
verdadeiro e falso, respectivamente.  (Eles correspondem a`s varia'veis
definidas em C `Lt' e `Lnil' que voce^ vera' se olhar no co'digo fonte
do Geomview ou em algum dos mo'dulos externos.)

   Nas descric,o~es ds comandos acima muitas refer6encias sa~o feitas a
formatos "OOGL" formats.  OOGL e' a linguagem de descric,a~o dos dados
que Geomview utiliza para descrever objetos geome'tricos, ca^meras,
apare^ncias, e outos objetos ba'sicos.  Para detalhes dos formatos
OOGL, veja *note Formatos dos Arquivos da OOGL::.  (Ou
equivalentemente, veja a pa'gina de manual oogl(5), distributed with
Geomview in the file /share/man/man5/oogl.5gv.

   Os comandos GCL e tipos de argumentos sa~o listados abaixo.  A
maioria da documentac,a~o nessa sec,a~o do manual esta' disponi'vel
dentro do Geomview via comandos `?' e `??'.  O comando `(?  COMANDO)'
faz com que Geomview mostre na tela um suma'rio de uma linha da sintaxe
de COMANDO, e `(?? COMANDO)' mostra na tela uma explanac,a~o de o que
COMANDO faz.  Voce^ pode incluir o caractere coringa `*' no COMANDO
para mostrar informac,o~es para um frupo de comandos coincidindo com um
modelo.  Por exemplo, `(?? *emodule*)' ira' mostrar todas as
informac,o~es sobre todos os comandos contendo a seque^ncia de
caracteres `emodule'.  `(? *)' ira' mostrar um lista curta de todos os
comandos.

* Menu:

* Argument Conventions::        Convenc,o~es usadas ao se descrever tipos de argumentos.
* GCL Reference::               Documentac,a~o para cada comandoo GCL.


File: geomview-pt_BR,  Node: Argument Conventions,  Next: GCL Reference,  Prev: GCL,  Up: GCL

7.1 Conventions Used In Describing Argument Types
=================================================

Os seguintes si'mbolos sa~o usados para descrever tipos de argumentos
na documentac,a~o para func,o~es GCL.

`APARE^NCIA'
     e' uma especificac,a~o de apare^ncia OOGL.

`CAM-ID'
     e' uma IDentificac,a~o que refre-se a uma ca^mera.

`CA^MERA'
     e' uma especificac,a~o de ca^mera do OOGL.

`GEOM-ID'
     e' uma IDentificac,a~o que se refere a um objeto geome'trico.

`GEOMETRY'
     e' uma especificac,a~o de objeto geome'trico do OOGL.

`ID'
     e' uma seque^ncia de caracteres que nomeia um objeto geome'trico
     ou ca^mera.  Como aqueles que voce^ cria, os valores permitidos
     sa~o:

    ``World, world, worldgeom, g0''
          a colec,a~o de todos os objetos geome'tricos

    `target'
          objeto alvo selecionado (ca^mera ou objeto geome'trico)

    `center'
          objeto central do movimento selecionado

    `targetcam'
          a u'ltima ca^mera alvo selecionada

    `targetgeom'
          o u'ltimo objeto geome'trico alvo selecionado

    `focus'
          ca^mera onde o cursor esta' (ou mais recentemente esteve)

    `allgeoms'
          todos os objetos geome'tricos

    `allcams'
          todas as ca^meras

    ``default, defaultcam, prototype''
          ca^meras futuras que herdara~o as escolhas padronizadas


     As seguintes IDs sa~o usadas para nomear sistemas de coordenadas,
     e.g. em comandos `pick' e `write':

    ``World, world, worldgeom, g0''
          o objeto mundo, dentro do qual todos os objetos geome'tricos
          vivem.

    `universe'
          o universo, no qual o no qual o objeto mundo, as luzes e as
          ca^meras vivem.  Transformac,o~es world2cam das ca^meras
          podem melhor serem chamadas universe2cam, etc.

    `self'
          "esse objeto do Geomview".  Transforma de um objeto para `si
          mesmo' e' a identidade; escrevendo seu objeto geome'trico
          fornece o bojeto em si mesmo sem executar nenhuma
          transformac,a~o; pontos selecionados aparecem nas coordenadas
          do objeto.

    `primitive'
          (para objetos selecionados (`pick') somente) Pontos
          selecionados aparecem no sistema de coordenadas da primitiva
          de menor ni'vel do OOGL.


     Um nome tambe'm e' uma `id'entificac,a~o aceita'vel.  Fornecimento
     de nomes e' feito u'nico pela anexac,a~o de nu'meros se
     necessa'rio (i.e. `foo<2>'). Todo objeto geome'trico e' tambe'm
     chamado g[n] e toda ca^mera e' tambe'm chamada c[n] (`g0' e'
     sempre o objeto geome'trico mundo - worldgeom): esse nome e' usado
     como um prefixo a comandos de teclado e pode tambe'm ser usado
     como uma identificac,a~o GCL.  Nu'meros sa~o usados apo's um
     objeto ser deletado. Ambos os nomes sa~o mostrados no navegador de
     Objeto.

`DECLARAC,A~O'
     representa uma chamada de func,a~o.  Chamadas a func,o~es possuem
     a forma `(func arg1 arg2 ... )', onde `func' e' o nome da func,a`o
     e `arg1', `arg2', ... sa~o os argumentos.

`TRANSFORMAC,A~O'
     e' uma matriz de transformac,a~o OOGL 4x4.

`NTRANSFORM'
     e' uma matriz de transformac,a~o OOGL (N+1)x(N+1).

`JANELA'
     e' uma especificac,a~o de janela do OOGL.


